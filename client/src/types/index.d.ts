export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: any;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /** The day, does not include a time. */
  Date: any;
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: any;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: any;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>;
  /** Reads and enables pagination through a set of `UserMessage`. */
  userMessages?: Maybe<UserMessagesConnection>;
  /** Reads and enables pagination through a set of `ContactGroup`. */
  contactGroups?: Maybe<ContactGroupsConnection>;
  /** Reads and enables pagination through a set of `ContactGroupPersonContact`. */
  contactGroupPersonContacts?: Maybe<ContactGroupPersonContactsConnection>;
  /** Reads and enables pagination through a set of `Country`. */
  countries?: Maybe<CountriesConnection>;
  /** Reads and enables pagination through a set of `Customer`. */
  customers?: Maybe<CustomersConnection>;
  /** Reads and enables pagination through a set of `CustomerPersonContact`. */
  customerPersonContacts?: Maybe<CustomerPersonContactsConnection>;
  /** Reads and enables pagination through a set of `PersonContact`. */
  personContacts?: Maybe<PersonContactsConnection>;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippers?: Maybe<ShippersConnection>;
  /** Reads and enables pagination through a set of `ShipperPersonContact`. */
  shipperPersonContacts?: Maybe<ShipperPersonContactsConnection>;
  /** Reads and enables pagination through a set of `Warehouse`. */
  warehouses?: Maybe<WarehousesConnection>;
  /** Reads and enables pagination through a set of `WarehousePersonContact`. */
  warehousePersonContacts?: Maybe<WarehousePersonContactsConnection>;
  /** Reads and enables pagination through a set of `ChileDepartureInspectionPallet`. */
  chileDepartureInspectionPallets?: Maybe<ChileDepartureInspectionPalletsConnection>;
  /** Reads and enables pagination through a set of `PeruDepartureInspection`. */
  peruDepartureInspections?: Maybe<PeruDepartureInspectionsConnection>;
  /** Reads and enables pagination through a set of `PeruDepartureInspectionPallet`. */
  peruDepartureInspectionPallets?: Maybe<PeruDepartureInspectionPalletsConnection>;
  /** Reads and enables pagination through a set of `PsaApplePallet`. */
  psaApplePallets?: Maybe<PsaApplePalletsConnection>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  psaArrivalPictures?: Maybe<PsaArrivalPicturesConnection>;
  /** Reads and enables pagination through a set of `PsaArrivalReport`. */
  psaArrivalReports?: Maybe<PsaArrivalReportsConnection>;
  /** Reads and enables pagination through a set of `PsaCherryPallet`. */
  psaCherryPallets?: Maybe<PsaCherryPalletsConnection>;
  /** Reads and enables pagination through a set of `PsaCitrusPallet`. */
  psaCitrusPallets?: Maybe<PsaCitrusPalletsConnection>;
  /** Reads and enables pagination through a set of `PsaGrapePallet`. */
  psaGrapePallets?: Maybe<PsaGrapePalletsConnection>;
  /** Reads and enables pagination through a set of `PsaLemonPallet`. */
  psaLemonPallets?: Maybe<PsaLemonPalletsConnection>;
  /** Reads and enables pagination through a set of `PsaPearPallet`. */
  psaPearPallets?: Maybe<PsaPearPalletsConnection>;
  /** Reads and enables pagination through a set of `PsaPersimmonPallet`. */
  psaPersimmonPallets?: Maybe<PsaPersimmonPalletsConnection>;
  /** Reads and enables pagination through a set of `PsaPomegranatePallet`. */
  psaPomegranatePallets?: Maybe<PsaPomegranatePalletsConnection>;
  /** Reads and enables pagination through a set of `PsaStoneFruitPallet`. */
  psaStoneFruitPallets?: Maybe<PsaStoneFruitPalletsConnection>;
  /** Reads and enables pagination through a set of `AgendaItem`. */
  agendaItems?: Maybe<AgendaItemsConnection>;
  /** Reads and enables pagination through a set of `CalendarEvent`. */
  calendarEvents?: Maybe<CalendarEventsConnection>;
  /** Reads and enables pagination through a set of `PriceCategory`. */
  priceCategories?: Maybe<PriceCategoriesConnection>;
  /** Reads and enables pagination through a set of `PriceEntry`. */
  priceEntries?: Maybe<PriceEntriesConnection>;
  /** Reads and enables pagination through a set of `PriceProduct`. */
  priceProducts?: Maybe<PriceProductsConnection>;
  /** Reads and enables pagination through a set of `PriceSize`. */
  priceSizes?: Maybe<PriceSizesConnection>;
  /** Reads and enables pagination through a set of `InventoryItem`. */
  inventoryItems?: Maybe<InventoryItemsConnection>;
  /** Reads and enables pagination through a set of `PackAtmosphere`. */
  packAtmospheres?: Maybe<PackAtmospheresConnection>;
  /** Reads and enables pagination through a set of `PackBoxStyle`. */
  packBoxStyles?: Maybe<PackBoxStylesConnection>;
  /** Reads and enables pagination through a set of `PackBoxType`. */
  packBoxTypes?: Maybe<PackBoxTypesConnection>;
  /** Reads and enables pagination through a set of `PackDestination`. */
  packDestinations?: Maybe<PackDestinationsConnection>;
  /** Reads and enables pagination through a set of `PackGrade`. */
  packGrades?: Maybe<PackGradesConnection>;
  /** Reads and enables pagination through a set of `PackHold`. */
  packHolds?: Maybe<PackHoldsConnection>;
  /** Reads and enables pagination through a set of `PackLabel`. */
  packLabels?: Maybe<PackLabelsConnection>;
  /** Reads and enables pagination through a set of `PackLiner`. */
  packLiners?: Maybe<PackLinersConnection>;
  /** Reads and enables pagination through a set of `PackMaster`. */
  packMasters?: Maybe<PackMastersConnection>;
  /** Reads and enables pagination through a set of `PackOut`. */
  packOuts?: Maybe<PackOutsConnection>;
  /** Reads and enables pagination through a set of `PackPalletType`. */
  packPalletTypes?: Maybe<PackPalletTypesConnection>;
  /** Reads and enables pagination through a set of `PackProduction`. */
  packProductions?: Maybe<PackProductionsConnection>;
  /** Reads and enables pagination through a set of `PackSpecial`. */
  packSpecials?: Maybe<PackSpecialsConnection>;
  /** Reads and enables pagination through a set of `PackStyle`. */
  packStyles?: Maybe<PackStylesConnection>;
  /** Reads and enables pagination through a set of `PackTreeRipe`. */
  packTreeRipes?: Maybe<PackTreeRipesConnection>;
  /** Reads and enables pagination through a set of `Pallet`. */
  pallets?: Maybe<PalletsConnection>;
  /** Reads and enables pagination through a set of `PalletSection`. */
  palletSections?: Maybe<PalletSectionsConnection>;
  /** Reads and enables pagination through a set of `PalletTempOne`. */
  palletTempOnes?: Maybe<PalletTempOnesConnection>;
  /** Reads and enables pagination through a set of `PalletTempTwo`. */
  palletTempTwos?: Maybe<PalletTempTwosConnection>;
  /** Reads and enables pagination through a set of `ProductMaster`. */
  productMasters?: Maybe<ProductMastersConnection>;
  /** Reads and enables pagination through a set of `ProductSize`. */
  productSizes?: Maybe<ProductSizesConnection>;
  /** Reads and enables pagination through a set of `ProductSpecies`. */
  productSpecieses?: Maybe<ProductSpeciesConnection>;
  /** Reads and enables pagination through a set of `ProductVariety`. */
  productVarieties?: Maybe<ProductVarietiesConnection>;
  /** Reads and enables pagination through a set of `ShipperProjection`. */
  shipperProjections?: Maybe<ShipperProjectionsConnection>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntries?: Maybe<ShipperProjectionEntriesConnection>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts?: Maybe<ShipperProjectionProductsConnection>;
  /** Reads and enables pagination through a set of `ShipperProjectionVessel`. */
  shipperProjectionVessels?: Maybe<ShipperProjectionVesselsConnection>;
  /** Reads and enables pagination through a set of `Vessel`. */
  vessels?: Maybe<VesselsConnection>;
  user?: Maybe<User>;
  userByPin?: Maybe<User>;
  userMessage?: Maybe<UserMessage>;
  contactGroup?: Maybe<ContactGroup>;
  contactGroupPersonContact?: Maybe<ContactGroupPersonContact>;
  country?: Maybe<Country>;
  customer?: Maybe<Customer>;
  customerPersonContact?: Maybe<CustomerPersonContact>;
  personContact?: Maybe<PersonContact>;
  shipper?: Maybe<Shipper>;
  shipperPersonContact?: Maybe<ShipperPersonContact>;
  warehouse?: Maybe<Warehouse>;
  warehousePersonContact?: Maybe<WarehousePersonContact>;
  chileDepartureInspectionPallet?: Maybe<ChileDepartureInspectionPallet>;
  peruDepartureInspection?: Maybe<PeruDepartureInspection>;
  peruDepartureInspectionPallet?: Maybe<PeruDepartureInspectionPallet>;
  psaApplePallet?: Maybe<PsaApplePallet>;
  psaArrivalPicture?: Maybe<PsaArrivalPicture>;
  psaArrivalReport?: Maybe<PsaArrivalReport>;
  psaCherryPallet?: Maybe<PsaCherryPallet>;
  psaCitrusPallet?: Maybe<PsaCitrusPallet>;
  psaGrapePallet?: Maybe<PsaGrapePallet>;
  psaLemonPallet?: Maybe<PsaLemonPallet>;
  psaPearPallet?: Maybe<PsaPearPallet>;
  psaPersimmonPallet?: Maybe<PsaPersimmonPallet>;
  psaPomegranatePallet?: Maybe<PsaPomegranatePallet>;
  psaStoneFruitPallet?: Maybe<PsaStoneFruitPallet>;
  agendaItem?: Maybe<AgendaItem>;
  calendarEvent?: Maybe<CalendarEvent>;
  priceCategory?: Maybe<PriceCategory>;
  priceEntry?: Maybe<PriceEntry>;
  priceProduct?: Maybe<PriceProduct>;
  priceSize?: Maybe<PriceSize>;
  inventoryItem?: Maybe<InventoryItem>;
  packAtmosphere?: Maybe<PackAtmosphere>;
  packAtmosphereByShipperIdAndMaCode?: Maybe<PackAtmosphere>;
  packBoxStyle?: Maybe<PackBoxStyle>;
  packBoxStyleByShipperIdAndBoxStyle?: Maybe<PackBoxStyle>;
  packBoxType?: Maybe<PackBoxType>;
  packBoxTypeByShipperIdAndBoxType?: Maybe<PackBoxType>;
  packDestination?: Maybe<PackDestination>;
  packDestinationByShipperIdAndDestinationCode?: Maybe<PackDestination>;
  packGrade?: Maybe<PackGrade>;
  packGradeByShipperIdAndGradeCode?: Maybe<PackGrade>;
  packHold?: Maybe<PackHold>;
  packHoldByShipperIdAndHoldCode?: Maybe<PackHold>;
  packLabel?: Maybe<PackLabel>;
  packLabelByShipperIdAndLabelCode?: Maybe<PackLabel>;
  packLiner?: Maybe<PackLiner>;
  packLinerByShipperIdAndLinerCode?: Maybe<PackLiner>;
  packMaster?: Maybe<PackMaster>;
  packOut?: Maybe<PackOut>;
  packOutByShipperIdAndOutCode?: Maybe<PackOut>;
  packPalletType?: Maybe<PackPalletType>;
  packPalletTypeByShipperIdAndPalletType?: Maybe<PackPalletType>;
  packProduction?: Maybe<PackProduction>;
  packProductionByShipperIdAndProductionCode?: Maybe<PackProduction>;
  packSpecial?: Maybe<PackSpecial>;
  packSpecialByShipperIdAndCustomerCode?: Maybe<PackSpecial>;
  packStyle?: Maybe<PackStyle>;
  packStyleByShipperIdAndPackStyle?: Maybe<PackStyle>;
  packTreeRipe?: Maybe<PackTreeRipe>;
  packTreeRipeByShipperIdAndTreeRipe?: Maybe<PackTreeRipe>;
  palletSection?: Maybe<PalletSection>;
  palletTempOne?: Maybe<PalletTempOne>;
  palletTempTwo?: Maybe<PalletTempTwo>;
  productMaster?: Maybe<ProductMaster>;
  productSize?: Maybe<ProductSize>;
  productSpecies?: Maybe<ProductSpecies>;
  productVariety?: Maybe<ProductVariety>;
  shipperProjection?: Maybe<ShipperProjection>;
  shipperProjectionEntry?: Maybe<ShipperProjectionEntry>;
  shipperProjectionProduct?: Maybe<ShipperProjectionProduct>;
  shipperProjectionVessel?: Maybe<ShipperProjectionVessel>;
  vessel?: Maybe<Vessel>;
  distinctValues?: Maybe<DistinctValuesConnection>;
  customerDistinctValues?: Maybe<CustomerDistinctValuesConnection>;
  shipperDistinctValues?: Maybe<ShipperDistinctValuesConnection>;
  /** Reads and enables pagination through a set of `ChileDepartureInspection`. */
  chileDepartureInspections?: Maybe<ChileDepartureInspectionsConnection>;
  psaInspectionVesselDistinctValues?: Maybe<PsaInspectionVesselDistinctValuesConnection>;
  pallet?: Maybe<Pallet>;
  vesselArrivalPortDistinctValues?: Maybe<VesselArrivalPortDistinctValuesConnection>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId?: Maybe<User>;
  /** Reads a single `UserMessage` using its globally unique `ID`. */
  userMessageByNodeId?: Maybe<UserMessage>;
  /** Reads a single `ContactGroup` using its globally unique `ID`. */
  contactGroupByNodeId?: Maybe<ContactGroup>;
  /** Reads a single `ContactGroupPersonContact` using its globally unique `ID`. */
  contactGroupPersonContactByNodeId?: Maybe<ContactGroupPersonContact>;
  /** Reads a single `Country` using its globally unique `ID`. */
  countryByNodeId?: Maybe<Country>;
  /** Reads a single `Customer` using its globally unique `ID`. */
  customerByNodeId?: Maybe<Customer>;
  /** Reads a single `CustomerPersonContact` using its globally unique `ID`. */
  customerPersonContactByNodeId?: Maybe<CustomerPersonContact>;
  /** Reads a single `PersonContact` using its globally unique `ID`. */
  personContactByNodeId?: Maybe<PersonContact>;
  /** Reads a single `Shipper` using its globally unique `ID`. */
  shipperByNodeId?: Maybe<Shipper>;
  /** Reads a single `ShipperPersonContact` using its globally unique `ID`. */
  shipperPersonContactByNodeId?: Maybe<ShipperPersonContact>;
  /** Reads a single `Warehouse` using its globally unique `ID`. */
  warehouseByNodeId?: Maybe<Warehouse>;
  /** Reads a single `WarehousePersonContact` using its globally unique `ID`. */
  warehousePersonContactByNodeId?: Maybe<WarehousePersonContact>;
  /** Reads a single `ChileDepartureInspectionPallet` using its globally unique `ID`. */
  chileDepartureInspectionPalletByNodeId?: Maybe<ChileDepartureInspectionPallet>;
  /** Reads a single `PeruDepartureInspection` using its globally unique `ID`. */
  peruDepartureInspectionByNodeId?: Maybe<PeruDepartureInspection>;
  /** Reads a single `PeruDepartureInspectionPallet` using its globally unique `ID`. */
  peruDepartureInspectionPalletByNodeId?: Maybe<PeruDepartureInspectionPallet>;
  /** Reads a single `PsaApplePallet` using its globally unique `ID`. */
  psaApplePalletByNodeId?: Maybe<PsaApplePallet>;
  /** Reads a single `PsaArrivalPicture` using its globally unique `ID`. */
  psaArrivalPictureByNodeId?: Maybe<PsaArrivalPicture>;
  /** Reads a single `PsaArrivalReport` using its globally unique `ID`. */
  psaArrivalReportByNodeId?: Maybe<PsaArrivalReport>;
  /** Reads a single `PsaCherryPallet` using its globally unique `ID`. */
  psaCherryPalletByNodeId?: Maybe<PsaCherryPallet>;
  /** Reads a single `PsaCitrusPallet` using its globally unique `ID`. */
  psaCitrusPalletByNodeId?: Maybe<PsaCitrusPallet>;
  /** Reads a single `PsaGrapePallet` using its globally unique `ID`. */
  psaGrapePalletByNodeId?: Maybe<PsaGrapePallet>;
  /** Reads a single `PsaLemonPallet` using its globally unique `ID`. */
  psaLemonPalletByNodeId?: Maybe<PsaLemonPallet>;
  /** Reads a single `PsaPearPallet` using its globally unique `ID`. */
  psaPearPalletByNodeId?: Maybe<PsaPearPallet>;
  /** Reads a single `PsaPersimmonPallet` using its globally unique `ID`. */
  psaPersimmonPalletByNodeId?: Maybe<PsaPersimmonPallet>;
  /** Reads a single `PsaPomegranatePallet` using its globally unique `ID`. */
  psaPomegranatePalletByNodeId?: Maybe<PsaPomegranatePallet>;
  /** Reads a single `PsaStoneFruitPallet` using its globally unique `ID`. */
  psaStoneFruitPalletByNodeId?: Maybe<PsaStoneFruitPallet>;
  /** Reads a single `AgendaItem` using its globally unique `ID`. */
  agendaItemByNodeId?: Maybe<AgendaItem>;
  /** Reads a single `CalendarEvent` using its globally unique `ID`. */
  calendarEventByNodeId?: Maybe<CalendarEvent>;
  /** Reads a single `PriceCategory` using its globally unique `ID`. */
  priceCategoryByNodeId?: Maybe<PriceCategory>;
  /** Reads a single `PriceEntry` using its globally unique `ID`. */
  priceEntryByNodeId?: Maybe<PriceEntry>;
  /** Reads a single `PriceProduct` using its globally unique `ID`. */
  priceProductByNodeId?: Maybe<PriceProduct>;
  /** Reads a single `PriceSize` using its globally unique `ID`. */
  priceSizeByNodeId?: Maybe<PriceSize>;
  /** Reads a single `InventoryItem` using its globally unique `ID`. */
  inventoryItemByNodeId?: Maybe<InventoryItem>;
  /** Reads a single `PackAtmosphere` using its globally unique `ID`. */
  packAtmosphereByNodeId?: Maybe<PackAtmosphere>;
  /** Reads a single `PackBoxStyle` using its globally unique `ID`. */
  packBoxStyleByNodeId?: Maybe<PackBoxStyle>;
  /** Reads a single `PackBoxType` using its globally unique `ID`. */
  packBoxTypeByNodeId?: Maybe<PackBoxType>;
  /** Reads a single `PackDestination` using its globally unique `ID`. */
  packDestinationByNodeId?: Maybe<PackDestination>;
  /** Reads a single `PackGrade` using its globally unique `ID`. */
  packGradeByNodeId?: Maybe<PackGrade>;
  /** Reads a single `PackHold` using its globally unique `ID`. */
  packHoldByNodeId?: Maybe<PackHold>;
  /** Reads a single `PackLabel` using its globally unique `ID`. */
  packLabelByNodeId?: Maybe<PackLabel>;
  /** Reads a single `PackLiner` using its globally unique `ID`. */
  packLinerByNodeId?: Maybe<PackLiner>;
  /** Reads a single `PackMaster` using its globally unique `ID`. */
  packMasterByNodeId?: Maybe<PackMaster>;
  /** Reads a single `PackOut` using its globally unique `ID`. */
  packOutByNodeId?: Maybe<PackOut>;
  /** Reads a single `PackPalletType` using its globally unique `ID`. */
  packPalletTypeByNodeId?: Maybe<PackPalletType>;
  /** Reads a single `PackProduction` using its globally unique `ID`. */
  packProductionByNodeId?: Maybe<PackProduction>;
  /** Reads a single `PackSpecial` using its globally unique `ID`. */
  packSpecialByNodeId?: Maybe<PackSpecial>;
  /** Reads a single `PackStyle` using its globally unique `ID`. */
  packStyleByNodeId?: Maybe<PackStyle>;
  /** Reads a single `PackTreeRipe` using its globally unique `ID`. */
  packTreeRipeByNodeId?: Maybe<PackTreeRipe>;
  /** Reads a single `PalletSection` using its globally unique `ID`. */
  palletSectionByNodeId?: Maybe<PalletSection>;
  /** Reads a single `PalletTempOne` using its globally unique `ID`. */
  palletTempOneByNodeId?: Maybe<PalletTempOne>;
  /** Reads a single `PalletTempTwo` using its globally unique `ID`. */
  palletTempTwoByNodeId?: Maybe<PalletTempTwo>;
  /** Reads a single `ProductMaster` using its globally unique `ID`. */
  productMasterByNodeId?: Maybe<ProductMaster>;
  /** Reads a single `ProductSize` using its globally unique `ID`. */
  productSizeByNodeId?: Maybe<ProductSize>;
  /** Reads a single `ProductSpecies` using its globally unique `ID`. */
  productSpeciesByNodeId?: Maybe<ProductSpecies>;
  /** Reads a single `ProductVariety` using its globally unique `ID`. */
  productVarietyByNodeId?: Maybe<ProductVariety>;
  /** Reads a single `ShipperProjection` using its globally unique `ID`. */
  shipperProjectionByNodeId?: Maybe<ShipperProjection>;
  /** Reads a single `ShipperProjectionEntry` using its globally unique `ID`. */
  shipperProjectionEntryByNodeId?: Maybe<ShipperProjectionEntry>;
  /** Reads a single `ShipperProjectionProduct` using its globally unique `ID`. */
  shipperProjectionProductByNodeId?: Maybe<ShipperProjectionProduct>;
  /** Reads a single `ShipperProjectionVessel` using its globally unique `ID`. */
  shipperProjectionVesselByNodeId?: Maybe<ShipperProjectionVessel>;
  /** Reads a single `Vessel` using its globally unique `ID`. */
  vesselByNodeId?: Maybe<Vessel>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UserMessagesOrderBy>>;
  condition?: Maybe<UserMessageCondition>;
  filter?: Maybe<UserMessageFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryContactGroupsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContactGroupsOrderBy>>;
  condition?: Maybe<ContactGroupCondition>;
  filter?: Maybe<ContactGroupFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryContactGroupPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContactGroupPersonContactsOrderBy>>;
  condition?: Maybe<ContactGroupPersonContactCondition>;
  filter?: Maybe<ContactGroupPersonContactFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCountriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CountriesOrderBy>>;
  condition?: Maybe<CountryCondition>;
  filter?: Maybe<CountryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerPersonContactsOrderBy>>;
  condition?: Maybe<CustomerPersonContactCondition>;
  filter?: Maybe<CustomerPersonContactFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
  condition?: Maybe<PersonContactCondition>;
  filter?: Maybe<PersonContactFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShippersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperPersonContactsOrderBy>>;
  condition?: Maybe<ShipperPersonContactCondition>;
  filter?: Maybe<ShipperPersonContactFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryWarehousesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WarehousesOrderBy>>;
  condition?: Maybe<WarehouseCondition>;
  filter?: Maybe<WarehouseFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryWarehousePersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WarehousePersonContactsOrderBy>>;
  condition?: Maybe<WarehousePersonContactCondition>;
  filter?: Maybe<WarehousePersonContactFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryChileDepartureInspectionPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ChileDepartureInspectionPalletsOrderBy>>;
  condition?: Maybe<ChileDepartureInspectionPalletCondition>;
  filter?: Maybe<ChileDepartureInspectionPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPeruDepartureInspectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PeruDepartureInspectionsOrderBy>>;
  condition?: Maybe<PeruDepartureInspectionCondition>;
  filter?: Maybe<PeruDepartureInspectionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPeruDepartureInspectionPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PeruDepartureInspectionPalletsOrderBy>>;
  condition?: Maybe<PeruDepartureInspectionPalletCondition>;
  filter?: Maybe<PeruDepartureInspectionPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaApplePalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaApplePalletsOrderBy>>;
  condition?: Maybe<PsaApplePalletCondition>;
  filter?: Maybe<PsaApplePalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaArrivalPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaArrivalPicturesOrderBy>>;
  condition?: Maybe<PsaArrivalPictureCondition>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaArrivalReportsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaArrivalReportsOrderBy>>;
  condition?: Maybe<PsaArrivalReportCondition>;
  filter?: Maybe<PsaArrivalReportFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaCherryPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaCherryPalletsOrderBy>>;
  condition?: Maybe<PsaCherryPalletCondition>;
  filter?: Maybe<PsaCherryPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaCitrusPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaCitrusPalletsOrderBy>>;
  condition?: Maybe<PsaCitrusPalletCondition>;
  filter?: Maybe<PsaCitrusPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaGrapePalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaGrapePalletsOrderBy>>;
  condition?: Maybe<PsaGrapePalletCondition>;
  filter?: Maybe<PsaGrapePalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaLemonPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaLemonPalletsOrderBy>>;
  condition?: Maybe<PsaLemonPalletCondition>;
  filter?: Maybe<PsaLemonPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPearPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaPearPalletsOrderBy>>;
  condition?: Maybe<PsaPearPalletCondition>;
  filter?: Maybe<PsaPearPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPersimmonPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaPersimmonPalletsOrderBy>>;
  condition?: Maybe<PsaPersimmonPalletCondition>;
  filter?: Maybe<PsaPersimmonPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPomegranatePalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaPomegranatePalletsOrderBy>>;
  condition?: Maybe<PsaPomegranatePalletCondition>;
  filter?: Maybe<PsaPomegranatePalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaStoneFruitPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaStoneFruitPalletsOrderBy>>;
  condition?: Maybe<PsaStoneFruitPalletCondition>;
  filter?: Maybe<PsaStoneFruitPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAgendaItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgendaItemsOrderBy>>;
  condition?: Maybe<AgendaItemCondition>;
  filter?: Maybe<AgendaItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCalendarEventsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CalendarEventsOrderBy>>;
  condition?: Maybe<CalendarEventCondition>;
  filter?: Maybe<CalendarEventFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceCategoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceCategoriesOrderBy>>;
  condition?: Maybe<PriceCategoryCondition>;
  filter?: Maybe<PriceCategoryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceEntriesOrderBy>>;
  condition?: Maybe<PriceEntryCondition>;
  filter?: Maybe<PriceEntryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceProductsOrderBy>>;
  condition?: Maybe<PriceProductCondition>;
  filter?: Maybe<PriceProductFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceSizesOrderBy>>;
  condition?: Maybe<PriceSizeCondition>;
  filter?: Maybe<PriceSizeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryInventoryItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InventoryItemsOrderBy>>;
  condition?: Maybe<InventoryItemCondition>;
  filter?: Maybe<InventoryItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackAtmospheresArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackAtmospheresOrderBy>>;
  condition?: Maybe<PackAtmosphereCondition>;
  filter?: Maybe<PackAtmosphereFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxStylesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackBoxStylesOrderBy>>;
  condition?: Maybe<PackBoxStyleCondition>;
  filter?: Maybe<PackBoxStyleFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackBoxTypesOrderBy>>;
  condition?: Maybe<PackBoxTypeCondition>;
  filter?: Maybe<PackBoxTypeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackDestinationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackDestinationsOrderBy>>;
  condition?: Maybe<PackDestinationCondition>;
  filter?: Maybe<PackDestinationFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackGradesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackGradesOrderBy>>;
  condition?: Maybe<PackGradeCondition>;
  filter?: Maybe<PackGradeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackHoldsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackHoldsOrderBy>>;
  condition?: Maybe<PackHoldCondition>;
  filter?: Maybe<PackHoldFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLabelsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackLabelsOrderBy>>;
  condition?: Maybe<PackLabelCondition>;
  filter?: Maybe<PackLabelFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLinersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackLinersOrderBy>>;
  condition?: Maybe<PackLinerCondition>;
  filter?: Maybe<PackLinerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackMastersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackMastersOrderBy>>;
  condition?: Maybe<PackMasterCondition>;
  filter?: Maybe<PackMasterFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackOutsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackOutsOrderBy>>;
  condition?: Maybe<PackOutCondition>;
  filter?: Maybe<PackOutFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackPalletTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackPalletTypesOrderBy>>;
  condition?: Maybe<PackPalletTypeCondition>;
  filter?: Maybe<PackPalletTypeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackProductionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackProductionsOrderBy>>;
  condition?: Maybe<PackProductionCondition>;
  filter?: Maybe<PackProductionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackSpecialsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackSpecialsOrderBy>>;
  condition?: Maybe<PackSpecialCondition>;
  filter?: Maybe<PackSpecialFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackStylesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackStylesOrderBy>>;
  condition?: Maybe<PackStyleCondition>;
  filter?: Maybe<PackStyleFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackTreeRipesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackTreeRipesOrderBy>>;
  condition?: Maybe<PackTreeRipeCondition>;
  filter?: Maybe<PackTreeRipeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PalletsOrderBy>>;
  condition?: Maybe<PalletCondition>;
  filter?: Maybe<PalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletSectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PalletSectionsOrderBy>>;
  condition?: Maybe<PalletSectionCondition>;
  filter?: Maybe<PalletSectionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletTempOnesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PalletTempOnesOrderBy>>;
  condition?: Maybe<PalletTempOneCondition>;
  filter?: Maybe<PalletTempOneFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletTempTwosArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PalletTempTwosOrderBy>>;
  condition?: Maybe<PalletTempTwoCondition>;
  filter?: Maybe<PalletTempTwoFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryProductMastersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductMastersOrderBy>>;
  condition?: Maybe<ProductMasterCondition>;
  filter?: Maybe<ProductMasterFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryProductSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductSizesOrderBy>>;
  condition?: Maybe<ProductSizeCondition>;
  filter?: Maybe<ProductSizeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryProductSpeciesesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductSpeciesOrderBy>>;
  condition?: Maybe<ProductSpeciesCondition>;
  filter?: Maybe<ProductSpeciesFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryProductVarietiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductVarietiesOrderBy>>;
  condition?: Maybe<ProductVarietyCondition>;
  filter?: Maybe<ProductVarietyFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
  condition?: Maybe<ShipperProjectionCondition>;
  filter?: Maybe<ShipperProjectionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionVesselsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselCondition>;
  filter?: Maybe<ShipperProjectionVesselFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVesselsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VesselsOrderBy>>;
  condition?: Maybe<VesselCondition>;
  filter?: Maybe<VesselFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByPinArgs = {
  pin: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserMessageArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContactGroupArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContactGroupPersonContactArgs = {
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCountryArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerPersonContactArgs = {
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonContactArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperPersonContactArgs = {
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWarehouseArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWarehousePersonContactArgs = {
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChileDepartureInspectionPalletArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPeruDepartureInspectionArgs = {
  containerId: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPeruDepartureInspectionPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaApplePalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaArrivalPictureArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaArrivalReportArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaCherryPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaCitrusPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaGrapePalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaLemonPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPearPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPersimmonPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPomegranatePalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaStoneFruitPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAgendaItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCalendarEventArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceCategoryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceEntryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceProductArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceSizeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInventoryItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackAtmosphereArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackAtmosphereByShipperIdAndMaCodeArgs = {
  shipperId: Scalars['String'];
  maCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxStyleArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxStyleByShipperIdAndBoxStyleArgs = {
  shipperId: Scalars['String'];
  boxStyle: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxTypeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxTypeByShipperIdAndBoxTypeArgs = {
  shipperId: Scalars['String'];
  boxType: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackDestinationArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackDestinationByShipperIdAndDestinationCodeArgs = {
  shipperId: Scalars['String'];
  destinationCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackGradeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackGradeByShipperIdAndGradeCodeArgs = {
  shipperId: Scalars['String'];
  gradeCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackHoldArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackHoldByShipperIdAndHoldCodeArgs = {
  shipperId: Scalars['String'];
  holdCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLabelArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLabelByShipperIdAndLabelCodeArgs = {
  shipperId: Scalars['String'];
  labelCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLinerArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLinerByShipperIdAndLinerCodeArgs = {
  shipperId: Scalars['String'];
  linerCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackMasterArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackOutArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackOutByShipperIdAndOutCodeArgs = {
  shipperId: Scalars['String'];
  outCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackPalletTypeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackPalletTypeByShipperIdAndPalletTypeArgs = {
  shipperId: Scalars['String'];
  palletType: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackProductionArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackProductionByShipperIdAndProductionCodeArgs = {
  shipperId: Scalars['String'];
  productionCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackSpecialArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackSpecialByShipperIdAndCustomerCodeArgs = {
  shipperId: Scalars['String'];
  customerCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackStyleArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackStyleByShipperIdAndPackStyleArgs = {
  shipperId: Scalars['String'];
  packStyle: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackTreeRipeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackTreeRipeByShipperIdAndTreeRipeArgs = {
  shipperId: Scalars['String'];
  treeRipe: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletSectionArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletTempOneArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletTempTwoArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductMasterArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductSizeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductSpeciesArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductVarietyArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionEntryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionProductArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionVesselArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVesselArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDistinctValuesArgs = {
  schemaName?: Maybe<Scalars['String']>;
  tableName?: Maybe<Scalars['String']>;
  columnName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerDistinctValuesArgs = {
  columnName?: Maybe<Scalars['String']>;
  conditionName?: Maybe<Scalars['String']>;
  conditionValue?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperDistinctValuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryChileDepartureInspectionsArgs = {
  orderBy?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<ChileDepartureInspectionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaInspectionVesselDistinctValuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletArgs = {
  palletid?: Maybe<Scalars['BigInt']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVesselArrivalPortDistinctValuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContactGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContactGroupPersonContactByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCountryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerPersonContactByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonContactByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperPersonContactByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWarehouseByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWarehousePersonContactByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChileDepartureInspectionPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPeruDepartureInspectionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPeruDepartureInspectionPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaApplePalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaArrivalPictureByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaArrivalReportByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaCherryPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaCitrusPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaGrapePalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaLemonPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPearPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPersimmonPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPomegranatePalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaStoneFruitPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAgendaItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCalendarEventByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceCategoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceEntryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceProductByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceSizeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInventoryItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackAtmosphereByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxStyleByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxTypeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackDestinationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackGradeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackHoldByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLabelByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLinerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackMasterByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackOutByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackPalletTypeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackProductionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackSpecialByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackStyleByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackTreeRipeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletSectionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletTempOneByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletTempTwoByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductMasterByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductSizeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductSpeciesByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductVarietyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionEntryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionProductByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionVesselByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVesselByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type User = Node & {
  __typename?: 'User';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `PersonContact` that is related to this `User`. */
  personContact?: Maybe<PersonContact>;
  /** Reads and enables pagination through a set of `UserMessage`. */
  userMessages: UserMessagesConnection;
  /** Reads and enables pagination through a set of `ContactGroup`. */
  contactGroups: ContactGroupsConnection;
};


export type UserUserMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UserMessagesOrderBy>>;
  condition?: Maybe<UserMessageCondition>;
  filter?: Maybe<UserMessageFilter>;
};


export type UserContactGroupsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContactGroupsOrderBy>>;
  condition?: Maybe<ContactGroupCondition>;
  filter?: Maybe<ContactGroupFilter>;
};


export type PersonContact = Node & {
  __typename?: 'PersonContact';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `CustomerPersonContact`. */
  customerPersonContacts: CustomerPersonContactsConnection;
  /** Reads and enables pagination through a set of `ShipperPersonContact`. */
  shipperPersonContacts: ShipperPersonContactsConnection;
  /** Reads and enables pagination through a set of `WarehousePersonContact`. */
  warehousePersonContacts: WarehousePersonContactsConnection;
  /** Reads and enables pagination through a set of `User`. */
  users: UsersConnection;
  /** Reads and enables pagination through a set of `ContactGroupPersonContact`. */
  contactGroupPersonContacts: ContactGroupPersonContactsConnection;
  searchText?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByCustomerPersonContactPersonContactIdAndCustomerId: PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperPersonContactPersonContactIdAndShipperId: PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Warehouse`. */
  warehousesByWarehousePersonContactPersonContactIdAndWarehouseId: PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ContactGroup`. */
  contactGroupsByContactGroupPersonContactPersonContactIdAndGroupId: PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdManyToManyConnection;
};


export type PersonContactCustomerPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerPersonContactsOrderBy>>;
  condition?: Maybe<CustomerPersonContactCondition>;
  filter?: Maybe<CustomerPersonContactFilter>;
};


export type PersonContactShipperPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperPersonContactsOrderBy>>;
  condition?: Maybe<ShipperPersonContactCondition>;
  filter?: Maybe<ShipperPersonContactFilter>;
};


export type PersonContactWarehousePersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WarehousePersonContactsOrderBy>>;
  condition?: Maybe<WarehousePersonContactCondition>;
  filter?: Maybe<WarehousePersonContactFilter>;
};


export type PersonContactUsersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
};


export type PersonContactContactGroupPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContactGroupPersonContactsOrderBy>>;
  condition?: Maybe<ContactGroupPersonContactCondition>;
  filter?: Maybe<ContactGroupPersonContactFilter>;
};


export type PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


export type PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WarehousesOrderBy>>;
  condition?: Maybe<WarehouseCondition>;
  filter?: Maybe<WarehouseFilter>;
};


export type PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContactGroupsOrderBy>>;
  condition?: Maybe<ContactGroupCondition>;
  filter?: Maybe<ContactGroupFilter>;
};

/** A connection to a list of `CustomerPersonContact` values. */
export type CustomerPersonContactsConnection = {
  __typename?: 'CustomerPersonContactsConnection';
  /** A list of `CustomerPersonContact` objects. */
  nodes: Array<Maybe<CustomerPersonContact>>;
  /** A list of edges which contains the `CustomerPersonContact` and cursor to aid in pagination. */
  edges: Array<CustomerPersonContactsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CustomerPersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CustomerPersonContact = Node & {
  __typename?: 'CustomerPersonContact';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
  /** Reads a single `Customer` that is related to this `CustomerPersonContact`. */
  customer?: Maybe<Customer>;
  /** Reads a single `PersonContact` that is related to this `CustomerPersonContact`. */
  personContact?: Maybe<PersonContact>;
};

export type Customer = Node & {
  __typename?: 'Customer';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  customerName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active: Scalars['Boolean'];
  /** Reads a single `Country` that is related to this `Customer`. */
  country?: Maybe<Country>;
  /** Reads and enables pagination through a set of `CustomerPersonContact`. */
  customerPersonContacts: CustomerPersonContactsConnection;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PersonContact`. */
  personContactsByCustomerPersonContactCustomerIdAndPersonContactId: CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdManyToManyConnection;
};


export type CustomerCustomerPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerPersonContactsOrderBy>>;
  condition?: Maybe<CustomerPersonContactCondition>;
  filter?: Maybe<CustomerPersonContactFilter>;
};


export type CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
  condition?: Maybe<PersonContactCondition>;
  filter?: Maybe<PersonContactFilter>;
};

export type Country = Node & {
  __typename?: 'Country';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  countryName: Scalars['String'];
  /** Reads and enables pagination through a set of `Customer`. */
  customers: CustomersConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippers: ShippersConnection;
  /** Reads and enables pagination through a set of `Warehouse`. */
  warehouses: WarehousesConnection;
};


export type CountryCustomersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


export type CountryShippersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type CountryWarehousesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WarehousesOrderBy>>;
  condition?: Maybe<WarehouseCondition>;
  filter?: Maybe<WarehouseFilter>;
};

/** A connection to a list of `Customer` values. */
export type CustomersConnection = {
  __typename?: 'CustomersConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer` and cursor to aid in pagination. */
  edges: Array<CustomersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection. */
export type CustomersEdge = {
  __typename?: 'CustomersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
};


/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
};

/** Methods to use when ordering `Customer`. */
export enum CustomersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CustomerNameAsc = 'CUSTOMER_NAME_ASC',
  CustomerNameDesc = 'CUSTOMER_NAME_DESC',
  Address_1Asc = 'ADDRESS_1_ASC',
  Address_1Desc = 'ADDRESS_1_DESC',
  Address_2Asc = 'ADDRESS_2_ASC',
  Address_2Desc = 'ADDRESS_2_DESC',
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  PostalStateAsc = 'POSTAL_STATE_ASC',
  PostalStateDesc = 'POSTAL_STATE_DESC',
  ZipCodeAsc = 'ZIP_CODE_ASC',
  ZipCodeDesc = 'ZIP_CODE_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  LogoSrcAsc = 'LOGO_SRC_ASC',
  LogoSrcDesc = 'LOGO_SRC_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  WebsiteAsc = 'WEBSITE_ASC',
  WebsiteDesc = 'WEBSITE_DESC',
  ActiveAsc = 'ACTIVE_ASC',
  ActiveDesc = 'ACTIVE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `Customer` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CustomerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerName` field. */
  customerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address1` field. */
  address1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address2` field. */
  address2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `postalState` field. */
  postalState?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `zipCode` field. */
  zipCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `logoSrc` field. */
  logoSrc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `active` field. */
  active?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `Customer` object types. All fields are combined with a logical ‘and.’ */
export type CustomerFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `customerName` field. */
  customerName?: Maybe<StringFilter>;
  /** Filter by the object’s `address1` field. */
  address1?: Maybe<StringFilter>;
  /** Filter by the object’s `address2` field. */
  address2?: Maybe<StringFilter>;
  /** Filter by the object’s `city` field. */
  city?: Maybe<StringFilter>;
  /** Filter by the object’s `postalState` field. */
  postalState?: Maybe<StringFilter>;
  /** Filter by the object’s `zipCode` field. */
  zipCode?: Maybe<StringFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<StringFilter>;
  /** Filter by the object’s `phone` field. */
  phone?: Maybe<StringFilter>;
  /** Filter by the object’s `logoSrc` field. */
  logoSrc?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `website` field. */
  website?: Maybe<StringFilter>;
  /** Filter by the object’s `active` field. */
  active?: Maybe<BooleanFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `customerPersonContacts` relation. */
  customerPersonContacts?: Maybe<CustomerToManyCustomerPersonContactFilter>;
  /** Some related `customerPersonContacts` exist. */
  customerPersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `country` relation. */
  country?: Maybe<CountryFilter>;
  /** A related `country` exists. */
  countryExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CustomerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CustomerFilter>>;
  /** Negates the expression. */
  not?: Maybe<CustomerFilter>;
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['String']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['String']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-sensitive). */
  includes?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Boolean']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Boolean']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Boolean']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against many `CustomerPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyCustomerPersonContactFilter = {
  /** Every related `CustomerPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CustomerPersonContactFilter>;
  /** Some related `CustomerPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CustomerPersonContactFilter>;
  /** No related `CustomerPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CustomerPersonContactFilter>;
};

/** A filter to be used against `CustomerPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type CustomerPersonContactFilter = {
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<StringFilter>;
  /** Filter by the object’s `personContactId` field. */
  personContactId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `customer` relation. */
  customer?: Maybe<CustomerFilter>;
  /** Filter by the object’s `personContact` relation. */
  personContact?: Maybe<PersonContactFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CustomerPersonContactFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CustomerPersonContactFilter>>;
  /** Negates the expression. */
  not?: Maybe<CustomerPersonContactFilter>;
};

/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigInt']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigInt']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['BigInt']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['BigInt']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['BigInt']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['BigInt']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigInt']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigInt']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigInt']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `PersonContact` object types. All fields are combined with a logical ‘and.’ */
export type PersonContactFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: Maybe<StringFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: Maybe<StringFilter>;
  /** Filter by the object’s `isPrimary` field. */
  isPrimary?: Maybe<BooleanFilter>;
  /** Filter by the object’s `email` field. */
  email?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryEmail` field. */
  secondaryEmail?: Maybe<StringFilter>;
  /** Filter by the object’s `homePhone` field. */
  homePhone?: Maybe<StringFilter>;
  /** Filter by the object’s `cellPhone` field. */
  cellPhone?: Maybe<StringFilter>;
  /** Filter by the object’s `workPhone` field. */
  workPhone?: Maybe<StringFilter>;
  /** Filter by the object’s `workExtension` field. */
  workExtension?: Maybe<StringFilter>;
  /** Filter by the object’s `imageSrc` field. */
  imageSrc?: Maybe<StringFilter>;
  /** Filter by the object’s `isInternal` field. */
  isInternal?: Maybe<BooleanFilter>;
  /** Filter by the object’s `roles` field. */
  roles?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `customerPersonContacts` relation. */
  customerPersonContacts?: Maybe<PersonContactToManyCustomerPersonContactFilter>;
  /** Some related `customerPersonContacts` exist. */
  customerPersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperPersonContacts` relation. */
  shipperPersonContacts?: Maybe<PersonContactToManyShipperPersonContactFilter>;
  /** Some related `shipperPersonContacts` exist. */
  shipperPersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `warehousePersonContacts` relation. */
  warehousePersonContacts?: Maybe<PersonContactToManyWarehousePersonContactFilter>;
  /** Some related `warehousePersonContacts` exist. */
  warehousePersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `users` relation. */
  users?: Maybe<PersonContactToManyUserFilter>;
  /** Some related `users` exist. */
  usersExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `contactGroupPersonContacts` relation. */
  contactGroupPersonContacts?: Maybe<PersonContactToManyContactGroupPersonContactFilter>;
  /** Some related `contactGroupPersonContacts` exist. */
  contactGroupPersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PersonContactFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PersonContactFilter>>;
  /** Negates the expression. */
  not?: Maybe<PersonContactFilter>;
};

/** A filter to be used against many `CustomerPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type PersonContactToManyCustomerPersonContactFilter = {
  /** Every related `CustomerPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CustomerPersonContactFilter>;
  /** Some related `CustomerPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CustomerPersonContactFilter>;
  /** No related `CustomerPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CustomerPersonContactFilter>;
};

/** A filter to be used against many `ShipperPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type PersonContactToManyShipperPersonContactFilter = {
  /** Every related `ShipperPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperPersonContactFilter>;
  /** Some related `ShipperPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperPersonContactFilter>;
  /** No related `ShipperPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperPersonContactFilter>;
};

/** A filter to be used against `ShipperPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type ShipperPersonContactFilter = {
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `personContactId` field. */
  personContactId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipper` relation. */
  shipper?: Maybe<ShipperFilter>;
  /** Filter by the object’s `personContact` relation. */
  personContact?: Maybe<PersonContactFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperPersonContactFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperPersonContactFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperPersonContactFilter>;
};

/** A filter to be used against `Shipper` object types. All fields are combined with a logical ‘and.’ */
export type ShipperFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperName` field. */
  shipperName?: Maybe<StringFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<StringFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<StringFilter>;
  /** Filter by the object’s `logoSrc` field. */
  logoSrc?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `website` field. */
  website?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperPersonContacts` relation. */
  shipperPersonContacts?: Maybe<ShipperToManyShipperPersonContactFilter>;
  /** Some related `shipperPersonContacts` exist. */
  shipperPersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperProjectionVessels` relation. */
  shipperProjectionVessels?: Maybe<ShipperToManyShipperProjectionVesselFilter>;
  /** Some related `shipperProjectionVessels` exist. */
  shipperProjectionVesselsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperProjectionProducts` relation. */
  shipperProjectionProducts?: Maybe<ShipperToManyShipperProjectionProductFilter>;
  /** Some related `shipperProjectionProducts` exist. */
  shipperProjectionProductsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperProjections` relation. */
  shipperProjections?: Maybe<ShipperToManyShipperProjectionFilter>;
  /** Some related `shipperProjections` exist. */
  shipperProjectionsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `country` relation. */
  country?: Maybe<CountryFilter>;
  /** A related `country` exists. */
  countryExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperFilter>;
};

/** A filter to be used against many `ShipperPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type ShipperToManyShipperPersonContactFilter = {
  /** Every related `ShipperPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperPersonContactFilter>;
  /** Some related `ShipperPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperPersonContactFilter>;
  /** No related `ShipperPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperPersonContactFilter>;
};

/** A filter to be used against many `ShipperProjectionVessel` object types. All fields are combined with a logical ‘and.’ */
export type ShipperToManyShipperProjectionVesselFilter = {
  /** Every related `ShipperProjectionVessel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionVesselFilter>;
  /** Some related `ShipperProjectionVessel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionVesselFilter>;
  /** No related `ShipperProjectionVessel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionVesselFilter>;
};

/** A filter to be used against `ShipperProjectionVessel` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionVesselFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vesselName` field. */
  vesselName?: Maybe<StringFilter>;
  /** Filter by the object’s `departureDate` field. */
  departureDate?: Maybe<DateFilter>;
  /** Filter by the object’s `arrivalDate` field. */
  arrivalDate?: Maybe<DateFilter>;
  /** Filter by the object’s `arrivalPort` field. */
  arrivalPort?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselStatus` field. */
  vesselStatus?: Maybe<StringFilter>;
  /** Filter by the object’s `isReviewed` field. */
  isReviewed?: Maybe<BooleanFilter>;
  /** Filter by the object’s `previousName` field. */
  previousName?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProjectionEntriesByVesselId` relation. */
  shipperProjectionEntriesByVesselId?: Maybe<ShipperProjectionVesselToManyShipperProjectionEntryFilter>;
  /** Some related `shipperProjectionEntriesByVesselId` exist. */
  shipperProjectionEntriesByVesselIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipper` relation. */
  shipper?: Maybe<ShipperFilter>;
  /** A related `shipper` exists. */
  shipperExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperProjectionVesselFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperProjectionVesselFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperProjectionVesselFilter>;
};

/** A filter to be used against Date fields. All fields are combined with a logical ‘and.’ */
export type DateFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Date']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Date']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Date']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Date']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Date']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Date']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Date']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Date']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Date']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Date']>;
};


/** A filter to be used against many `ShipperProjectionEntry` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionVesselToManyShipperProjectionEntryFilter = {
  /** Every related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionEntryFilter>;
  /** Some related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionEntryFilter>;
  /** No related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionEntryFilter>;
};

/** A filter to be used against `ShipperProjectionEntry` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionEntryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `vesselId` field. */
  vesselId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `productId` field. */
  productId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperProjectionId` field. */
  shipperProjectionId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vessel` relation. */
  vessel?: Maybe<ShipperProjectionVesselFilter>;
  /** A related `vessel` exists. */
  vesselExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `product` relation. */
  product?: Maybe<ShipperProjectionProductFilter>;
  /** A related `product` exists. */
  productExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperProjection` relation. */
  shipperProjection?: Maybe<ShipperProjectionFilter>;
  /** A related `shipperProjection` exists. */
  shipperProjectionExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperProjectionEntryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperProjectionEntryFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperProjectionEntryFilter>;
};

/** A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’ */
export type BigFloatFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigFloat']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigFloat']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['BigFloat']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['BigFloat']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['BigFloat']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['BigFloat']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigFloat']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigFloat']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigFloat']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigFloat']>;
};


/** A filter to be used against `ShipperProjectionProduct` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionProductFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `species` field. */
  species?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `packType` field. */
  packType?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProjectionEntriesByProductId` relation. */
  shipperProjectionEntriesByProductId?: Maybe<ShipperProjectionProductToManyShipperProjectionEntryFilter>;
  /** Some related `shipperProjectionEntriesByProductId` exist. */
  shipperProjectionEntriesByProductIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipper` relation. */
  shipper?: Maybe<ShipperFilter>;
  /** A related `shipper` exists. */
  shipperExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperProjectionProductFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperProjectionProductFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperProjectionProductFilter>;
};

/** A filter to be used against many `ShipperProjectionEntry` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionProductToManyShipperProjectionEntryFilter = {
  /** Every related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionEntryFilter>;
  /** Some related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionEntryFilter>;
  /** No related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionEntryFilter>;
};

/** A filter to be used against `ShipperProjection` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `completedAt` field. */
  completedAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `isReviewed` field. */
  isReviewed?: Maybe<BooleanFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `totalPallets` field. */
  totalPallets?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperProjectionEntries` relation. */
  shipperProjectionEntries?: Maybe<ShipperProjectionToManyShipperProjectionEntryFilter>;
  /** Some related `shipperProjectionEntries` exist. */
  shipperProjectionEntriesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipper` relation. */
  shipper?: Maybe<ShipperFilter>;
  /** A related `shipper` exists. */
  shipperExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperProjectionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperProjectionFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperProjectionFilter>;
};

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Datetime']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Datetime']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Datetime']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Datetime']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>;
};


/** A filter to be used against many `ShipperProjectionEntry` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionToManyShipperProjectionEntryFilter = {
  /** Every related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionEntryFilter>;
  /** Some related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionEntryFilter>;
  /** No related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionEntryFilter>;
};

/** A filter to be used against many `ShipperProjectionProduct` object types. All fields are combined with a logical ‘and.’ */
export type ShipperToManyShipperProjectionProductFilter = {
  /** Every related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionProductFilter>;
  /** Some related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionProductFilter>;
  /** No related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionProductFilter>;
};

/** A filter to be used against many `ShipperProjection` object types. All fields are combined with a logical ‘and.’ */
export type ShipperToManyShipperProjectionFilter = {
  /** Every related `ShipperProjection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionFilter>;
  /** Some related `ShipperProjection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionFilter>;
  /** No related `ShipperProjection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionFilter>;
};

/** A filter to be used against `Country` object types. All fields are combined with a logical ‘and.’ */
export type CountryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `countryName` field. */
  countryName?: Maybe<StringFilter>;
  /** Filter by the object’s `customers` relation. */
  customers?: Maybe<CountryToManyCustomerFilter>;
  /** Some related `customers` exist. */
  customersExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shippers` relation. */
  shippers?: Maybe<CountryToManyShipperFilter>;
  /** Some related `shippers` exist. */
  shippersExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `warehouses` relation. */
  warehouses?: Maybe<CountryToManyWarehouseFilter>;
  /** Some related `warehouses` exist. */
  warehousesExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CountryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CountryFilter>>;
  /** Negates the expression. */
  not?: Maybe<CountryFilter>;
};

/** A filter to be used against many `Customer` object types. All fields are combined with a logical ‘and.’ */
export type CountryToManyCustomerFilter = {
  /** Every related `Customer` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CustomerFilter>;
  /** Some related `Customer` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CustomerFilter>;
  /** No related `Customer` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CustomerFilter>;
};

/** A filter to be used against many `Shipper` object types. All fields are combined with a logical ‘and.’ */
export type CountryToManyShipperFilter = {
  /** Every related `Shipper` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperFilter>;
  /** Some related `Shipper` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperFilter>;
  /** No related `Shipper` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperFilter>;
};

/** A filter to be used against many `Warehouse` object types. All fields are combined with a logical ‘and.’ */
export type CountryToManyWarehouseFilter = {
  /** Every related `Warehouse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<WarehouseFilter>;
  /** Some related `Warehouse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<WarehouseFilter>;
  /** No related `Warehouse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<WarehouseFilter>;
};

/** A filter to be used against `Warehouse` object types. All fields are combined with a logical ‘and.’ */
export type WarehouseFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `warehouseName` field. */
  warehouseName?: Maybe<StringFilter>;
  /** Filter by the object’s `address1` field. */
  address1?: Maybe<StringFilter>;
  /** Filter by the object’s `address2` field. */
  address2?: Maybe<StringFilter>;
  /** Filter by the object’s `address3` field. */
  address3?: Maybe<StringFilter>;
  /** Filter by the object’s `city` field. */
  city?: Maybe<StringFilter>;
  /** Filter by the object’s `postalState` field. */
  postalState?: Maybe<StringFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<StringFilter>;
  /** Filter by the object’s `zipCode` field. */
  zipCode?: Maybe<StringFilter>;
  /** Filter by the object’s `phone` field. */
  phone?: Maybe<StringFilter>;
  /** Filter by the object’s `outQueue` field. */
  outQueue?: Maybe<StringFilter>;
  /** Filter by the object’s `stateTaxCode` field. */
  stateTaxCode?: Maybe<StringFilter>;
  /** Filter by the object’s `countyTaxCode` field. */
  countyTaxCode?: Maybe<StringFilter>;
  /** Filter by the object’s `cityTaxCode` field. */
  cityTaxCode?: Maybe<StringFilter>;
  /** Filter by the object’s `miscTaxCode` field. */
  miscTaxCode?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `warehousePersonContacts` relation. */
  warehousePersonContacts?: Maybe<WarehouseToManyWarehousePersonContactFilter>;
  /** Some related `warehousePersonContacts` exist. */
  warehousePersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `country` relation. */
  country?: Maybe<CountryFilter>;
  /** A related `country` exists. */
  countryExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<WarehouseFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<WarehouseFilter>>;
  /** Negates the expression. */
  not?: Maybe<WarehouseFilter>;
};

/** A filter to be used against many `WarehousePersonContact` object types. All fields are combined with a logical ‘and.’ */
export type WarehouseToManyWarehousePersonContactFilter = {
  /** Every related `WarehousePersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<WarehousePersonContactFilter>;
  /** Some related `WarehousePersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<WarehousePersonContactFilter>;
  /** No related `WarehousePersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<WarehousePersonContactFilter>;
};

/** A filter to be used against `WarehousePersonContact` object types. All fields are combined with a logical ‘and.’ */
export type WarehousePersonContactFilter = {
  /** Filter by the object’s `warehouseId` field. */
  warehouseId?: Maybe<StringFilter>;
  /** Filter by the object’s `personContactId` field. */
  personContactId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `warehouse` relation. */
  warehouse?: Maybe<WarehouseFilter>;
  /** Filter by the object’s `personContact` relation. */
  personContact?: Maybe<PersonContactFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<WarehousePersonContactFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<WarehousePersonContactFilter>>;
  /** Negates the expression. */
  not?: Maybe<WarehousePersonContactFilter>;
};

/** A filter to be used against many `WarehousePersonContact` object types. All fields are combined with a logical ‘and.’ */
export type PersonContactToManyWarehousePersonContactFilter = {
  /** Every related `WarehousePersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<WarehousePersonContactFilter>;
  /** Some related `WarehousePersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<WarehousePersonContactFilter>;
  /** No related `WarehousePersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<WarehousePersonContactFilter>;
};

/** A filter to be used against many `User` object types. All fields are combined with a logical ‘and.’ */
export type PersonContactToManyUserFilter = {
  /** Every related `User` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<UserFilter>;
  /** Some related `User` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<UserFilter>;
  /** No related `User` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<UserFilter>;
};

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `pin` field. */
  pin?: Maybe<StringFilter>;
  /** Filter by the object’s `personContactId` field. */
  personContactId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `userMessages` relation. */
  userMessages?: Maybe<UserToManyUserMessageFilter>;
  /** Some related `userMessages` exist. */
  userMessagesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `contactGroups` relation. */
  contactGroups?: Maybe<UserToManyContactGroupFilter>;
  /** Some related `contactGroups` exist. */
  contactGroupsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `personContact` relation. */
  personContact?: Maybe<PersonContactFilter>;
  /** A related `personContact` exists. */
  personContactExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserFilter>>;
  /** Negates the expression. */
  not?: Maybe<UserFilter>;
};

/** A filter to be used against many `UserMessage` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserMessageFilter = {
  /** Every related `UserMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<UserMessageFilter>;
  /** Some related `UserMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<UserMessageFilter>;
  /** No related `UserMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<UserMessageFilter>;
};

/** A filter to be used against `UserMessage` object types. All fields are combined with a logical ‘and.’ */
export type UserMessageFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `actionLink` field. */
  actionLink?: Maybe<StringFilter>;
  /** Filter by the object’s `actionText` field. */
  actionText?: Maybe<StringFilter>;
  /** Filter by the object’s `details` field. */
  details?: Maybe<StringFilter>;
  /** Filter by the object’s `header` field. */
  header?: Maybe<StringFilter>;
  /** Filter by the object’s `isRead` field. */
  isRead?: Maybe<BooleanFilter>;
  /** Filter by the object’s `messageDate` field. */
  messageDate?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `priority` field. */
  priority?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserMessageFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserMessageFilter>>;
  /** Negates the expression. */
  not?: Maybe<UserMessageFilter>;
};

/** A filter to be used against many `ContactGroup` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyContactGroupFilter = {
  /** Every related `ContactGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ContactGroupFilter>;
  /** Some related `ContactGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ContactGroupFilter>;
  /** No related `ContactGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ContactGroupFilter>;
};

/** A filter to be used against `ContactGroup` object types. All fields are combined with a logical ‘and.’ */
export type ContactGroupFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `groupDescription` field. */
  groupDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `groupName` field. */
  groupName?: Maybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `contactGroupPersonContactsByGroupId` relation. */
  contactGroupPersonContactsByGroupId?: Maybe<ContactGroupToManyContactGroupPersonContactFilter>;
  /** Some related `contactGroupPersonContactsByGroupId` exist. */
  contactGroupPersonContactsByGroupIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ContactGroupFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ContactGroupFilter>>;
  /** Negates the expression. */
  not?: Maybe<ContactGroupFilter>;
};

/** A filter to be used against many `ContactGroupPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type ContactGroupToManyContactGroupPersonContactFilter = {
  /** Every related `ContactGroupPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ContactGroupPersonContactFilter>;
  /** Some related `ContactGroupPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ContactGroupPersonContactFilter>;
  /** No related `ContactGroupPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ContactGroupPersonContactFilter>;
};

/** A filter to be used against `ContactGroupPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type ContactGroupPersonContactFilter = {
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `personContactId` field. */
  personContactId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `group` relation. */
  group?: Maybe<ContactGroupFilter>;
  /** Filter by the object’s `personContact` relation. */
  personContact?: Maybe<PersonContactFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ContactGroupPersonContactFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ContactGroupPersonContactFilter>>;
  /** Negates the expression. */
  not?: Maybe<ContactGroupPersonContactFilter>;
};

/** A filter to be used against many `ContactGroupPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type PersonContactToManyContactGroupPersonContactFilter = {
  /** Every related `ContactGroupPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ContactGroupPersonContactFilter>;
  /** Some related `ContactGroupPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ContactGroupPersonContactFilter>;
  /** No related `ContactGroupPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ContactGroupPersonContactFilter>;
};

/** A connection to a list of `Shipper` values. */
export type ShippersConnection = {
  __typename?: 'ShippersConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper` and cursor to aid in pagination. */
  edges: Array<ShippersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Shipper = Node & {
  __typename?: 'Shipper';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  /** Reads a single `Country` that is related to this `Shipper`. */
  country?: Maybe<Country>;
  /** Reads and enables pagination through a set of `ShipperPersonContact`. */
  shipperPersonContacts: ShipperPersonContactsConnection;
  /** Reads and enables pagination through a set of `ShipperProjectionVessel`. */
  shipperProjectionVessels: ShipperProjectionVesselsConnection;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
  /** Reads and enables pagination through a set of `ShipperProjection`. */
  shipperProjections: ShipperProjectionsConnection;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PersonContact`. */
  personContactsByShipperPersonContactShipperIdAndPersonContactId: ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdManyToManyConnection;
};


export type ShipperShipperPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperPersonContactsOrderBy>>;
  condition?: Maybe<ShipperPersonContactCondition>;
  filter?: Maybe<ShipperPersonContactFilter>;
};


export type ShipperShipperProjectionVesselsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselCondition>;
  filter?: Maybe<ShipperProjectionVesselFilter>;
};


export type ShipperShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};


export type ShipperShipperProjectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
  condition?: Maybe<ShipperProjectionCondition>;
  filter?: Maybe<ShipperProjectionFilter>;
};


export type ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
  condition?: Maybe<PersonContactCondition>;
  filter?: Maybe<PersonContactFilter>;
};

/** A connection to a list of `ShipperPersonContact` values. */
export type ShipperPersonContactsConnection = {
  __typename?: 'ShipperPersonContactsConnection';
  /** A list of `ShipperPersonContact` objects. */
  nodes: Array<Maybe<ShipperPersonContact>>;
  /** A list of edges which contains the `ShipperPersonContact` and cursor to aid in pagination. */
  edges: Array<ShipperPersonContactsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperPersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ShipperPersonContact = Node & {
  __typename?: 'ShipperPersonContact';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
  /** Reads a single `Shipper` that is related to this `ShipperPersonContact`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `PersonContact` that is related to this `ShipperPersonContact`. */
  personContact?: Maybe<PersonContact>;
};

/** A `ShipperPersonContact` edge in the connection. */
export type ShipperPersonContactsEdge = {
  __typename?: 'ShipperPersonContactsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperPersonContact` at the end of the edge. */
  node?: Maybe<ShipperPersonContact>;
};

/** Methods to use when ordering `ShipperPersonContact`. */
export enum ShipperPersonContactsOrderBy {
  Natural = 'NATURAL',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PersonContactIdAsc = 'PERSON_CONTACT_ID_ASC',
  PersonContactIdDesc = 'PERSON_CONTACT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ShipperPersonContact` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ShipperPersonContactCondition = {
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `personContactId` field. */
  personContactId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `ShipperProjectionVessel` values. */
export type ShipperProjectionVesselsConnection = {
  __typename?: 'ShipperProjectionVesselsConnection';
  /** A list of `ShipperProjectionVessel` objects. */
  nodes: Array<Maybe<ShipperProjectionVessel>>;
  /** A list of edges which contains the `ShipperProjectionVessel` and cursor to aid in pagination. */
  edges: Array<ShipperProjectionVesselsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionVessel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ShipperProjectionVessel = Node & {
  __typename?: 'ShipperProjectionVessel';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  previousName?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVessel`. */
  shipper?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntriesByVesselId: ShipperProjectionEntriesConnection;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProductsByShipperProjectionEntryVesselIdAndProductId: ShipperProjectionVesselShipperProjectionProductsByShipperProjectionEntryVesselIdAndProductIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ShipperProjection`. */
  shipperProjectionsByShipperProjectionEntryVesselIdAndShipperProjectionId: ShipperProjectionVesselShipperProjectionsByShipperProjectionEntryVesselIdAndShipperProjectionIdManyToManyConnection;
};


export type ShipperProjectionVesselShipperProjectionEntriesByVesselIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};


export type ShipperProjectionVesselShipperProjectionProductsByShipperProjectionEntryVesselIdAndProductIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};


export type ShipperProjectionVesselShipperProjectionsByShipperProjectionEntryVesselIdAndShipperProjectionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
  condition?: Maybe<ShipperProjectionCondition>;
  filter?: Maybe<ShipperProjectionFilter>;
};

/** A connection to a list of `ShipperProjectionEntry` values. */
export type ShipperProjectionEntriesConnection = {
  __typename?: 'ShipperProjectionEntriesConnection';
  /** A list of `ShipperProjectionEntry` objects. */
  nodes: Array<Maybe<ShipperProjectionEntry>>;
  /** A list of edges which contains the `ShipperProjectionEntry` and cursor to aid in pagination. */
  edges: Array<ShipperProjectionEntriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionEntry` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ShipperProjectionEntry = Node & {
  __typename?: 'ShipperProjectionEntry';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  palletCount?: Maybe<Scalars['BigFloat']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  shipperProjectionId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `ShipperProjectionVessel` that is related to this `ShipperProjectionEntry`. */
  vessel?: Maybe<ShipperProjectionVessel>;
  /** Reads a single `ShipperProjectionProduct` that is related to this `ShipperProjectionEntry`. */
  product?: Maybe<ShipperProjectionProduct>;
  /** Reads a single `ShipperProjection` that is related to this `ShipperProjectionEntry`. */
  shipperProjection?: Maybe<ShipperProjection>;
};

export type ShipperProjectionProduct = Node & {
  __typename?: 'ShipperProjectionProduct';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionProduct`. */
  shipper?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntriesByProductId: ShipperProjectionEntriesConnection;
  /** Reads and enables pagination through a set of `ShipperProjectionVessel`. */
  shipperProjectionVesselsByShipperProjectionEntryProductIdAndVesselId: ShipperProjectionProductShipperProjectionVesselsByShipperProjectionEntryProductIdAndVesselIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ShipperProjection`. */
  shipperProjectionsByShipperProjectionEntryProductIdAndShipperProjectionId: ShipperProjectionProductShipperProjectionsByShipperProjectionEntryProductIdAndShipperProjectionIdManyToManyConnection;
};


export type ShipperProjectionProductShipperProjectionEntriesByProductIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};


export type ShipperProjectionProductShipperProjectionVesselsByShipperProjectionEntryProductIdAndVesselIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselCondition>;
  filter?: Maybe<ShipperProjectionVesselFilter>;
};


export type ShipperProjectionProductShipperProjectionsByShipperProjectionEntryProductIdAndShipperProjectionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
  condition?: Maybe<ShipperProjectionCondition>;
  filter?: Maybe<ShipperProjectionFilter>;
};

/** Methods to use when ordering `ShipperProjectionEntry`. */
export enum ShipperProjectionEntriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PalletCountAsc = 'PALLET_COUNT_ASC',
  PalletCountDesc = 'PALLET_COUNT_DESC',
  VesselIdAsc = 'VESSEL_ID_ASC',
  VesselIdDesc = 'VESSEL_ID_DESC',
  ProductIdAsc = 'PRODUCT_ID_ASC',
  ProductIdDesc = 'PRODUCT_ID_DESC',
  ShipperProjectionIdAsc = 'SHIPPER_PROJECTION_ID_ASC',
  ShipperProjectionIdDesc = 'SHIPPER_PROJECTION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ShipperProjectionEntry` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ShipperProjectionEntryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `palletCount` field. */
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `vesselId` field. */
  vesselId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `productId` field. */
  productId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperProjectionId` field. */
  shipperProjectionId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `ShipperProjectionVessel` values, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionProductShipperProjectionVesselsByShipperProjectionEntryProductIdAndVesselIdManyToManyConnection = {
  __typename?: 'ShipperProjectionProductShipperProjectionVesselsByShipperProjectionEntryProductIdAndVesselIdManyToManyConnection';
  /** A list of `ShipperProjectionVessel` objects. */
  nodes: Array<Maybe<ShipperProjectionVessel>>;
  /** A list of edges which contains the `ShipperProjectionVessel`, info from the `ShipperProjectionEntry`, and the cursor to aid in pagination. */
  edges: Array<ShipperProjectionProductShipperProjectionVesselsByShipperProjectionEntryProductIdAndVesselIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionVessel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjectionVessel` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionProductShipperProjectionVesselsByShipperProjectionEntryProductIdAndVesselIdManyToManyEdge = {
  __typename?: 'ShipperProjectionProductShipperProjectionVesselsByShipperProjectionEntryProductIdAndVesselIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionVessel` at the end of the edge. */
  node?: Maybe<ShipperProjectionVessel>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntriesByVesselId: ShipperProjectionEntriesConnection;
};


/** A `ShipperProjectionVessel` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionProductShipperProjectionVesselsByShipperProjectionEntryProductIdAndVesselIdManyToManyEdgeShipperProjectionEntriesByVesselIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};

/** Methods to use when ordering `ShipperProjectionVessel`. */
export enum ShipperProjectionVesselsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VesselNameAsc = 'VESSEL_NAME_ASC',
  VesselNameDesc = 'VESSEL_NAME_DESC',
  DepartureDateAsc = 'DEPARTURE_DATE_ASC',
  DepartureDateDesc = 'DEPARTURE_DATE_DESC',
  ArrivalDateAsc = 'ARRIVAL_DATE_ASC',
  ArrivalDateDesc = 'ARRIVAL_DATE_DESC',
  ArrivalPortAsc = 'ARRIVAL_PORT_ASC',
  ArrivalPortDesc = 'ARRIVAL_PORT_DESC',
  VesselStatusAsc = 'VESSEL_STATUS_ASC',
  VesselStatusDesc = 'VESSEL_STATUS_DESC',
  IsReviewedAsc = 'IS_REVIEWED_ASC',
  IsReviewedDesc = 'IS_REVIEWED_DESC',
  PreviousNameAsc = 'PREVIOUS_NAME_ASC',
  PreviousNameDesc = 'PREVIOUS_NAME_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ShipperProjectionVessel` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ShipperProjectionVesselCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vesselName` field. */
  vesselName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `departureDate` field. */
  departureDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `arrivalDate` field. */
  arrivalDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `arrivalPort` field. */
  arrivalPort?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselStatus` field. */
  vesselStatus?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isReviewed` field. */
  isReviewed?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `previousName` field. */
  previousName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
};

/** A connection to a list of `ShipperProjection` values, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionProductShipperProjectionsByShipperProjectionEntryProductIdAndShipperProjectionIdManyToManyConnection = {
  __typename?: 'ShipperProjectionProductShipperProjectionsByShipperProjectionEntryProductIdAndShipperProjectionIdManyToManyConnection';
  /** A list of `ShipperProjection` objects. */
  nodes: Array<Maybe<ShipperProjection>>;
  /** A list of edges which contains the `ShipperProjection`, info from the `ShipperProjectionEntry`, and the cursor to aid in pagination. */
  edges: Array<ShipperProjectionProductShipperProjectionsByShipperProjectionEntryProductIdAndShipperProjectionIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ShipperProjection = Node & {
  __typename?: 'ShipperProjection';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  completedAt?: Maybe<Scalars['Datetime']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  shipperId?: Maybe<Scalars['String']>;
  /** Reads a single `Shipper` that is related to this `ShipperProjection`. */
  shipper?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntries: ShipperProjectionEntriesConnection;
  searchText?: Maybe<Scalars['String']>;
  totalPallets?: Maybe<Scalars['BigInt']>;
  /** Reads and enables pagination through a set of `ShipperProjectionVessel`. */
  shipperProjectionVesselsByShipperProjectionEntryShipperProjectionIdAndVesselId: ShipperProjectionShipperProjectionVesselsByShipperProjectionEntryShipperProjectionIdAndVesselIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProductsByShipperProjectionEntryShipperProjectionIdAndProductId: ShipperProjectionShipperProjectionProductsByShipperProjectionEntryShipperProjectionIdAndProductIdManyToManyConnection;
};


export type ShipperProjectionShipperProjectionEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};


export type ShipperProjectionShipperProjectionVesselsByShipperProjectionEntryShipperProjectionIdAndVesselIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselCondition>;
  filter?: Maybe<ShipperProjectionVesselFilter>;
};


export type ShipperProjectionShipperProjectionProductsByShipperProjectionEntryShipperProjectionIdAndProductIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A connection to a list of `ShipperProjectionVessel` values, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionShipperProjectionVesselsByShipperProjectionEntryShipperProjectionIdAndVesselIdManyToManyConnection = {
  __typename?: 'ShipperProjectionShipperProjectionVesselsByShipperProjectionEntryShipperProjectionIdAndVesselIdManyToManyConnection';
  /** A list of `ShipperProjectionVessel` objects. */
  nodes: Array<Maybe<ShipperProjectionVessel>>;
  /** A list of edges which contains the `ShipperProjectionVessel`, info from the `ShipperProjectionEntry`, and the cursor to aid in pagination. */
  edges: Array<ShipperProjectionShipperProjectionVesselsByShipperProjectionEntryShipperProjectionIdAndVesselIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionVessel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjectionVessel` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionShipperProjectionVesselsByShipperProjectionEntryShipperProjectionIdAndVesselIdManyToManyEdge = {
  __typename?: 'ShipperProjectionShipperProjectionVesselsByShipperProjectionEntryShipperProjectionIdAndVesselIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionVessel` at the end of the edge. */
  node?: Maybe<ShipperProjectionVessel>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntriesByVesselId: ShipperProjectionEntriesConnection;
};


/** A `ShipperProjectionVessel` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionShipperProjectionVesselsByShipperProjectionEntryShipperProjectionIdAndVesselIdManyToManyEdgeShipperProjectionEntriesByVesselIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};

/** A connection to a list of `ShipperProjectionProduct` values, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionShipperProjectionProductsByShipperProjectionEntryShipperProjectionIdAndProductIdManyToManyConnection = {
  __typename?: 'ShipperProjectionShipperProjectionProductsByShipperProjectionEntryShipperProjectionIdAndProductIdManyToManyConnection';
  /** A list of `ShipperProjectionProduct` objects. */
  nodes: Array<Maybe<ShipperProjectionProduct>>;
  /** A list of edges which contains the `ShipperProjectionProduct`, info from the `ShipperProjectionEntry`, and the cursor to aid in pagination. */
  edges: Array<ShipperProjectionShipperProjectionProductsByShipperProjectionEntryShipperProjectionIdAndProductIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionProduct` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjectionProduct` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionShipperProjectionProductsByShipperProjectionEntryShipperProjectionIdAndProductIdManyToManyEdge = {
  __typename?: 'ShipperProjectionShipperProjectionProductsByShipperProjectionEntryShipperProjectionIdAndProductIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionProduct` at the end of the edge. */
  node?: Maybe<ShipperProjectionProduct>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntriesByProductId: ShipperProjectionEntriesConnection;
};


/** A `ShipperProjectionProduct` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionShipperProjectionProductsByShipperProjectionEntryShipperProjectionIdAndProductIdManyToManyEdgeShipperProjectionEntriesByProductIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};

/** Methods to use when ordering `ShipperProjectionProduct`. */
export enum ShipperProjectionProductsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SpeciesAsc = 'SPECIES_ASC',
  SpeciesDesc = 'SPECIES_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  PackTypeAsc = 'PACK_TYPE_ASC',
  PackTypeDesc = 'PACK_TYPE_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ShipperProjectionProduct` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ShipperProjectionProductCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `species` field. */
  species?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packType` field. */
  packType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
};

/** A `ShipperProjection` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionProductShipperProjectionsByShipperProjectionEntryProductIdAndShipperProjectionIdManyToManyEdge = {
  __typename?: 'ShipperProjectionProductShipperProjectionsByShipperProjectionEntryProductIdAndShipperProjectionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjection` at the end of the edge. */
  node?: Maybe<ShipperProjection>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntries: ShipperProjectionEntriesConnection;
};


/** A `ShipperProjection` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionProductShipperProjectionsByShipperProjectionEntryProductIdAndShipperProjectionIdManyToManyEdgeShipperProjectionEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};

/** Methods to use when ordering `ShipperProjection`. */
export enum ShipperProjectionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CompletedAtAsc = 'COMPLETED_AT_ASC',
  CompletedAtDesc = 'COMPLETED_AT_DESC',
  IsReviewedAsc = 'IS_REVIEWED_ASC',
  IsReviewedDesc = 'IS_REVIEWED_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  TotalPalletsAsc = 'TOTAL_PALLETS_ASC',
  TotalPalletsDesc = 'TOTAL_PALLETS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ShipperProjection` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ShipperProjectionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `completedAt` field. */
  completedAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `isReviewed` field. */
  isReviewed?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
};

/** A `ShipperProjectionEntry` edge in the connection. */
export type ShipperProjectionEntriesEdge = {
  __typename?: 'ShipperProjectionEntriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionEntry` at the end of the edge. */
  node?: Maybe<ShipperProjectionEntry>;
};

/** A connection to a list of `ShipperProjectionProduct` values, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionVesselShipperProjectionProductsByShipperProjectionEntryVesselIdAndProductIdManyToManyConnection = {
  __typename?: 'ShipperProjectionVesselShipperProjectionProductsByShipperProjectionEntryVesselIdAndProductIdManyToManyConnection';
  /** A list of `ShipperProjectionProduct` objects. */
  nodes: Array<Maybe<ShipperProjectionProduct>>;
  /** A list of edges which contains the `ShipperProjectionProduct`, info from the `ShipperProjectionEntry`, and the cursor to aid in pagination. */
  edges: Array<ShipperProjectionVesselShipperProjectionProductsByShipperProjectionEntryVesselIdAndProductIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionProduct` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjectionProduct` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionVesselShipperProjectionProductsByShipperProjectionEntryVesselIdAndProductIdManyToManyEdge = {
  __typename?: 'ShipperProjectionVesselShipperProjectionProductsByShipperProjectionEntryVesselIdAndProductIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionProduct` at the end of the edge. */
  node?: Maybe<ShipperProjectionProduct>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntriesByProductId: ShipperProjectionEntriesConnection;
};


/** A `ShipperProjectionProduct` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionVesselShipperProjectionProductsByShipperProjectionEntryVesselIdAndProductIdManyToManyEdgeShipperProjectionEntriesByProductIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};

/** A connection to a list of `ShipperProjection` values, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionVesselShipperProjectionsByShipperProjectionEntryVesselIdAndShipperProjectionIdManyToManyConnection = {
  __typename?: 'ShipperProjectionVesselShipperProjectionsByShipperProjectionEntryVesselIdAndShipperProjectionIdManyToManyConnection';
  /** A list of `ShipperProjection` objects. */
  nodes: Array<Maybe<ShipperProjection>>;
  /** A list of edges which contains the `ShipperProjection`, info from the `ShipperProjectionEntry`, and the cursor to aid in pagination. */
  edges: Array<ShipperProjectionVesselShipperProjectionsByShipperProjectionEntryVesselIdAndShipperProjectionIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjection` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionVesselShipperProjectionsByShipperProjectionEntryVesselIdAndShipperProjectionIdManyToManyEdge = {
  __typename?: 'ShipperProjectionVesselShipperProjectionsByShipperProjectionEntryVesselIdAndShipperProjectionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjection` at the end of the edge. */
  node?: Maybe<ShipperProjection>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntries: ShipperProjectionEntriesConnection;
};


/** A `ShipperProjection` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionVesselShipperProjectionsByShipperProjectionEntryVesselIdAndShipperProjectionIdManyToManyEdgeShipperProjectionEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};

/** A `ShipperProjectionVessel` edge in the connection. */
export type ShipperProjectionVesselsEdge = {
  __typename?: 'ShipperProjectionVesselsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionVessel` at the end of the edge. */
  node?: Maybe<ShipperProjectionVessel>;
};

/** A connection to a list of `ShipperProjectionProduct` values. */
export type ShipperProjectionProductsConnection = {
  __typename?: 'ShipperProjectionProductsConnection';
  /** A list of `ShipperProjectionProduct` objects. */
  nodes: Array<Maybe<ShipperProjectionProduct>>;
  /** A list of edges which contains the `ShipperProjectionProduct` and cursor to aid in pagination. */
  edges: Array<ShipperProjectionProductsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionProduct` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjectionProduct` edge in the connection. */
export type ShipperProjectionProductsEdge = {
  __typename?: 'ShipperProjectionProductsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionProduct` at the end of the edge. */
  node?: Maybe<ShipperProjectionProduct>;
};

/** A connection to a list of `ShipperProjection` values. */
export type ShipperProjectionsConnection = {
  __typename?: 'ShipperProjectionsConnection';
  /** A list of `ShipperProjection` objects. */
  nodes: Array<Maybe<ShipperProjection>>;
  /** A list of edges which contains the `ShipperProjection` and cursor to aid in pagination. */
  edges: Array<ShipperProjectionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjection` edge in the connection. */
export type ShipperProjectionsEdge = {
  __typename?: 'ShipperProjectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjection` at the end of the edge. */
  node?: Maybe<ShipperProjection>;
};

/** A connection to a list of `PersonContact` values, with data from `ShipperPersonContact`. */
export type ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdManyToManyConnection = {
  __typename?: 'ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdManyToManyConnection';
  /** A list of `PersonContact` objects. */
  nodes: Array<Maybe<PersonContact>>;
  /** A list of edges which contains the `PersonContact`, info from the `ShipperPersonContact`, and the cursor to aid in pagination. */
  edges: Array<ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PersonContact` edge in the connection, with data from `ShipperPersonContact`. */
export type ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdManyToManyEdge = {
  __typename?: 'ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PersonContact` at the end of the edge. */
  node?: Maybe<PersonContact>;
};

/** Methods to use when ordering `PersonContact`. */
export enum PersonContactsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  IsPrimaryAsc = 'IS_PRIMARY_ASC',
  IsPrimaryDesc = 'IS_PRIMARY_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  SecondaryEmailAsc = 'SECONDARY_EMAIL_ASC',
  SecondaryEmailDesc = 'SECONDARY_EMAIL_DESC',
  HomePhoneAsc = 'HOME_PHONE_ASC',
  HomePhoneDesc = 'HOME_PHONE_DESC',
  CellPhoneAsc = 'CELL_PHONE_ASC',
  CellPhoneDesc = 'CELL_PHONE_DESC',
  WorkPhoneAsc = 'WORK_PHONE_ASC',
  WorkPhoneDesc = 'WORK_PHONE_DESC',
  WorkExtensionAsc = 'WORK_EXTENSION_ASC',
  WorkExtensionDesc = 'WORK_EXTENSION_DESC',
  ImageSrcAsc = 'IMAGE_SRC_ASC',
  ImageSrcDesc = 'IMAGE_SRC_DESC',
  IsInternalAsc = 'IS_INTERNAL_ASC',
  IsInternalDesc = 'IS_INTERNAL_DESC',
  RolesAsc = 'ROLES_ASC',
  RolesDesc = 'ROLES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CustomersByCustomerPersonContactPersonContactIdAndCustomerIdAsc = 'CUSTOMERS_BY_CUSTOMER_PERSON_CONTACT_PERSON_CONTACT_ID_AND_CUSTOMER_ID_ASC',
  CustomersByCustomerPersonContactPersonContactIdAndCustomerIdDesc = 'CUSTOMERS_BY_CUSTOMER_PERSON_CONTACT_PERSON_CONTACT_ID_AND_CUSTOMER_ID_DESC',
  ShippersByShipperPersonContactPersonContactIdAndShipperIdAsc = 'SHIPPERS_BY_SHIPPER_PERSON_CONTACT_PERSON_CONTACT_ID_AND_SHIPPER_ID_ASC',
  ShippersByShipperPersonContactPersonContactIdAndShipperIdDesc = 'SHIPPERS_BY_SHIPPER_PERSON_CONTACT_PERSON_CONTACT_ID_AND_SHIPPER_ID_DESC',
  WarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdAsc = 'WAREHOUSES_BY_WAREHOUSE_PERSON_CONTACT_PERSON_CONTACT_ID_AND_WAREHOUSE_ID_ASC',
  WarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdDesc = 'WAREHOUSES_BY_WAREHOUSE_PERSON_CONTACT_PERSON_CONTACT_ID_AND_WAREHOUSE_ID_DESC'
}

/**
 * A condition to be used against `PersonContact` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PersonContactCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isPrimary` field. */
  isPrimary?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `email` field. */
  email?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryEmail` field. */
  secondaryEmail?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `homePhone` field. */
  homePhone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cellPhone` field. */
  cellPhone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `workPhone` field. */
  workPhone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `workExtension` field. */
  workExtension?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `imageSrc` field. */
  imageSrc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isInternal` field. */
  isInternal?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `roles` field. */
  roles?: Maybe<Scalars['String']>;
};

/** A `Shipper` edge in the connection. */
export type ShippersEdge = {
  __typename?: 'ShippersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
};

/** Methods to use when ordering `Shipper`. */
export enum ShippersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperNameAsc = 'SHIPPER_NAME_ASC',
  ShipperNameDesc = 'SHIPPER_NAME_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  LogoSrcAsc = 'LOGO_SRC_ASC',
  LogoSrcDesc = 'LOGO_SRC_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  WebsiteAsc = 'WEBSITE_ASC',
  WebsiteDesc = 'WEBSITE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `Shipper` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ShipperCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperName` field. */
  shipperName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `logoSrc` field. */
  logoSrc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Warehouse` values. */
export type WarehousesConnection = {
  __typename?: 'WarehousesConnection';
  /** A list of `Warehouse` objects. */
  nodes: Array<Maybe<Warehouse>>;
  /** A list of edges which contains the `Warehouse` and cursor to aid in pagination. */
  edges: Array<WarehousesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Warehouse` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Warehouse = Node & {
  __typename?: 'Warehouse';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  warehouseName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  /** Reads a single `Country` that is related to this `Warehouse`. */
  country?: Maybe<Country>;
  /** Reads and enables pagination through a set of `WarehousePersonContact`. */
  warehousePersonContacts: WarehousePersonContactsConnection;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PersonContact`. */
  personContactsByWarehousePersonContactWarehouseIdAndPersonContactId: WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdManyToManyConnection;
};


export type WarehouseWarehousePersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WarehousePersonContactsOrderBy>>;
  condition?: Maybe<WarehousePersonContactCondition>;
  filter?: Maybe<WarehousePersonContactFilter>;
};


export type WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
  condition?: Maybe<PersonContactCondition>;
  filter?: Maybe<PersonContactFilter>;
};

/** A connection to a list of `WarehousePersonContact` values. */
export type WarehousePersonContactsConnection = {
  __typename?: 'WarehousePersonContactsConnection';
  /** A list of `WarehousePersonContact` objects. */
  nodes: Array<Maybe<WarehousePersonContact>>;
  /** A list of edges which contains the `WarehousePersonContact` and cursor to aid in pagination. */
  edges: Array<WarehousePersonContactsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WarehousePersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type WarehousePersonContact = Node & {
  __typename?: 'WarehousePersonContact';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
  /** Reads a single `Warehouse` that is related to this `WarehousePersonContact`. */
  warehouse?: Maybe<Warehouse>;
  /** Reads a single `PersonContact` that is related to this `WarehousePersonContact`. */
  personContact?: Maybe<PersonContact>;
};

/** A `WarehousePersonContact` edge in the connection. */
export type WarehousePersonContactsEdge = {
  __typename?: 'WarehousePersonContactsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `WarehousePersonContact` at the end of the edge. */
  node?: Maybe<WarehousePersonContact>;
};

/** Methods to use when ordering `WarehousePersonContact`. */
export enum WarehousePersonContactsOrderBy {
  Natural = 'NATURAL',
  WarehouseIdAsc = 'WAREHOUSE_ID_ASC',
  WarehouseIdDesc = 'WAREHOUSE_ID_DESC',
  PersonContactIdAsc = 'PERSON_CONTACT_ID_ASC',
  PersonContactIdDesc = 'PERSON_CONTACT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `WarehousePersonContact` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type WarehousePersonContactCondition = {
  /** Checks for equality with the object’s `warehouseId` field. */
  warehouseId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `personContactId` field. */
  personContactId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `PersonContact` values, with data from `WarehousePersonContact`. */
export type WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdManyToManyConnection = {
  __typename?: 'WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdManyToManyConnection';
  /** A list of `PersonContact` objects. */
  nodes: Array<Maybe<PersonContact>>;
  /** A list of edges which contains the `PersonContact`, info from the `WarehousePersonContact`, and the cursor to aid in pagination. */
  edges: Array<WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PersonContact` edge in the connection, with data from `WarehousePersonContact`. */
export type WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdManyToManyEdge = {
  __typename?: 'WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PersonContact` at the end of the edge. */
  node?: Maybe<PersonContact>;
};

/** A `Warehouse` edge in the connection. */
export type WarehousesEdge = {
  __typename?: 'WarehousesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Warehouse` at the end of the edge. */
  node?: Maybe<Warehouse>;
};

/** Methods to use when ordering `Warehouse`. */
export enum WarehousesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  WarehouseNameAsc = 'WAREHOUSE_NAME_ASC',
  WarehouseNameDesc = 'WAREHOUSE_NAME_DESC',
  Address_1Asc = 'ADDRESS_1_ASC',
  Address_1Desc = 'ADDRESS_1_DESC',
  Address_2Asc = 'ADDRESS_2_ASC',
  Address_2Desc = 'ADDRESS_2_DESC',
  Address_3Asc = 'ADDRESS_3_ASC',
  Address_3Desc = 'ADDRESS_3_DESC',
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  PostalStateAsc = 'POSTAL_STATE_ASC',
  PostalStateDesc = 'POSTAL_STATE_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  ZipCodeAsc = 'ZIP_CODE_ASC',
  ZipCodeDesc = 'ZIP_CODE_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  OutQueueAsc = 'OUT_QUEUE_ASC',
  OutQueueDesc = 'OUT_QUEUE_DESC',
  StateTaxCodeAsc = 'STATE_TAX_CODE_ASC',
  StateTaxCodeDesc = 'STATE_TAX_CODE_DESC',
  CountyTaxCodeAsc = 'COUNTY_TAX_CODE_ASC',
  CountyTaxCodeDesc = 'COUNTY_TAX_CODE_DESC',
  CityTaxCodeAsc = 'CITY_TAX_CODE_ASC',
  CityTaxCodeDesc = 'CITY_TAX_CODE_DESC',
  MiscTaxCodeAsc = 'MISC_TAX_CODE_ASC',
  MiscTaxCodeDesc = 'MISC_TAX_CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `Warehouse` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type WarehouseCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `warehouseName` field. */
  warehouseName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address1` field. */
  address1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address2` field. */
  address2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address3` field. */
  address3?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `postalState` field. */
  postalState?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `zipCode` field. */
  zipCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `outQueue` field. */
  outQueue?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stateTaxCode` field. */
  stateTaxCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countyTaxCode` field. */
  countyTaxCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cityTaxCode` field. */
  cityTaxCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `miscTaxCode` field. */
  miscTaxCode?: Maybe<Scalars['String']>;
};

/** Methods to use when ordering `CustomerPersonContact`. */
export enum CustomerPersonContactsOrderBy {
  Natural = 'NATURAL',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  PersonContactIdAsc = 'PERSON_CONTACT_ID_ASC',
  PersonContactIdDesc = 'PERSON_CONTACT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `CustomerPersonContact` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type CustomerPersonContactCondition = {
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `personContactId` field. */
  personContactId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `PersonContact` values, with data from `CustomerPersonContact`. */
export type CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdManyToManyConnection = {
  __typename?: 'CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdManyToManyConnection';
  /** A list of `PersonContact` objects. */
  nodes: Array<Maybe<PersonContact>>;
  /** A list of edges which contains the `PersonContact`, info from the `CustomerPersonContact`, and the cursor to aid in pagination. */
  edges: Array<CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PersonContact` edge in the connection, with data from `CustomerPersonContact`. */
export type CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdManyToManyEdge = {
  __typename?: 'CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PersonContact` at the end of the edge. */
  node?: Maybe<PersonContact>;
};

/** A `CustomerPersonContact` edge in the connection. */
export type CustomerPersonContactsEdge = {
  __typename?: 'CustomerPersonContactsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CustomerPersonContact` at the end of the edge. */
  node?: Maybe<CustomerPersonContact>;
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PinAsc = 'PIN_ASC',
  PinDesc = 'PIN_DESC',
  PersonContactIdAsc = 'PERSON_CONTACT_ID_ASC',
  PersonContactIdDesc = 'PERSON_CONTACT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pin` field. */
  pin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `personContactId` field. */
  personContactId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `ContactGroupPersonContact` values. */
export type ContactGroupPersonContactsConnection = {
  __typename?: 'ContactGroupPersonContactsConnection';
  /** A list of `ContactGroupPersonContact` objects. */
  nodes: Array<Maybe<ContactGroupPersonContact>>;
  /** A list of edges which contains the `ContactGroupPersonContact` and cursor to aid in pagination. */
  edges: Array<ContactGroupPersonContactsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ContactGroupPersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ContactGroupPersonContact = Node & {
  __typename?: 'ContactGroupPersonContact';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
  /** Reads a single `ContactGroup` that is related to this `ContactGroupPersonContact`. */
  group?: Maybe<ContactGroup>;
  /** Reads a single `PersonContact` that is related to this `ContactGroupPersonContact`. */
  personContact?: Maybe<PersonContact>;
};

export type ContactGroup = Node & {
  __typename?: 'ContactGroup';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  groupDescription: Scalars['String'];
  groupName: Scalars['String'];
  userId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `User` that is related to this `ContactGroup`. */
  user?: Maybe<User>;
  /** Reads and enables pagination through a set of `ContactGroupPersonContact`. */
  contactGroupPersonContactsByGroupId: ContactGroupPersonContactsConnection;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PersonContact`. */
  personContactsByContactGroupPersonContactGroupIdAndPersonContactId: ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdManyToManyConnection;
};


export type ContactGroupContactGroupPersonContactsByGroupIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContactGroupPersonContactsOrderBy>>;
  condition?: Maybe<ContactGroupPersonContactCondition>;
  filter?: Maybe<ContactGroupPersonContactFilter>;
};


export type ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
  condition?: Maybe<PersonContactCondition>;
  filter?: Maybe<PersonContactFilter>;
};

/** Methods to use when ordering `ContactGroupPersonContact`. */
export enum ContactGroupPersonContactsOrderBy {
  Natural = 'NATURAL',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  PersonContactIdAsc = 'PERSON_CONTACT_ID_ASC',
  PersonContactIdDesc = 'PERSON_CONTACT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ContactGroupPersonContact` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ContactGroupPersonContactCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `personContactId` field. */
  personContactId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `PersonContact` values, with data from `ContactGroupPersonContact`. */
export type ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdManyToManyConnection = {
  __typename?: 'ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdManyToManyConnection';
  /** A list of `PersonContact` objects. */
  nodes: Array<Maybe<PersonContact>>;
  /** A list of edges which contains the `PersonContact`, info from the `ContactGroupPersonContact`, and the cursor to aid in pagination. */
  edges: Array<ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PersonContact` edge in the connection, with data from `ContactGroupPersonContact`. */
export type ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdManyToManyEdge = {
  __typename?: 'ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PersonContact` at the end of the edge. */
  node?: Maybe<PersonContact>;
};

/** A `ContactGroupPersonContact` edge in the connection. */
export type ContactGroupPersonContactsEdge = {
  __typename?: 'ContactGroupPersonContactsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ContactGroupPersonContact` at the end of the edge. */
  node?: Maybe<ContactGroupPersonContact>;
};

/** A connection to a list of `Customer` values, with data from `CustomerPersonContact`. */
export type PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdManyToManyConnection = {
  __typename?: 'PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `CustomerPersonContact`, and the cursor to aid in pagination. */
  edges: Array<PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `CustomerPersonContact`. */
export type PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdManyToManyEdge = {
  __typename?: 'PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
};

/** A connection to a list of `Shipper` values, with data from `ShipperPersonContact`. */
export type PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdManyToManyConnection = {
  __typename?: 'PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperPersonContact`, and the cursor to aid in pagination. */
  edges: Array<PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperPersonContact`. */
export type PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdManyToManyEdge = {
  __typename?: 'PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
};

/** A connection to a list of `Warehouse` values, with data from `WarehousePersonContact`. */
export type PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdManyToManyConnection = {
  __typename?: 'PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdManyToManyConnection';
  /** A list of `Warehouse` objects. */
  nodes: Array<Maybe<Warehouse>>;
  /** A list of edges which contains the `Warehouse`, info from the `WarehousePersonContact`, and the cursor to aid in pagination. */
  edges: Array<PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Warehouse` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Warehouse` edge in the connection, with data from `WarehousePersonContact`. */
export type PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdManyToManyEdge = {
  __typename?: 'PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Warehouse` at the end of the edge. */
  node?: Maybe<Warehouse>;
};

/** A connection to a list of `ContactGroup` values, with data from `ContactGroupPersonContact`. */
export type PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdManyToManyConnection = {
  __typename?: 'PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdManyToManyConnection';
  /** A list of `ContactGroup` objects. */
  nodes: Array<Maybe<ContactGroup>>;
  /** A list of edges which contains the `ContactGroup`, info from the `ContactGroupPersonContact`, and the cursor to aid in pagination. */
  edges: Array<PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ContactGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ContactGroup` edge in the connection, with data from `ContactGroupPersonContact`. */
export type PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdManyToManyEdge = {
  __typename?: 'PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ContactGroup` at the end of the edge. */
  node?: Maybe<ContactGroup>;
};

/** Methods to use when ordering `ContactGroup`. */
export enum ContactGroupsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  GroupDescriptionAsc = 'GROUP_DESCRIPTION_ASC',
  GroupDescriptionDesc = 'GROUP_DESCRIPTION_DESC',
  GroupNameAsc = 'GROUP_NAME_ASC',
  GroupNameDesc = 'GROUP_NAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ContactGroup` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ContactGroupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `groupDescription` field. */
  groupDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `groupName` field. */
  groupName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `UserMessage` values. */
export type UserMessagesConnection = {
  __typename?: 'UserMessagesConnection';
  /** A list of `UserMessage` objects. */
  nodes: Array<Maybe<UserMessage>>;
  /** A list of edges which contains the `UserMessage` and cursor to aid in pagination. */
  edges: Array<UserMessagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserMessage` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type UserMessage = Node & {
  __typename?: 'UserMessage';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  actionLink?: Maybe<Scalars['String']>;
  actionText?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  header?: Maybe<Scalars['String']>;
  isRead: Scalars['Boolean'];
  messageDate?: Maybe<Scalars['Datetime']>;
  priority?: Maybe<Scalars['BigFloat']>;
  userId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `User` that is related to this `UserMessage`. */
  user?: Maybe<User>;
};

/** A `UserMessage` edge in the connection. */
export type UserMessagesEdge = {
  __typename?: 'UserMessagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UserMessage` at the end of the edge. */
  node?: Maybe<UserMessage>;
};

/** Methods to use when ordering `UserMessage`. */
export enum UserMessagesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ActionLinkAsc = 'ACTION_LINK_ASC',
  ActionLinkDesc = 'ACTION_LINK_DESC',
  ActionTextAsc = 'ACTION_TEXT_ASC',
  ActionTextDesc = 'ACTION_TEXT_DESC',
  DetailsAsc = 'DETAILS_ASC',
  DetailsDesc = 'DETAILS_DESC',
  HeaderAsc = 'HEADER_ASC',
  HeaderDesc = 'HEADER_DESC',
  IsReadAsc = 'IS_READ_ASC',
  IsReadDesc = 'IS_READ_DESC',
  MessageDateAsc = 'MESSAGE_DATE_ASC',
  MessageDateDesc = 'MESSAGE_DATE_DESC',
  PriorityAsc = 'PRIORITY_ASC',
  PriorityDesc = 'PRIORITY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `UserMessage` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserMessageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `actionLink` field. */
  actionLink?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `actionText` field. */
  actionText?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `details` field. */
  details?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `header` field. */
  header?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isRead` field. */
  isRead?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `messageDate` field. */
  messageDate?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `priority` field. */
  priority?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `ContactGroup` values. */
export type ContactGroupsConnection = {
  __typename?: 'ContactGroupsConnection';
  /** A list of `ContactGroup` objects. */
  nodes: Array<Maybe<ContactGroup>>;
  /** A list of edges which contains the `ContactGroup` and cursor to aid in pagination. */
  edges: Array<ContactGroupsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ContactGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ContactGroup` edge in the connection. */
export type ContactGroupsEdge = {
  __typename?: 'ContactGroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ContactGroup` at the end of the edge. */
  node?: Maybe<ContactGroup>;
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};

/** A connection to a list of `Country` values. */
export type CountriesConnection = {
  __typename?: 'CountriesConnection';
  /** A list of `Country` objects. */
  nodes: Array<Maybe<Country>>;
  /** A list of edges which contains the `Country` and cursor to aid in pagination. */
  edges: Array<CountriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Country` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Country` edge in the connection. */
export type CountriesEdge = {
  __typename?: 'CountriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Country` at the end of the edge. */
  node?: Maybe<Country>;
};

/** Methods to use when ordering `Country`. */
export enum CountriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CountryNameAsc = 'COUNTRY_NAME_ASC',
  CountryNameDesc = 'COUNTRY_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `Country` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CountryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryName` field. */
  countryName?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PersonContact` values. */
export type PersonContactsConnection = {
  __typename?: 'PersonContactsConnection';
  /** A list of `PersonContact` objects. */
  nodes: Array<Maybe<PersonContact>>;
  /** A list of edges which contains the `PersonContact` and cursor to aid in pagination. */
  edges: Array<PersonContactsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PersonContact` edge in the connection. */
export type PersonContactsEdge = {
  __typename?: 'PersonContactsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PersonContact` at the end of the edge. */
  node?: Maybe<PersonContact>;
};

/** A connection to a list of `ChileDepartureInspectionPallet` values. */
export type ChileDepartureInspectionPalletsConnection = {
  __typename?: 'ChileDepartureInspectionPalletsConnection';
  /** A list of `ChileDepartureInspectionPallet` objects. */
  nodes: Array<Maybe<ChileDepartureInspectionPallet>>;
  /** A list of edges which contains the `ChileDepartureInspectionPallet` and cursor to aid in pagination. */
  edges: Array<ChileDepartureInspectionPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ChileDepartureInspectionPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ChileDepartureInspectionPallet = Node & {
  __typename?: 'ChileDepartureInspectionPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  lotId?: Maybe<Scalars['String']>;
  lotNumber?: Maybe<Scalars['String']>;
  locationName?: Maybe<Scalars['String']>;
  shipper?: Maybe<Scalars['String']>;
  inspectionDate?: Maybe<Scalars['Date']>;
  productName?: Maybe<Scalars['String']>;
  packingType?: Maybe<Scalars['String']>;
  productType?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  supervisor?: Maybe<Scalars['String']>;
  palletNumber?: Maybe<Scalars['String']>;
  boxesCount?: Maybe<Scalars['BigFloat']>;
  netWeight?: Maybe<Scalars['BigFloat']>;
  grower?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  packingDate?: Maybe<Scalars['Date']>;
  label?: Maybe<Scalars['String']>;
  temperature?: Maybe<Scalars['String']>;
  openAppearance?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  stem?: Maybe<Scalars['String']>;
  texture?: Maybe<Scalars['String']>;
  bunchesCount?: Maybe<Scalars['BigFloat']>;
  brix?: Maybe<Scalars['BigFloat']>;
  diameterMin?: Maybe<Scalars['BigFloat']>;
  diameterMax?: Maybe<Scalars['BigFloat']>;
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  decayPct?: Maybe<Scalars['BigFloat']>;
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  shatterPct?: Maybe<Scalars['BigFloat']>;
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  scoreName?: Maybe<Scalars['String']>;
  reportLink?: Maybe<Scalars['String']>;
  imagesLink?: Maybe<Scalars['String']>;
};

/** A `ChileDepartureInspectionPallet` edge in the connection. */
export type ChileDepartureInspectionPalletsEdge = {
  __typename?: 'ChileDepartureInspectionPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ChileDepartureInspectionPallet` at the end of the edge. */
  node?: Maybe<ChileDepartureInspectionPallet>;
};

/** Methods to use when ordering `ChileDepartureInspectionPallet`. */
export enum ChileDepartureInspectionPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LotIdAsc = 'LOT_ID_ASC',
  LotIdDesc = 'LOT_ID_DESC',
  LotNumberAsc = 'LOT_NUMBER_ASC',
  LotNumberDesc = 'LOT_NUMBER_DESC',
  LocationNameAsc = 'LOCATION_NAME_ASC',
  LocationNameDesc = 'LOCATION_NAME_DESC',
  ShipperAsc = 'SHIPPER_ASC',
  ShipperDesc = 'SHIPPER_DESC',
  InspectionDateAsc = 'INSPECTION_DATE_ASC',
  InspectionDateDesc = 'INSPECTION_DATE_DESC',
  ProductNameAsc = 'PRODUCT_NAME_ASC',
  ProductNameDesc = 'PRODUCT_NAME_DESC',
  PackingTypeAsc = 'PACKING_TYPE_ASC',
  PackingTypeDesc = 'PACKING_TYPE_DESC',
  ProductTypeAsc = 'PRODUCT_TYPE_ASC',
  ProductTypeDesc = 'PRODUCT_TYPE_DESC',
  PalletCountAsc = 'PALLET_COUNT_ASC',
  PalletCountDesc = 'PALLET_COUNT_DESC',
  SupervisorAsc = 'SUPERVISOR_ASC',
  SupervisorDesc = 'SUPERVISOR_DESC',
  PalletNumberAsc = 'PALLET_NUMBER_ASC',
  PalletNumberDesc = 'PALLET_NUMBER_DESC',
  BoxesCountAsc = 'BOXES_COUNT_ASC',
  BoxesCountDesc = 'BOXES_COUNT_DESC',
  NetWeightAsc = 'NET_WEIGHT_ASC',
  NetWeightDesc = 'NET_WEIGHT_DESC',
  GrowerAsc = 'GROWER_ASC',
  GrowerDesc = 'GROWER_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  PackingDateAsc = 'PACKING_DATE_ASC',
  PackingDateDesc = 'PACKING_DATE_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  TemperatureAsc = 'TEMPERATURE_ASC',
  TemperatureDesc = 'TEMPERATURE_DESC',
  OpenAppearanceAsc = 'OPEN_APPEARANCE_ASC',
  OpenAppearanceDesc = 'OPEN_APPEARANCE_DESC',
  ColorAsc = 'COLOR_ASC',
  ColorDesc = 'COLOR_DESC',
  StemAsc = 'STEM_ASC',
  StemDesc = 'STEM_DESC',
  TextureAsc = 'TEXTURE_ASC',
  TextureDesc = 'TEXTURE_DESC',
  BunchesCountAsc = 'BUNCHES_COUNT_ASC',
  BunchesCountDesc = 'BUNCHES_COUNT_DESC',
  BrixAsc = 'BRIX_ASC',
  BrixDesc = 'BRIX_DESC',
  DiameterMinAsc = 'DIAMETER_MIN_ASC',
  DiameterMinDesc = 'DIAMETER_MIN_DESC',
  DiameterMaxAsc = 'DIAMETER_MAX_ASC',
  DiameterMaxDesc = 'DIAMETER_MAX_DESC',
  StragglyTightPctAsc = 'STRAGGLY_TIGHT_PCT_ASC',
  StragglyTightPctDesc = 'STRAGGLY_TIGHT_PCT_DESC',
  SurfaceDiscPctAsc = 'SURFACE_DISC_PCT_ASC',
  SurfaceDiscPctDesc = 'SURFACE_DISC_PCT_DESC',
  RussetScarsPctAsc = 'RUSSET_SCARS_PCT_ASC',
  RussetScarsPctDesc = 'RUSSET_SCARS_PCT_DESC',
  SunburnPctAsc = 'SUNBURN_PCT_ASC',
  SunburnPctDesc = 'SUNBURN_PCT_DESC',
  UndersizedBunchesPctAsc = 'UNDERSIZED_BUNCHES_PCT_ASC',
  UndersizedBunchesPctDesc = 'UNDERSIZED_BUNCHES_PCT_DESC',
  OtherDefectsPctAsc = 'OTHER_DEFECTS_PCT_ASC',
  OtherDefectsPctDesc = 'OTHER_DEFECTS_PCT_DESC',
  StemDehyPctAsc = 'STEM_DEHY_PCT_ASC',
  StemDehyPctDesc = 'STEM_DEHY_PCT_DESC',
  GlassyWeakPctAsc = 'GLASSY_WEAK_PCT_ASC',
  GlassyWeakPctDesc = 'GLASSY_WEAK_PCT_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  SplitCrushedPctAsc = 'SPLIT_CRUSHED_PCT_ASC',
  SplitCrushedPctDesc = 'SPLIT_CRUSHED_PCT_DESC',
  DrySplitPctAsc = 'DRY_SPLIT_PCT_ASC',
  DrySplitPctDesc = 'DRY_SPLIT_PCT_DESC',
  WetStickyPctAsc = 'WET_STICKY_PCT_ASC',
  WetStickyPctDesc = 'WET_STICKY_PCT_DESC',
  WaterberriesPctAsc = 'WATERBERRIES_PCT_ASC',
  WaterberriesPctDesc = 'WATERBERRIES_PCT_DESC',
  ShatterPctAsc = 'SHATTER_PCT_ASC',
  ShatterPctDesc = 'SHATTER_PCT_DESC',
  TotalQualityDefectsPctAsc = 'TOTAL_QUALITY_DEFECTS_PCT_ASC',
  TotalQualityDefectsPctDesc = 'TOTAL_QUALITY_DEFECTS_PCT_DESC',
  TotalConditionDefectsPctAsc = 'TOTAL_CONDITION_DEFECTS_PCT_ASC',
  TotalConditionDefectsPctDesc = 'TOTAL_CONDITION_DEFECTS_PCT_DESC',
  QualityScoreAsc = 'QUALITY_SCORE_ASC',
  QualityScoreDesc = 'QUALITY_SCORE_DESC',
  ConditionScoreAsc = 'CONDITION_SCORE_ASC',
  ConditionScoreDesc = 'CONDITION_SCORE_DESC',
  ScoreNameAsc = 'SCORE_NAME_ASC',
  ScoreNameDesc = 'SCORE_NAME_DESC',
  ReportLinkAsc = 'REPORT_LINK_ASC',
  ReportLinkDesc = 'REPORT_LINK_DESC',
  ImagesLinkAsc = 'IMAGES_LINK_ASC',
  ImagesLinkDesc = 'IMAGES_LINK_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ChileDepartureInspectionPallet` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type ChileDepartureInspectionPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotId` field. */
  lotId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotNumber` field. */
  lotNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `locationName` field. */
  locationName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipper` field. */
  shipper?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionDate` field. */
  inspectionDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `productName` field. */
  productName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packingType` field. */
  packingType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productType` field. */
  productType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletCount` field. */
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `supervisor` field. */
  supervisor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletNumber` field. */
  palletNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxesCount` field. */
  boxesCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `netWeight` field. */
  netWeight?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `grower` field. */
  grower?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packingDate` field. */
  packingDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `label` field. */
  label?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `temperature` field. */
  temperature?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `openAppearance` field. */
  openAppearance?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `color` field. */
  color?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stem` field. */
  stem?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `texture` field. */
  texture?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bunchesCount` field. */
  bunchesCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `brix` field. */
  brix?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `diameterMin` field. */
  diameterMin?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `diameterMax` field. */
  diameterMax?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `stragglyTightPct` field. */
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `surfaceDiscPct` field. */
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `russetScarsPct` field. */
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `sunburnPct` field. */
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `undersizedBunchesPct` field. */
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `otherDefectsPct` field. */
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `stemDehyPct` field. */
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `glassyWeakPct` field. */
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `splitCrushedPct` field. */
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `drySplitPct` field. */
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `wetStickyPct` field. */
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `waterberriesPct` field. */
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `shatterPct` field. */
  shatterPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `totalQualityDefectsPct` field. */
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `totalConditionDefectsPct` field. */
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `qualityScore` field. */
  qualityScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `conditionScore` field. */
  conditionScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `scoreName` field. */
  scoreName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `reportLink` field. */
  reportLink?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `imagesLink` field. */
  imagesLink?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ChileDepartureInspectionPallet` object types. All fields are combined with a logical ‘and.’ */
export type ChileDepartureInspectionPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `lotId` field. */
  lotId?: Maybe<StringFilter>;
  /** Filter by the object’s `lotNumber` field. */
  lotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `locationName` field. */
  locationName?: Maybe<StringFilter>;
  /** Filter by the object’s `shipper` field. */
  shipper?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionDate` field. */
  inspectionDate?: Maybe<DateFilter>;
  /** Filter by the object’s `productName` field. */
  productName?: Maybe<StringFilter>;
  /** Filter by the object’s `packingType` field. */
  packingType?: Maybe<StringFilter>;
  /** Filter by the object’s `productType` field. */
  productType?: Maybe<StringFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `supervisor` field. */
  supervisor?: Maybe<StringFilter>;
  /** Filter by the object’s `palletNumber` field. */
  palletNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `boxesCount` field. */
  boxesCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `netWeight` field. */
  netWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `grower` field. */
  grower?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `packingDate` field. */
  packingDate?: Maybe<DateFilter>;
  /** Filter by the object’s `label` field. */
  label?: Maybe<StringFilter>;
  /** Filter by the object’s `temperature` field. */
  temperature?: Maybe<StringFilter>;
  /** Filter by the object’s `openAppearance` field. */
  openAppearance?: Maybe<StringFilter>;
  /** Filter by the object’s `color` field. */
  color?: Maybe<StringFilter>;
  /** Filter by the object’s `stem` field. */
  stem?: Maybe<StringFilter>;
  /** Filter by the object’s `texture` field. */
  texture?: Maybe<StringFilter>;
  /** Filter by the object’s `bunchesCount` field. */
  bunchesCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brix` field. */
  brix?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `diameterMin` field. */
  diameterMin?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `diameterMax` field. */
  diameterMax?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `stragglyTightPct` field. */
  stragglyTightPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `surfaceDiscPct` field. */
  surfaceDiscPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `russetScarsPct` field. */
  russetScarsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `sunburnPct` field. */
  sunburnPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `undersizedBunchesPct` field. */
  undersizedBunchesPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `otherDefectsPct` field. */
  otherDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `stemDehyPct` field. */
  stemDehyPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `glassyWeakPct` field. */
  glassyWeakPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `splitCrushedPct` field. */
  splitCrushedPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `drySplitPct` field. */
  drySplitPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `wetStickyPct` field. */
  wetStickyPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `waterberriesPct` field. */
  waterberriesPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `shatterPct` field. */
  shatterPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `totalQualityDefectsPct` field. */
  totalQualityDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `totalConditionDefectsPct` field. */
  totalConditionDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `qualityScore` field. */
  qualityScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `conditionScore` field. */
  conditionScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `scoreName` field. */
  scoreName?: Maybe<StringFilter>;
  /** Filter by the object’s `reportLink` field. */
  reportLink?: Maybe<StringFilter>;
  /** Filter by the object’s `imagesLink` field. */
  imagesLink?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ChileDepartureInspectionPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ChileDepartureInspectionPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<ChileDepartureInspectionPalletFilter>;
};

/** A connection to a list of `PeruDepartureInspection` values. */
export type PeruDepartureInspectionsConnection = {
  __typename?: 'PeruDepartureInspectionsConnection';
  /** A list of `PeruDepartureInspection` objects. */
  nodes: Array<Maybe<PeruDepartureInspection>>;
  /** A list of edges which contains the `PeruDepartureInspection` and cursor to aid in pagination. */
  edges: Array<PeruDepartureInspectionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PeruDepartureInspection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PeruDepartureInspection = Node & {
  __typename?: 'PeruDepartureInspection';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  containerId: Scalars['String'];
  avgBunchesPerBox: Scalars['BigFloat'];
  avgNetWeight: Scalars['BigFloat'];
  bagsPerBox: Scalars['BigFloat'];
  bagType?: Maybe<Scalars['String']>;
  brand: Scalars['String'];
  brixAvg: Scalars['BigFloat'];
  brixMax: Scalars['BigFloat'];
  brixMin: Scalars['BigFloat'];
  category: Scalars['String'];
  comments: Scalars['String'];
  conditionScore: Scalars['BigFloat'];
  departureWeek: Scalars['String'];
  destination: Scalars['String'];
  exporter: Scalars['String'];
  inspectionDate: Scalars['Date'];
  packingDate: Scalars['Date'];
  packingHouse: Scalars['String'];
  packingMaterial: Scalars['String'];
  presentation: Scalars['String'];
  qualityScore: Scalars['BigFloat'];
  variety: Scalars['String'];
  /** Reads and enables pagination through a set of `PeruDepartureInspectionPallet`. */
  peruDepartureInspectionPalletsByContainerId: PeruDepartureInspectionPalletsConnection;
  searchText?: Maybe<Scalars['String']>;
  imageUrls?: Maybe<Array<Scalars['String']>>;
};


export type PeruDepartureInspectionPeruDepartureInspectionPalletsByContainerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PeruDepartureInspectionPalletsOrderBy>>;
  condition?: Maybe<PeruDepartureInspectionPalletCondition>;
  filter?: Maybe<PeruDepartureInspectionPalletFilter>;
};

/** A connection to a list of `PeruDepartureInspectionPallet` values. */
export type PeruDepartureInspectionPalletsConnection = {
  __typename?: 'PeruDepartureInspectionPalletsConnection';
  /** A list of `PeruDepartureInspectionPallet` objects. */
  nodes: Array<Maybe<PeruDepartureInspectionPallet>>;
  /** A list of edges which contains the `PeruDepartureInspectionPallet` and cursor to aid in pagination. */
  edges: Array<PeruDepartureInspectionPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PeruDepartureInspectionPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PeruDepartureInspectionPallet = Node & {
  __typename?: 'PeruDepartureInspectionPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  palletId: Scalars['String'];
  containerId: Scalars['String'];
  size: Scalars['String'];
  netWeight: Scalars['BigFloat'];
  openingScore: Scalars['BigFloat'];
  colorScore: Scalars['BigFloat'];
  stemScore: Scalars['BigFloat'];
  textureScore: Scalars['BigFloat'];
  bunchesPerBox: Scalars['BigFloat'];
  brix: Scalars['BigFloat'];
  qualityScore: Scalars['BigFloat'];
  conditionScore: Scalars['BigFloat'];
  stragglyTightPct: Scalars['BigFloat'];
  surfaceDiscPct: Scalars['BigFloat'];
  russetScarsPct: Scalars['BigFloat'];
  sunburnPct: Scalars['BigFloat'];
  undersizedBunchesPct: Scalars['BigFloat'];
  otherDefectsPct: Scalars['BigFloat'];
  totalQualityDefectsPct: Scalars['BigFloat'];
  stemDehyPct: Scalars['BigFloat'];
  glassyWeakPct: Scalars['BigFloat'];
  decayPct: Scalars['BigFloat'];
  splitCrushedPct: Scalars['BigFloat'];
  drySplitPct: Scalars['BigFloat'];
  wetStickyPct: Scalars['BigFloat'];
  waterberriesPct: Scalars['BigFloat'];
  shatterPct: Scalars['BigFloat'];
  totalConditionDefectsPct: Scalars['BigFloat'];
  totalDefectsPct: Scalars['BigFloat'];
  /** Reads a single `PeruDepartureInspection` that is related to this `PeruDepartureInspectionPallet`. */
  container?: Maybe<PeruDepartureInspection>;
};

/** A `PeruDepartureInspectionPallet` edge in the connection. */
export type PeruDepartureInspectionPalletsEdge = {
  __typename?: 'PeruDepartureInspectionPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PeruDepartureInspectionPallet` at the end of the edge. */
  node?: Maybe<PeruDepartureInspectionPallet>;
};

/** Methods to use when ordering `PeruDepartureInspectionPallet`. */
export enum PeruDepartureInspectionPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  NetWeightAsc = 'NET_WEIGHT_ASC',
  NetWeightDesc = 'NET_WEIGHT_DESC',
  OpeningScoreAsc = 'OPENING_SCORE_ASC',
  OpeningScoreDesc = 'OPENING_SCORE_DESC',
  ColorScoreAsc = 'COLOR_SCORE_ASC',
  ColorScoreDesc = 'COLOR_SCORE_DESC',
  StemScoreAsc = 'STEM_SCORE_ASC',
  StemScoreDesc = 'STEM_SCORE_DESC',
  TextureScoreAsc = 'TEXTURE_SCORE_ASC',
  TextureScoreDesc = 'TEXTURE_SCORE_DESC',
  BunchesPerBoxAsc = 'BUNCHES_PER_BOX_ASC',
  BunchesPerBoxDesc = 'BUNCHES_PER_BOX_DESC',
  BrixAsc = 'BRIX_ASC',
  BrixDesc = 'BRIX_DESC',
  QualityScoreAsc = 'QUALITY_SCORE_ASC',
  QualityScoreDesc = 'QUALITY_SCORE_DESC',
  ConditionScoreAsc = 'CONDITION_SCORE_ASC',
  ConditionScoreDesc = 'CONDITION_SCORE_DESC',
  StragglyTightPctAsc = 'STRAGGLY_TIGHT_PCT_ASC',
  StragglyTightPctDesc = 'STRAGGLY_TIGHT_PCT_DESC',
  SurfaceDiscPctAsc = 'SURFACE_DISC_PCT_ASC',
  SurfaceDiscPctDesc = 'SURFACE_DISC_PCT_DESC',
  RussetScarsPctAsc = 'RUSSET_SCARS_PCT_ASC',
  RussetScarsPctDesc = 'RUSSET_SCARS_PCT_DESC',
  SunburnPctAsc = 'SUNBURN_PCT_ASC',
  SunburnPctDesc = 'SUNBURN_PCT_DESC',
  UndersizedBunchesPctAsc = 'UNDERSIZED_BUNCHES_PCT_ASC',
  UndersizedBunchesPctDesc = 'UNDERSIZED_BUNCHES_PCT_DESC',
  OtherDefectsPctAsc = 'OTHER_DEFECTS_PCT_ASC',
  OtherDefectsPctDesc = 'OTHER_DEFECTS_PCT_DESC',
  TotalQualityDefectsPctAsc = 'TOTAL_QUALITY_DEFECTS_PCT_ASC',
  TotalQualityDefectsPctDesc = 'TOTAL_QUALITY_DEFECTS_PCT_DESC',
  StemDehyPctAsc = 'STEM_DEHY_PCT_ASC',
  StemDehyPctDesc = 'STEM_DEHY_PCT_DESC',
  GlassyWeakPctAsc = 'GLASSY_WEAK_PCT_ASC',
  GlassyWeakPctDesc = 'GLASSY_WEAK_PCT_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  SplitCrushedPctAsc = 'SPLIT_CRUSHED_PCT_ASC',
  SplitCrushedPctDesc = 'SPLIT_CRUSHED_PCT_DESC',
  DrySplitPctAsc = 'DRY_SPLIT_PCT_ASC',
  DrySplitPctDesc = 'DRY_SPLIT_PCT_DESC',
  WetStickyPctAsc = 'WET_STICKY_PCT_ASC',
  WetStickyPctDesc = 'WET_STICKY_PCT_DESC',
  WaterberriesPctAsc = 'WATERBERRIES_PCT_ASC',
  WaterberriesPctDesc = 'WATERBERRIES_PCT_DESC',
  ShatterPctAsc = 'SHATTER_PCT_ASC',
  ShatterPctDesc = 'SHATTER_PCT_DESC',
  TotalConditionDefectsPctAsc = 'TOTAL_CONDITION_DEFECTS_PCT_ASC',
  TotalConditionDefectsPctDesc = 'TOTAL_CONDITION_DEFECTS_PCT_DESC',
  TotalDefectsPctAsc = 'TOTAL_DEFECTS_PCT_ASC',
  TotalDefectsPctDesc = 'TOTAL_DEFECTS_PCT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PeruDepartureInspectionPallet` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type PeruDepartureInspectionPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `netWeight` field. */
  netWeight?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `openingScore` field. */
  openingScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `colorScore` field. */
  colorScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `stemScore` field. */
  stemScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `textureScore` field. */
  textureScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `bunchesPerBox` field. */
  bunchesPerBox?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `brix` field. */
  brix?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `qualityScore` field. */
  qualityScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `conditionScore` field. */
  conditionScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `stragglyTightPct` field. */
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `surfaceDiscPct` field. */
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `russetScarsPct` field. */
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `sunburnPct` field. */
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `undersizedBunchesPct` field. */
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `otherDefectsPct` field. */
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `totalQualityDefectsPct` field. */
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `stemDehyPct` field. */
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `glassyWeakPct` field. */
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `splitCrushedPct` field. */
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `drySplitPct` field. */
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `wetStickyPct` field. */
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `waterberriesPct` field. */
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `shatterPct` field. */
  shatterPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `totalConditionDefectsPct` field. */
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `totalDefectsPct` field. */
  totalDefectsPct?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `PeruDepartureInspectionPallet` object types. All fields are combined with a logical ‘and.’ */
export type PeruDepartureInspectionPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `netWeight` field. */
  netWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `openingScore` field. */
  openingScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `colorScore` field. */
  colorScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `stemScore` field. */
  stemScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `textureScore` field. */
  textureScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `bunchesPerBox` field. */
  bunchesPerBox?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brix` field. */
  brix?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `qualityScore` field. */
  qualityScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `conditionScore` field. */
  conditionScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `stragglyTightPct` field. */
  stragglyTightPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `surfaceDiscPct` field. */
  surfaceDiscPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `russetScarsPct` field. */
  russetScarsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `sunburnPct` field. */
  sunburnPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `undersizedBunchesPct` field. */
  undersizedBunchesPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `otherDefectsPct` field. */
  otherDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `totalQualityDefectsPct` field. */
  totalQualityDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `stemDehyPct` field. */
  stemDehyPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `glassyWeakPct` field. */
  glassyWeakPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `splitCrushedPct` field. */
  splitCrushedPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `drySplitPct` field. */
  drySplitPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `wetStickyPct` field. */
  wetStickyPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `waterberriesPct` field. */
  waterberriesPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `shatterPct` field. */
  shatterPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `totalConditionDefectsPct` field. */
  totalConditionDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `totalDefectsPct` field. */
  totalDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `container` relation. */
  container?: Maybe<PeruDepartureInspectionFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PeruDepartureInspectionPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PeruDepartureInspectionPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PeruDepartureInspectionPalletFilter>;
};

/** A filter to be used against `PeruDepartureInspection` object types. All fields are combined with a logical ‘and.’ */
export type PeruDepartureInspectionFilter = {
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `avgBunchesPerBox` field. */
  avgBunchesPerBox?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `avgNetWeight` field. */
  avgNetWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `bagsPerBox` field. */
  bagsPerBox?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `bagType` field. */
  bagType?: Maybe<StringFilter>;
  /** Filter by the object’s `brand` field. */
  brand?: Maybe<StringFilter>;
  /** Filter by the object’s `brixAvg` field. */
  brixAvg?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brixMax` field. */
  brixMax?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brixMin` field. */
  brixMin?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `category` field. */
  category?: Maybe<StringFilter>;
  /** Filter by the object’s `comments` field. */
  comments?: Maybe<StringFilter>;
  /** Filter by the object’s `conditionScore` field. */
  conditionScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `departureWeek` field. */
  departureWeek?: Maybe<StringFilter>;
  /** Filter by the object’s `destination` field. */
  destination?: Maybe<StringFilter>;
  /** Filter by the object’s `exporter` field. */
  exporter?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionDate` field. */
  inspectionDate?: Maybe<DateFilter>;
  /** Filter by the object’s `packingDate` field. */
  packingDate?: Maybe<DateFilter>;
  /** Filter by the object’s `packingHouse` field. */
  packingHouse?: Maybe<StringFilter>;
  /** Filter by the object’s `packingMaterial` field. */
  packingMaterial?: Maybe<StringFilter>;
  /** Filter by the object’s `presentation` field. */
  presentation?: Maybe<StringFilter>;
  /** Filter by the object’s `qualityScore` field. */
  qualityScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `peruDepartureInspectionPalletsByContainerId` relation. */
  peruDepartureInspectionPalletsByContainerId?: Maybe<PeruDepartureInspectionToManyPeruDepartureInspectionPalletFilter>;
  /** Some related `peruDepartureInspectionPalletsByContainerId` exist. */
  peruDepartureInspectionPalletsByContainerIdExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PeruDepartureInspectionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PeruDepartureInspectionFilter>>;
  /** Negates the expression. */
  not?: Maybe<PeruDepartureInspectionFilter>;
};

/** A filter to be used against many `PeruDepartureInspectionPallet` object types. All fields are combined with a logical ‘and.’ */
export type PeruDepartureInspectionToManyPeruDepartureInspectionPalletFilter = {
  /** Every related `PeruDepartureInspectionPallet` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PeruDepartureInspectionPalletFilter>;
  /** Some related `PeruDepartureInspectionPallet` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PeruDepartureInspectionPalletFilter>;
  /** No related `PeruDepartureInspectionPallet` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PeruDepartureInspectionPalletFilter>;
};

/** A `PeruDepartureInspection` edge in the connection. */
export type PeruDepartureInspectionsEdge = {
  __typename?: 'PeruDepartureInspectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PeruDepartureInspection` at the end of the edge. */
  node?: Maybe<PeruDepartureInspection>;
};

/** Methods to use when ordering `PeruDepartureInspection`. */
export enum PeruDepartureInspectionsOrderBy {
  Natural = 'NATURAL',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  AvgBunchesPerBoxAsc = 'AVG_BUNCHES_PER_BOX_ASC',
  AvgBunchesPerBoxDesc = 'AVG_BUNCHES_PER_BOX_DESC',
  AvgNetWeightAsc = 'AVG_NET_WEIGHT_ASC',
  AvgNetWeightDesc = 'AVG_NET_WEIGHT_DESC',
  BagsPerBoxAsc = 'BAGS_PER_BOX_ASC',
  BagsPerBoxDesc = 'BAGS_PER_BOX_DESC',
  BagTypeAsc = 'BAG_TYPE_ASC',
  BagTypeDesc = 'BAG_TYPE_DESC',
  BrandAsc = 'BRAND_ASC',
  BrandDesc = 'BRAND_DESC',
  BrixAvgAsc = 'BRIX_AVG_ASC',
  BrixAvgDesc = 'BRIX_AVG_DESC',
  BrixMaxAsc = 'BRIX_MAX_ASC',
  BrixMaxDesc = 'BRIX_MAX_DESC',
  BrixMinAsc = 'BRIX_MIN_ASC',
  BrixMinDesc = 'BRIX_MIN_DESC',
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  CommentsAsc = 'COMMENTS_ASC',
  CommentsDesc = 'COMMENTS_DESC',
  ConditionScoreAsc = 'CONDITION_SCORE_ASC',
  ConditionScoreDesc = 'CONDITION_SCORE_DESC',
  DepartureWeekAsc = 'DEPARTURE_WEEK_ASC',
  DepartureWeekDesc = 'DEPARTURE_WEEK_DESC',
  DestinationAsc = 'DESTINATION_ASC',
  DestinationDesc = 'DESTINATION_DESC',
  ExporterAsc = 'EXPORTER_ASC',
  ExporterDesc = 'EXPORTER_DESC',
  InspectionDateAsc = 'INSPECTION_DATE_ASC',
  InspectionDateDesc = 'INSPECTION_DATE_DESC',
  PackingDateAsc = 'PACKING_DATE_ASC',
  PackingDateDesc = 'PACKING_DATE_DESC',
  PackingHouseAsc = 'PACKING_HOUSE_ASC',
  PackingHouseDesc = 'PACKING_HOUSE_DESC',
  PackingMaterialAsc = 'PACKING_MATERIAL_ASC',
  PackingMaterialDesc = 'PACKING_MATERIAL_DESC',
  PresentationAsc = 'PRESENTATION_ASC',
  PresentationDesc = 'PRESENTATION_DESC',
  QualityScoreAsc = 'QUALITY_SCORE_ASC',
  QualityScoreDesc = 'QUALITY_SCORE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PeruDepartureInspection` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type PeruDepartureInspectionCondition = {
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `avgBunchesPerBox` field. */
  avgBunchesPerBox?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `avgNetWeight` field. */
  avgNetWeight?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `bagsPerBox` field. */
  bagsPerBox?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `bagType` field. */
  bagType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brand` field. */
  brand?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixAvg` field. */
  brixAvg?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `brixMax` field. */
  brixMax?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `brixMin` field. */
  brixMin?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `category` field. */
  category?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comments` field. */
  comments?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `conditionScore` field. */
  conditionScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `departureWeek` field. */
  departureWeek?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `destination` field. */
  destination?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporter` field. */
  exporter?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionDate` field. */
  inspectionDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `packingDate` field. */
  packingDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `packingHouse` field. */
  packingHouse?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packingMaterial` field. */
  packingMaterial?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `presentation` field. */
  presentation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `qualityScore` field. */
  qualityScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaApplePallet` values. */
export type PsaApplePalletsConnection = {
  __typename?: 'PsaApplePalletsConnection';
  /** A list of `PsaApplePallet` objects. */
  nodes: Array<Maybe<PsaApplePallet>>;
  /** A list of edges which contains the `PsaApplePallet` and cursor to aid in pagination. */
  edges: Array<PsaApplePalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaApplePallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PsaApplePallet = Node & {
  __typename?: 'PsaApplePallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  stemPuncturesPct?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  sunScaldPieces?: Maybe<Scalars['String']>;
  sunScaldPct?: Maybe<Scalars['String']>;
  sunScaldDeg?: Maybe<Scalars['String']>;
  scaldPieces?: Maybe<Scalars['String']>;
  scaldPct?: Maybe<Scalars['String']>;
  scaldDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  crackingPieces?: Maybe<Scalars['String']>;
  crackingPct?: Maybe<Scalars['String']>;
  bitterPitPieces?: Maybe<Scalars['String']>;
  bitterPitPct?: Maybe<Scalars['String']>;
  bitterPitDeg?: Maybe<Scalars['String']>;
  lenticelBreakdownPieces?: Maybe<Scalars['String']>;
  lenticelBreakdownPct?: Maybe<Scalars['String']>;
  lenticelBreakdownDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  watercorePieces?: Maybe<Scalars['String']>;
  watercorePct?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaApplePalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/** A connection to a list of `PsaArrivalPicture` values. */
export type PsaArrivalPicturesConnection = {
  __typename?: 'PsaArrivalPicturesConnection';
  /** A list of `PsaArrivalPicture` objects. */
  nodes: Array<Maybe<PsaArrivalPicture>>;
  /** A list of edges which contains the `PsaArrivalPicture` and cursor to aid in pagination. */
  edges: Array<PsaArrivalPicturesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaArrivalPicture` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PsaArrivalPicture = Node & {
  __typename?: 'PsaArrivalPicture';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  pictureDate?: Maybe<Scalars['Date']>;
  arrivalCode?: Maybe<Scalars['String']>;
  pictureDescription?: Maybe<Scalars['String']>;
  exporterId?: Maybe<Scalars['BigInt']>;
  palletId?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  varietyName?: Maybe<Scalars['String']>;
  imageUrl: Scalars['String'];
};

/** A `PsaArrivalPicture` edge in the connection. */
export type PsaArrivalPicturesEdge = {
  __typename?: 'PsaArrivalPicturesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaArrivalPicture` at the end of the edge. */
  node?: Maybe<PsaArrivalPicture>;
};

/** A filter to be used against `PsaArrivalPicture` object types. All fields are combined with a logical ‘and.’ */
export type PsaArrivalPictureFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `pictureDate` field. */
  pictureDate?: Maybe<DateFilter>;
  /** Filter by the object’s `arrivalCode` field. */
  arrivalCode?: Maybe<StringFilter>;
  /** Filter by the object’s `pictureDescription` field. */
  pictureDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterId` field. */
  exporterId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `varietyName` field. */
  varietyName?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaArrivalPictureFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaArrivalPictureFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaArrivalPictureFilter>;
};

/** A `PsaApplePallet` edge in the connection. */
export type PsaApplePalletsEdge = {
  __typename?: 'PsaApplePalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaApplePallet` at the end of the edge. */
  node?: Maybe<PsaApplePallet>;
};

/** Methods to use when ordering `PsaApplePallet`. */
export enum PsaApplePalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  RunNumberAsc = 'RUN_NUMBER_ASC',
  RunNumberDesc = 'RUN_NUMBER_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  GradeAsc = 'GRADE_ASC',
  GradeDesc = 'GRADE_DESC',
  InspGradeAsc = 'INSP_GRADE_ASC',
  InspGradeDesc = 'INSP_GRADE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  GroundColorAsc = 'GROUND_COLOR_ASC',
  GroundColorDesc = 'GROUND_COLOR_DESC',
  BlushColorAsc = 'BLUSH_COLOR_ASC',
  BlushColorDesc = 'BLUSH_COLOR_DESC',
  BlushPctAsc = 'BLUSH_PCT_ASC',
  BlushPctDesc = 'BLUSH_PCT_DESC',
  ScarsPiecesAsc = 'SCARS_PIECES_ASC',
  ScarsPiecesDesc = 'SCARS_PIECES_DESC',
  ScarsPctAsc = 'SCARS_PCT_ASC',
  ScarsPctDesc = 'SCARS_PCT_DESC',
  ScarsDegAsc = 'SCARS_DEG_ASC',
  ScarsDegDesc = 'SCARS_DEG_DESC',
  StemPuncturesPiecesAsc = 'STEM_PUNCTURES_PIECES_ASC',
  StemPuncturesPiecesDesc = 'STEM_PUNCTURES_PIECES_DESC',
  StemPuncturesPctAsc = 'STEM_PUNCTURES_PCT_ASC',
  StemPuncturesPctDesc = 'STEM_PUNCTURES_PCT_DESC',
  CutsPiecesAsc = 'CUTS_PIECES_ASC',
  CutsPiecesDesc = 'CUTS_PIECES_DESC',
  CutsPctAsc = 'CUTS_PCT_ASC',
  CutsPctDesc = 'CUTS_PCT_DESC',
  CutsDegAsc = 'CUTS_DEG_ASC',
  CutsDegDesc = 'CUTS_DEG_DESC',
  SunScaldPiecesAsc = 'SUN_SCALD_PIECES_ASC',
  SunScaldPiecesDesc = 'SUN_SCALD_PIECES_DESC',
  SunScaldPctAsc = 'SUN_SCALD_PCT_ASC',
  SunScaldPctDesc = 'SUN_SCALD_PCT_DESC',
  SunScaldDegAsc = 'SUN_SCALD_DEG_ASC',
  SunScaldDegDesc = 'SUN_SCALD_DEG_DESC',
  ScaldPiecesAsc = 'SCALD_PIECES_ASC',
  ScaldPiecesDesc = 'SCALD_PIECES_DESC',
  ScaldPctAsc = 'SCALD_PCT_ASC',
  ScaldPctDesc = 'SCALD_PCT_DESC',
  ScaldDegAsc = 'SCALD_DEG_ASC',
  ScaldDegDesc = 'SCALD_DEG_DESC',
  BruisingPiecesAsc = 'BRUISING_PIECES_ASC',
  BruisingPiecesDesc = 'BRUISING_PIECES_DESC',
  BruisingPctAsc = 'BRUISING_PCT_ASC',
  BruisingPctDesc = 'BRUISING_PCT_DESC',
  BruisingDegAsc = 'BRUISING_DEG_ASC',
  BruisingDegDesc = 'BRUISING_DEG_DESC',
  CrackingPiecesAsc = 'CRACKING_PIECES_ASC',
  CrackingPiecesDesc = 'CRACKING_PIECES_DESC',
  CrackingPctAsc = 'CRACKING_PCT_ASC',
  CrackingPctDesc = 'CRACKING_PCT_DESC',
  BitterPitPiecesAsc = 'BITTER_PIT_PIECES_ASC',
  BitterPitPiecesDesc = 'BITTER_PIT_PIECES_DESC',
  BitterPitPctAsc = 'BITTER_PIT_PCT_ASC',
  BitterPitPctDesc = 'BITTER_PIT_PCT_DESC',
  BitterPitDegAsc = 'BITTER_PIT_DEG_ASC',
  BitterPitDegDesc = 'BITTER_PIT_DEG_DESC',
  LenticelBreakdownPiecesAsc = 'LENTICEL_BREAKDOWN_PIECES_ASC',
  LenticelBreakdownPiecesDesc = 'LENTICEL_BREAKDOWN_PIECES_DESC',
  LenticelBreakdownPctAsc = 'LENTICEL_BREAKDOWN_PCT_ASC',
  LenticelBreakdownPctDesc = 'LENTICEL_BREAKDOWN_PCT_DESC',
  LenticelBreakdownDegAsc = 'LENTICEL_BREAKDOWN_DEG_ASC',
  LenticelBreakdownDegDesc = 'LENTICEL_BREAKDOWN_DEG_DESC',
  DehydrationPiecesAsc = 'DEHYDRATION_PIECES_ASC',
  DehydrationPiecesDesc = 'DEHYDRATION_PIECES_DESC',
  DehydrationPctAsc = 'DEHYDRATION_PCT_ASC',
  DehydrationPctDesc = 'DEHYDRATION_PCT_DESC',
  DehydrationDegAsc = 'DEHYDRATION_DEG_ASC',
  DehydrationDegDesc = 'DEHYDRATION_DEG_DESC',
  CutCountAsc = 'CUT_COUNT_ASC',
  CutCountDesc = 'CUT_COUNT_DESC',
  WatercorePiecesAsc = 'WATERCORE_PIECES_ASC',
  WatercorePiecesDesc = 'WATERCORE_PIECES_DESC',
  WatercorePctAsc = 'WATERCORE_PCT_ASC',
  WatercorePctDesc = 'WATERCORE_PCT_DESC',
  InternalDamagePiecesAsc = 'INTERNAL_DAMAGE_PIECES_ASC',
  InternalDamagePiecesDesc = 'INTERNAL_DAMAGE_PIECES_DESC',
  InternalDamagePerAsc = 'INTERNAL_DAMAGE_PER_ASC',
  InternalDamagePerDesc = 'INTERNAL_DAMAGE_PER_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  Pressure1Asc = 'PRESSURE1_ASC',
  Pressure1Desc = 'PRESSURE1_DESC',
  Pressure2Asc = 'PRESSURE2_ASC',
  Pressure2Desc = 'PRESSURE2_DESC',
  Pressure3Asc = 'PRESSURE3_ASC',
  Pressure3Desc = 'PRESSURE3_DESC',
  Pressure4Asc = 'PRESSURE4_ASC',
  Pressure4Desc = 'PRESSURE4_DESC',
  Pressure5Asc = 'PRESSURE5_ASC',
  Pressure5Desc = 'PRESSURE5_DESC',
  Pressure6Asc = 'PRESSURE6_ASC',
  Pressure6Desc = 'PRESSURE6_DESC',
  PressuresMinAsc = 'PRESSURES_MIN_ASC',
  PressuresMinDesc = 'PRESSURES_MIN_DESC',
  PressuresMaxAsc = 'PRESSURES_MAX_ASC',
  PressuresMaxDesc = 'PRESSURES_MAX_DESC',
  PressuresAvgAsc = 'PRESSURES_AVG_ASC',
  PressuresAvgDesc = 'PRESSURES_AVG_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PsaApplePallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaApplePalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `runNumber` field. */
  runNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `grade` field. */
  grade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrade` field. */
  inspGrade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `groundColor` field. */
  groundColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushColor` field. */
  blushColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushPct` field. */
  blushPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPct` field. */
  scarsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemPuncturesPieces` field. */
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemPuncturesPct` field. */
  stemPuncturesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsPieces` field. */
  cutsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsPct` field. */
  cutsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsDeg` field. */
  cutsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunScaldPieces` field. */
  sunScaldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunScaldPct` field. */
  sunScaldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunScaldDeg` field. */
  sunScaldDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scaldPieces` field. */
  scaldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scaldPct` field. */
  scaldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scaldDeg` field. */
  scaldDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `crackingPieces` field. */
  crackingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `crackingPct` field. */
  crackingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bitterPitPieces` field. */
  bitterPitPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bitterPitPct` field. */
  bitterPitPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bitterPitDeg` field. */
  bitterPitDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lenticelBreakdownPieces` field. */
  lenticelBreakdownPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lenticelBreakdownPct` field. */
  lenticelBreakdownPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lenticelBreakdownDeg` field. */
  lenticelBreakdownDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutCount` field. */
  cutCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `watercorePieces` field. */
  watercorePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `watercorePct` field. */
  watercorePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure1` field. */
  pressure1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure2` field. */
  pressure2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure3` field. */
  pressure3?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure4` field. */
  pressure4?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure5` field. */
  pressure5?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure6` field. */
  pressure6?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PsaApplePallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaApplePalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `runNumber` field. */
  runNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `grade` field. */
  grade?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrade` field. */
  inspGrade?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `groundColor` field. */
  groundColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushColor` field. */
  blushColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushPct` field. */
  blushPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPct` field. */
  scarsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `stemPuncturesPieces` field. */
  stemPuncturesPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `stemPuncturesPct` field. */
  stemPuncturesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsPieces` field. */
  cutsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsPct` field. */
  cutsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsDeg` field. */
  cutsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `sunScaldPieces` field. */
  sunScaldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `sunScaldPct` field. */
  sunScaldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `sunScaldDeg` field. */
  sunScaldDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `scaldPieces` field. */
  scaldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scaldPct` field. */
  scaldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scaldDeg` field. */
  scaldDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `crackingPieces` field. */
  crackingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `crackingPct` field. */
  crackingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bitterPitPieces` field. */
  bitterPitPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `bitterPitPct` field. */
  bitterPitPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bitterPitDeg` field. */
  bitterPitDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `lenticelBreakdownPieces` field. */
  lenticelBreakdownPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `lenticelBreakdownPct` field. */
  lenticelBreakdownPct?: Maybe<StringFilter>;
  /** Filter by the object’s `lenticelBreakdownDeg` field. */
  lenticelBreakdownDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutCount` field. */
  cutCount?: Maybe<StringFilter>;
  /** Filter by the object’s `watercorePieces` field. */
  watercorePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `watercorePct` field. */
  watercorePct?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure1` field. */
  pressure1?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure2` field. */
  pressure2?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure3` field. */
  pressure3?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure4` field. */
  pressure4?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure5` field. */
  pressure5?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure6` field. */
  pressure6?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaApplePalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaApplePalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaApplePalletFilter>;
};

/** Methods to use when ordering `PsaArrivalPicture`. */
export enum PsaArrivalPicturesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PictureDateAsc = 'PICTURE_DATE_ASC',
  PictureDateDesc = 'PICTURE_DATE_DESC',
  ArrivalCodeAsc = 'ARRIVAL_CODE_ASC',
  ArrivalCodeDesc = 'ARRIVAL_CODE_DESC',
  PictureDescriptionAsc = 'PICTURE_DESCRIPTION_ASC',
  PictureDescriptionDesc = 'PICTURE_DESCRIPTION_DESC',
  ExporterIdAsc = 'EXPORTER_ID_ASC',
  ExporterIdDesc = 'EXPORTER_ID_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyNameAsc = 'VARIETY_NAME_ASC',
  VarietyNameDesc = 'VARIETY_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PsaArrivalPicture` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaArrivalPictureCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pictureDate` field. */
  pictureDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `arrivalCode` field. */
  arrivalCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pictureDescription` field. */
  pictureDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterId` field. */
  exporterId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `varietyName` field. */
  varietyName?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaArrivalReport` values. */
export type PsaArrivalReportsConnection = {
  __typename?: 'PsaArrivalReportsConnection';
  /** A list of `PsaArrivalReport` objects. */
  nodes: Array<Maybe<PsaArrivalReport>>;
  /** A list of edges which contains the `PsaArrivalReport` and cursor to aid in pagination. */
  edges: Array<PsaArrivalReportsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaArrivalReport` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PsaArrivalReport = Node & {
  __typename?: 'PsaArrivalReport';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  reportDate?: Maybe<Scalars['Date']>;
  locationName?: Maybe<Scalars['String']>;
  arrivalCode?: Maybe<Scalars['String']>;
  arrivalName?: Maybe<Scalars['String']>;
  exporterId?: Maybe<Scalars['BigInt']>;
  exporterName?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaApplePallet`. */
  applePallets: PsaApplePalletsConnection;
  /** Reads and enables pagination through a set of `PsaCherryPallet`. */
  cherryPallets: PsaCherryPalletsConnection;
  /** Reads and enables pagination through a set of `PsaCitrusPallet`. */
  citrusPallets: PsaCitrusPalletsConnection;
  commodityList?: Maybe<Array<Maybe<Scalars['String']>>>;
  conditionRange?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaGrapePallet`. */
  grapePallets: PsaGrapePalletsConnection;
  /** Reads and enables pagination through a set of `PsaLemonPallet`. */
  lemonPallets: PsaLemonPalletsConnection;
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Reads and enables pagination through a set of `PsaPearPallet`. */
  pearPallets: PsaPearPalletsConnection;
  /** Reads and enables pagination through a set of `PsaPersimmonPallet`. */
  persimmonPallets: PsaPersimmonPalletsConnection;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
  /** Reads and enables pagination through a set of `PsaPomegranatePallet`. */
  pomegranatePallets: PsaPomegranatePalletsConnection;
  qualityRange?: Maybe<Scalars['String']>;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaStoneFruitPallet`. */
  stoneFruitPallets: PsaStoneFruitPalletsConnection;
  varietyList?: Maybe<Array<Maybe<Scalars['String']>>>;
  vessel?: Maybe<Vessel>;
  reportUrl: Scalars['String'];
};


export type PsaArrivalReportApplePalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaApplePalletsOrderBy>>;
  filter?: Maybe<PsaApplePalletFilter>;
};


export type PsaArrivalReportCherryPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaCherryPalletsOrderBy>>;
  filter?: Maybe<PsaCherryPalletFilter>;
};


export type PsaArrivalReportCitrusPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaCitrusPalletsOrderBy>>;
  filter?: Maybe<PsaCitrusPalletFilter>;
};


export type PsaArrivalReportGrapePalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaGrapePalletsOrderBy>>;
  filter?: Maybe<PsaGrapePalletFilter>;
};


export type PsaArrivalReportLemonPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaLemonPalletsOrderBy>>;
  filter?: Maybe<PsaLemonPalletFilter>;
};


export type PsaArrivalReportPearPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaPearPalletsOrderBy>>;
  filter?: Maybe<PsaPearPalletFilter>;
};


export type PsaArrivalReportPersimmonPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaPersimmonPalletsOrderBy>>;
  filter?: Maybe<PsaPersimmonPalletFilter>;
};


export type PsaArrivalReportPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PsaArrivalPictureCondition>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};


export type PsaArrivalReportPomegranatePalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaPomegranatePalletsOrderBy>>;
  filter?: Maybe<PsaPomegranatePalletFilter>;
};


export type PsaArrivalReportStoneFruitPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaStoneFruitPalletsOrderBy>>;
  filter?: Maybe<PsaStoneFruitPalletFilter>;
};


export type PsaArrivalReportVarietyListArgs = {
  com?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaCherryPallet` values. */
export type PsaCherryPalletsConnection = {
  __typename?: 'PsaCherryPalletsConnection';
  /** A list of `PsaCherryPallet` objects. */
  nodes: Array<Maybe<PsaCherryPallet>>;
  /** A list of edges which contains the `PsaCherryPallet` and cursor to aid in pagination. */
  edges: Array<PsaCherryPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaCherryPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PsaCherryPallet = Node & {
  __typename?: 'PsaCherryPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  sizeMin?: Maybe<Scalars['String']>;
  sizeMax?: Maybe<Scalars['String']>;
  sizeMost?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  scarsMarksPieces?: Maybe<Scalars['String']>;
  scarsMarksPct?: Maybe<Scalars['String']>;
  scarsMarksDeg?: Maybe<Scalars['String']>;
  misshapenPieces?: Maybe<Scalars['String']>;
  misshapenPct?: Maybe<Scalars['String']>;
  stemlessPieces?: Maybe<Scalars['String']>;
  stemlessPct?: Maybe<Scalars['String']>;
  splitsPieces?: Maybe<Scalars['String']>;
  splitsPct?: Maybe<Scalars['String']>;
  splitsDeg?: Maybe<Scalars['String']>;
  firmness?: Maybe<Scalars['String']>;
  pittingBruisingPieces?: Maybe<Scalars['String']>;
  pittingBruisingPct?: Maybe<Scalars['String']>;
  pittingBruisingDeg?: Maybe<Scalars['String']>;
  stemDehydrationPieces?: Maybe<Scalars['String']>;
  stemDehydrationPct?: Maybe<Scalars['String']>;
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaCherryPalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/** A `PsaCherryPallet` edge in the connection. */
export type PsaCherryPalletsEdge = {
  __typename?: 'PsaCherryPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaCherryPallet` at the end of the edge. */
  node?: Maybe<PsaCherryPallet>;
};

/** Methods to use when ordering `PsaCherryPallet`. */
export enum PsaCherryPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  SizeMinAsc = 'SIZE_MIN_ASC',
  SizeMinDesc = 'SIZE_MIN_DESC',
  SizeMaxAsc = 'SIZE_MAX_ASC',
  SizeMaxDesc = 'SIZE_MAX_DESC',
  SizeMostAsc = 'SIZE_MOST_ASC',
  SizeMostDesc = 'SIZE_MOST_DESC',
  ColorAsc = 'COLOR_ASC',
  ColorDesc = 'COLOR_DESC',
  ScarsMarksPiecesAsc = 'SCARS_MARKS_PIECES_ASC',
  ScarsMarksPiecesDesc = 'SCARS_MARKS_PIECES_DESC',
  ScarsMarksPctAsc = 'SCARS_MARKS_PCT_ASC',
  ScarsMarksPctDesc = 'SCARS_MARKS_PCT_DESC',
  ScarsMarksDegAsc = 'SCARS_MARKS_DEG_ASC',
  ScarsMarksDegDesc = 'SCARS_MARKS_DEG_DESC',
  MisshapenPiecesAsc = 'MISSHAPEN_PIECES_ASC',
  MisshapenPiecesDesc = 'MISSHAPEN_PIECES_DESC',
  MisshapenPctAsc = 'MISSHAPEN_PCT_ASC',
  MisshapenPctDesc = 'MISSHAPEN_PCT_DESC',
  StemlessPiecesAsc = 'STEMLESS_PIECES_ASC',
  StemlessPiecesDesc = 'STEMLESS_PIECES_DESC',
  StemlessPctAsc = 'STEMLESS_PCT_ASC',
  StemlessPctDesc = 'STEMLESS_PCT_DESC',
  SplitsPiecesAsc = 'SPLITS_PIECES_ASC',
  SplitsPiecesDesc = 'SPLITS_PIECES_DESC',
  SplitsPctAsc = 'SPLITS_PCT_ASC',
  SplitsPctDesc = 'SPLITS_PCT_DESC',
  SplitsDegAsc = 'SPLITS_DEG_ASC',
  SplitsDegDesc = 'SPLITS_DEG_DESC',
  FirmnessAsc = 'FIRMNESS_ASC',
  FirmnessDesc = 'FIRMNESS_DESC',
  PittingBruisingPiecesAsc = 'PITTING_BRUISING_PIECES_ASC',
  PittingBruisingPiecesDesc = 'PITTING_BRUISING_PIECES_DESC',
  PittingBruisingPctAsc = 'PITTING_BRUISING_PCT_ASC',
  PittingBruisingPctDesc = 'PITTING_BRUISING_PCT_DESC',
  PittingBruisingDegAsc = 'PITTING_BRUISING_DEG_ASC',
  PittingBruisingDegDesc = 'PITTING_BRUISING_DEG_DESC',
  StemDehydrationPiecesAsc = 'STEM_DEHYDRATION_PIECES_ASC',
  StemDehydrationPiecesDesc = 'STEM_DEHYDRATION_PIECES_DESC',
  StemDehydrationPctAsc = 'STEM_DEHYDRATION_PCT_ASC',
  StemDehydrationPctDesc = 'STEM_DEHYDRATION_PCT_DESC',
  StemDehydrationDegAsc = 'STEM_DEHYDRATION_DEG_ASC',
  StemDehydrationDegDesc = 'STEM_DEHYDRATION_DEG_DESC',
  DehydrationPiecesAsc = 'DEHYDRATION_PIECES_ASC',
  DehydrationPiecesDesc = 'DEHYDRATION_PIECES_DESC',
  DehydrationPctAsc = 'DEHYDRATION_PCT_ASC',
  DehydrationPctDesc = 'DEHYDRATION_PCT_DESC',
  DehydrationDegAsc = 'DEHYDRATION_DEG_ASC',
  DehydrationDegDesc = 'DEHYDRATION_DEG_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `PsaCherryPallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaCherryPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeMin` field. */
  sizeMin?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeMax` field. */
  sizeMax?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeMost` field. */
  sizeMost?: Maybe<StringFilter>;
  /** Filter by the object’s `color` field. */
  color?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsMarksPieces` field. */
  scarsMarksPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsMarksPct` field. */
  scarsMarksPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsMarksDeg` field. */
  scarsMarksDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `misshapenPieces` field. */
  misshapenPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `misshapenPct` field. */
  misshapenPct?: Maybe<StringFilter>;
  /** Filter by the object’s `stemlessPieces` field. */
  stemlessPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `stemlessPct` field. */
  stemlessPct?: Maybe<StringFilter>;
  /** Filter by the object’s `splitsPieces` field. */
  splitsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `splitsPct` field. */
  splitsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `splitsDeg` field. */
  splitsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `firmness` field. */
  firmness?: Maybe<StringFilter>;
  /** Filter by the object’s `pittingBruisingPieces` field. */
  pittingBruisingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `pittingBruisingPct` field. */
  pittingBruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pittingBruisingDeg` field. */
  pittingBruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `stemDehydrationPieces` field. */
  stemDehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `stemDehydrationPct` field. */
  stemDehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `stemDehydrationDeg` field. */
  stemDehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaCherryPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaCherryPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaCherryPalletFilter>;
};

/** A connection to a list of `PsaCitrusPallet` values. */
export type PsaCitrusPalletsConnection = {
  __typename?: 'PsaCitrusPalletsConnection';
  /** A list of `PsaCitrusPallet` objects. */
  nodes: Array<Maybe<PsaCitrusPallet>>;
  /** A list of edges which contains the `PsaCitrusPallet` and cursor to aid in pagination. */
  edges: Array<PsaCitrusPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaCitrusPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PsaCitrusPallet = Node & {
  __typename?: 'PsaCitrusPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  diameterMinMm?: Maybe<Scalars['String']>;
  diameterMinInches?: Maybe<Scalars['String']>;
  diameterMaxMm?: Maybe<Scalars['String']>;
  diameterMaxInches?: Maybe<Scalars['String']>;
  diameterMostMm?: Maybe<Scalars['String']>;
  diameterMostInches?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  greenHazePieces?: Maybe<Scalars['String']>;
  greenHazePct?: Maybe<Scalars['String']>;
  greenHazeDeg?: Maybe<Scalars['String']>;
  oilSpotsPieces?: Maybe<Scalars['String']>;
  oilSpotsPct?: Maybe<Scalars['String']>;
  oilSpotsDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  dryPulpPieces?: Maybe<Scalars['String']>;
  dryPulpPct?: Maybe<Scalars['String']>;
  dryPulpDeg?: Maybe<Scalars['String']>;
  seedsPieces?: Maybe<Scalars['String']>;
  seedsPct?: Maybe<Scalars['String']>;
  skinBreakdownPieces?: Maybe<Scalars['String']>;
  skinBreakdownPct?: Maybe<Scalars['String']>;
  skinBreakdownDeg?: Maybe<Scalars['String']>;
  creasingPieces?: Maybe<Scalars['String']>;
  creasingPct?: Maybe<Scalars['String']>;
  creasingDeg?: Maybe<Scalars['String']>;
  puffinessPieces?: Maybe<Scalars['String']>;
  puffinessPct?: Maybe<Scalars['String']>;
  puffinessDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  sporesPieces?: Maybe<Scalars['String']>;
  sporesPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaCitrusPalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/** A `PsaCitrusPallet` edge in the connection. */
export type PsaCitrusPalletsEdge = {
  __typename?: 'PsaCitrusPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaCitrusPallet` at the end of the edge. */
  node?: Maybe<PsaCitrusPallet>;
};

/** Methods to use when ordering `PsaCitrusPallet`. */
export enum PsaCitrusPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  ColorAsc = 'COLOR_ASC',
  ColorDesc = 'COLOR_DESC',
  DiameterMinMmAsc = 'DIAMETER_MIN_MM_ASC',
  DiameterMinMmDesc = 'DIAMETER_MIN_MM_DESC',
  DiameterMinInchesAsc = 'DIAMETER_MIN_INCHES_ASC',
  DiameterMinInchesDesc = 'DIAMETER_MIN_INCHES_DESC',
  DiameterMaxMmAsc = 'DIAMETER_MAX_MM_ASC',
  DiameterMaxMmDesc = 'DIAMETER_MAX_MM_DESC',
  DiameterMaxInchesAsc = 'DIAMETER_MAX_INCHES_ASC',
  DiameterMaxInchesDesc = 'DIAMETER_MAX_INCHES_DESC',
  DiameterMostMmAsc = 'DIAMETER_MOST_MM_ASC',
  DiameterMostMmDesc = 'DIAMETER_MOST_MM_DESC',
  DiameterMostInchesAsc = 'DIAMETER_MOST_INCHES_ASC',
  DiameterMostInchesDesc = 'DIAMETER_MOST_INCHES_DESC',
  ScarsPiecesAsc = 'SCARS_PIECES_ASC',
  ScarsPiecesDesc = 'SCARS_PIECES_DESC',
  ScarsPctAsc = 'SCARS_PCT_ASC',
  ScarsPctDesc = 'SCARS_PCT_DESC',
  ScarsDegAsc = 'SCARS_DEG_ASC',
  ScarsDegDesc = 'SCARS_DEG_DESC',
  GreenHazePiecesAsc = 'GREEN_HAZE_PIECES_ASC',
  GreenHazePiecesDesc = 'GREEN_HAZE_PIECES_DESC',
  GreenHazePctAsc = 'GREEN_HAZE_PCT_ASC',
  GreenHazePctDesc = 'GREEN_HAZE_PCT_DESC',
  GreenHazeDegAsc = 'GREEN_HAZE_DEG_ASC',
  GreenHazeDegDesc = 'GREEN_HAZE_DEG_DESC',
  OilSpotsPiecesAsc = 'OIL_SPOTS_PIECES_ASC',
  OilSpotsPiecesDesc = 'OIL_SPOTS_PIECES_DESC',
  OilSpotsPctAsc = 'OIL_SPOTS_PCT_ASC',
  OilSpotsPctDesc = 'OIL_SPOTS_PCT_DESC',
  OilSpotsDegAsc = 'OIL_SPOTS_DEG_ASC',
  OilSpotsDegDesc = 'OIL_SPOTS_DEG_DESC',
  CutCountAsc = 'CUT_COUNT_ASC',
  CutCountDesc = 'CUT_COUNT_DESC',
  DryPulpPiecesAsc = 'DRY_PULP_PIECES_ASC',
  DryPulpPiecesDesc = 'DRY_PULP_PIECES_DESC',
  DryPulpPctAsc = 'DRY_PULP_PCT_ASC',
  DryPulpPctDesc = 'DRY_PULP_PCT_DESC',
  DryPulpDegAsc = 'DRY_PULP_DEG_ASC',
  DryPulpDegDesc = 'DRY_PULP_DEG_DESC',
  SeedsPiecesAsc = 'SEEDS_PIECES_ASC',
  SeedsPiecesDesc = 'SEEDS_PIECES_DESC',
  SeedsPctAsc = 'SEEDS_PCT_ASC',
  SeedsPctDesc = 'SEEDS_PCT_DESC',
  SkinBreakdownPiecesAsc = 'SKIN_BREAKDOWN_PIECES_ASC',
  SkinBreakdownPiecesDesc = 'SKIN_BREAKDOWN_PIECES_DESC',
  SkinBreakdownPctAsc = 'SKIN_BREAKDOWN_PCT_ASC',
  SkinBreakdownPctDesc = 'SKIN_BREAKDOWN_PCT_DESC',
  SkinBreakdownDegAsc = 'SKIN_BREAKDOWN_DEG_ASC',
  SkinBreakdownDegDesc = 'SKIN_BREAKDOWN_DEG_DESC',
  CreasingPiecesAsc = 'CREASING_PIECES_ASC',
  CreasingPiecesDesc = 'CREASING_PIECES_DESC',
  CreasingPctAsc = 'CREASING_PCT_ASC',
  CreasingPctDesc = 'CREASING_PCT_DESC',
  CreasingDegAsc = 'CREASING_DEG_ASC',
  CreasingDegDesc = 'CREASING_DEG_DESC',
  PuffinessPiecesAsc = 'PUFFINESS_PIECES_ASC',
  PuffinessPiecesDesc = 'PUFFINESS_PIECES_DESC',
  PuffinessPctAsc = 'PUFFINESS_PCT_ASC',
  PuffinessPctDesc = 'PUFFINESS_PCT_DESC',
  PuffinessDegAsc = 'PUFFINESS_DEG_ASC',
  PuffinessDegDesc = 'PUFFINESS_DEG_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  SporesPiecesAsc = 'SPORES_PIECES_ASC',
  SporesPiecesDesc = 'SPORES_PIECES_DESC',
  SporesPctAsc = 'SPORES_PCT_ASC',
  SporesPctDesc = 'SPORES_PCT_DESC',
  BrixAsc = 'BRIX_ASC',
  BrixDesc = 'BRIX_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `PsaCitrusPallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaCitrusPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `color` field. */
  color?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMinMm` field. */
  diameterMinMm?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMinInches` field. */
  diameterMinInches?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMaxMm` field. */
  diameterMaxMm?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMaxInches` field. */
  diameterMaxInches?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMostMm` field. */
  diameterMostMm?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMostInches` field. */
  diameterMostInches?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPct` field. */
  scarsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `greenHazePieces` field. */
  greenHazePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `greenHazePct` field. */
  greenHazePct?: Maybe<StringFilter>;
  /** Filter by the object’s `greenHazeDeg` field. */
  greenHazeDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `oilSpotsPieces` field. */
  oilSpotsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `oilSpotsPct` field. */
  oilSpotsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `oilSpotsDeg` field. */
  oilSpotsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutCount` field. */
  cutCount?: Maybe<StringFilter>;
  /** Filter by the object’s `dryPulpPieces` field. */
  dryPulpPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dryPulpPct` field. */
  dryPulpPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dryPulpDeg` field. */
  dryPulpDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `seedsPieces` field. */
  seedsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `seedsPct` field. */
  seedsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `skinBreakdownPieces` field. */
  skinBreakdownPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `skinBreakdownPct` field. */
  skinBreakdownPct?: Maybe<StringFilter>;
  /** Filter by the object’s `skinBreakdownDeg` field. */
  skinBreakdownDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `creasingPieces` field. */
  creasingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `creasingPct` field. */
  creasingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `creasingDeg` field. */
  creasingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `puffinessPieces` field. */
  puffinessPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `puffinessPct` field. */
  puffinessPct?: Maybe<StringFilter>;
  /** Filter by the object’s `puffinessDeg` field. */
  puffinessDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `sporesPieces` field. */
  sporesPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `sporesPct` field. */
  sporesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `brix` field. */
  brix?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaCitrusPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaCitrusPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaCitrusPalletFilter>;
};

/** A connection to a list of `PsaGrapePallet` values. */
export type PsaGrapePalletsConnection = {
  __typename?: 'PsaGrapePalletsConnection';
  /** A list of `PsaGrapePallet` objects. */
  nodes: Array<Maybe<PsaGrapePallet>>;
  /** A list of edges which contains the `PsaGrapePallet` and cursor to aid in pagination. */
  edges: Array<PsaGrapePalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaGrapePallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PsaGrapePallet = Node & {
  __typename?: 'PsaGrapePallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['Date']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  autoOpening?: Maybe<Scalars['String']>;
  bunches?: Maybe<Scalars['String']>;
  sizeMin?: Maybe<Scalars['String']>;
  sizeMax?: Maybe<Scalars['String']>;
  sizeMost?: Maybe<Scalars['String']>;
  undersizeBunchesCount?: Maybe<Scalars['String']>;
  autoUndersizeBerriesBunches?: Maybe<Scalars['String']>;
  undersizeBerriesPct?: Maybe<Scalars['String']>;
  colorMin?: Maybe<Scalars['String']>;
  colorMax?: Maybe<Scalars['String']>;
  colorMost?: Maybe<Scalars['String']>;
  colorConsistency?: Maybe<Scalars['String']>;
  autoColorConsistency?: Maybe<Scalars['String']>;
  sunburnBunches?: Maybe<Scalars['String']>;
  autoSunburnBunches?: Maybe<Scalars['String']>;
  sunburnPct?: Maybe<Scalars['String']>;
  sunburnBunchesDeg?: Maybe<Scalars['String']>;
  bunchConformation?: Maybe<Scalars['String']>;
  autoBunchConformation?: Maybe<Scalars['String']>;
  stragglyBunches?: Maybe<Scalars['String']>;
  stragglyPct?: Maybe<Scalars['String']>;
  smallBunches?: Maybe<Scalars['String']>;
  russetMarksBunches?: Maybe<Scalars['String']>;
  russetMarksPct?: Maybe<Scalars['String']>;
  autoRussetMarksPct?: Maybe<Scalars['String']>;
  dustPct?: Maybe<Scalars['String']>;
  autoDustPct?: Maybe<Scalars['String']>;
  residuesPct?: Maybe<Scalars['String']>;
  autoResiduesPct?: Maybe<Scalars['String']>;
  tightBunches?: Maybe<Scalars['String']>;
  autoTightBunches?: Maybe<Scalars['String']>;
  bruisingBunches?: Maybe<Scalars['String']>;
  autoBruisingBunches?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  stemDehydrationPct?: Maybe<Scalars['String']>;
  autoStemDehydrationPct?: Maybe<Scalars['String']>;
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  berryCondition?: Maybe<Scalars['String']>;
  autoBerryCondition?: Maybe<Scalars['String']>;
  h2OBerries?: Maybe<Scalars['String']>;
  autoH2OBerries?: Maybe<Scalars['String']>;
  so2DamagePct?: Maybe<Scalars['String']>;
  autoSo2DamagePct?: Maybe<Scalars['String']>;
  so2DamageDeg?: Maybe<Scalars['String']>;
  weakBunches?: Maybe<Scalars['String']>;
  autoWeakBunches?: Maybe<Scalars['String']>;
  splitsHairlinePct?: Maybe<Scalars['String']>;
  autoSplitsHairlinePct?: Maybe<Scalars['String']>;
  splitsWetCrushPct?: Maybe<Scalars['String']>;
  autoSplitsWetCrushPct?: Maybe<Scalars['String']>;
  splitsDryPct?: Maybe<Scalars['String']>;
  autoSplitsDryPct?: Maybe<Scalars['String']>;
  intDisc?: Maybe<Scalars['String']>;
  autoIntDisc?: Maybe<Scalars['String']>;
  intDiscDeg?: Maybe<Scalars['String']>;
  decayMoldBerries?: Maybe<Scalars['String']>;
  autoDecayMoldBerries?: Maybe<Scalars['String']>;
  decaySlipskinBerries?: Maybe<Scalars['String']>;
  autoDecaySlipskinBerries?: Maybe<Scalars['String']>;
  decayNestBerries?: Maybe<Scalars['String']>;
  autoDecayNestBerries?: Maybe<Scalars['String']>;
  decayNestDeg?: Maybe<Scalars['String']>;
  shatterPct?: Maybe<Scalars['String']>;
  autoShatterPct?: Maybe<Scalars['String']>;
  brixMin?: Maybe<Scalars['String']>;
  brixMax?: Maybe<Scalars['String']>;
  brixMost?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  autoOverallQuality?: Maybe<Scalars['String']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  autoOverallCondition?: Maybe<Scalars['String']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaGrapePalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/** A `PsaGrapePallet` edge in the connection. */
export type PsaGrapePalletsEdge = {
  __typename?: 'PsaGrapePalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaGrapePallet` at the end of the edge. */
  node?: Maybe<PsaGrapePallet>;
};

/** Methods to use when ordering `PsaGrapePallet`. */
export enum PsaGrapePalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  GradeAsc = 'GRADE_ASC',
  GradeDesc = 'GRADE_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  AutoOpeningAsc = 'AUTO_OPENING_ASC',
  AutoOpeningDesc = 'AUTO_OPENING_DESC',
  BunchesAsc = 'BUNCHES_ASC',
  BunchesDesc = 'BUNCHES_DESC',
  SizeMinAsc = 'SIZE_MIN_ASC',
  SizeMinDesc = 'SIZE_MIN_DESC',
  SizeMaxAsc = 'SIZE_MAX_ASC',
  SizeMaxDesc = 'SIZE_MAX_DESC',
  SizeMostAsc = 'SIZE_MOST_ASC',
  SizeMostDesc = 'SIZE_MOST_DESC',
  UndersizeBunchesCountAsc = 'UNDERSIZE_BUNCHES_COUNT_ASC',
  UndersizeBunchesCountDesc = 'UNDERSIZE_BUNCHES_COUNT_DESC',
  AutoUndersizeBerriesBunchesAsc = 'AUTO_UNDERSIZE_BERRIES_BUNCHES_ASC',
  AutoUndersizeBerriesBunchesDesc = 'AUTO_UNDERSIZE_BERRIES_BUNCHES_DESC',
  UndersizeBerriesPctAsc = 'UNDERSIZE_BERRIES_PCT_ASC',
  UndersizeBerriesPctDesc = 'UNDERSIZE_BERRIES_PCT_DESC',
  ColorMinAsc = 'COLOR_MIN_ASC',
  ColorMinDesc = 'COLOR_MIN_DESC',
  ColorMaxAsc = 'COLOR_MAX_ASC',
  ColorMaxDesc = 'COLOR_MAX_DESC',
  ColorMostAsc = 'COLOR_MOST_ASC',
  ColorMostDesc = 'COLOR_MOST_DESC',
  ColorConsistencyAsc = 'COLOR_CONSISTENCY_ASC',
  ColorConsistencyDesc = 'COLOR_CONSISTENCY_DESC',
  AutoColorConsistencyAsc = 'AUTO_COLOR_CONSISTENCY_ASC',
  AutoColorConsistencyDesc = 'AUTO_COLOR_CONSISTENCY_DESC',
  SunburnBunchesAsc = 'SUNBURN_BUNCHES_ASC',
  SunburnBunchesDesc = 'SUNBURN_BUNCHES_DESC',
  AutoSunburnBunchesAsc = 'AUTO_SUNBURN_BUNCHES_ASC',
  AutoSunburnBunchesDesc = 'AUTO_SUNBURN_BUNCHES_DESC',
  SunburnPctAsc = 'SUNBURN_PCT_ASC',
  SunburnPctDesc = 'SUNBURN_PCT_DESC',
  SunburnBunchesDegAsc = 'SUNBURN_BUNCHES_DEG_ASC',
  SunburnBunchesDegDesc = 'SUNBURN_BUNCHES_DEG_DESC',
  BunchConformationAsc = 'BUNCH_CONFORMATION_ASC',
  BunchConformationDesc = 'BUNCH_CONFORMATION_DESC',
  AutoBunchConformationAsc = 'AUTO_BUNCH_CONFORMATION_ASC',
  AutoBunchConformationDesc = 'AUTO_BUNCH_CONFORMATION_DESC',
  StragglyBunchesAsc = 'STRAGGLY_BUNCHES_ASC',
  StragglyBunchesDesc = 'STRAGGLY_BUNCHES_DESC',
  StragglyPctAsc = 'STRAGGLY_PCT_ASC',
  StragglyPctDesc = 'STRAGGLY_PCT_DESC',
  SmallBunchesAsc = 'SMALL_BUNCHES_ASC',
  SmallBunchesDesc = 'SMALL_BUNCHES_DESC',
  RussetMarksBunchesAsc = 'RUSSET_MARKS_BUNCHES_ASC',
  RussetMarksBunchesDesc = 'RUSSET_MARKS_BUNCHES_DESC',
  RussetMarksPctAsc = 'RUSSET_MARKS_PCT_ASC',
  RussetMarksPctDesc = 'RUSSET_MARKS_PCT_DESC',
  AutoRussetMarksPctAsc = 'AUTO_RUSSET_MARKS_PCT_ASC',
  AutoRussetMarksPctDesc = 'AUTO_RUSSET_MARKS_PCT_DESC',
  DustPctAsc = 'DUST_PCT_ASC',
  DustPctDesc = 'DUST_PCT_DESC',
  AutoDustPctAsc = 'AUTO_DUST_PCT_ASC',
  AutoDustPctDesc = 'AUTO_DUST_PCT_DESC',
  ResiduesPctAsc = 'RESIDUES_PCT_ASC',
  ResiduesPctDesc = 'RESIDUES_PCT_DESC',
  AutoResiduesPctAsc = 'AUTO_RESIDUES_PCT_ASC',
  AutoResiduesPctDesc = 'AUTO_RESIDUES_PCT_DESC',
  TightBunchesAsc = 'TIGHT_BUNCHES_ASC',
  TightBunchesDesc = 'TIGHT_BUNCHES_DESC',
  AutoTightBunchesAsc = 'AUTO_TIGHT_BUNCHES_ASC',
  AutoTightBunchesDesc = 'AUTO_TIGHT_BUNCHES_DESC',
  BruisingBunchesAsc = 'BRUISING_BUNCHES_ASC',
  BruisingBunchesDesc = 'BRUISING_BUNCHES_DESC',
  AutoBruisingBunchesAsc = 'AUTO_BRUISING_BUNCHES_ASC',
  AutoBruisingBunchesDesc = 'AUTO_BRUISING_BUNCHES_DESC',
  BruisingPctAsc = 'BRUISING_PCT_ASC',
  BruisingPctDesc = 'BRUISING_PCT_DESC',
  BruisingDegAsc = 'BRUISING_DEG_ASC',
  BruisingDegDesc = 'BRUISING_DEG_DESC',
  StemDehydrationPctAsc = 'STEM_DEHYDRATION_PCT_ASC',
  StemDehydrationPctDesc = 'STEM_DEHYDRATION_PCT_DESC',
  AutoStemDehydrationPctAsc = 'AUTO_STEM_DEHYDRATION_PCT_ASC',
  AutoStemDehydrationPctDesc = 'AUTO_STEM_DEHYDRATION_PCT_DESC',
  StemDehydrationDegAsc = 'STEM_DEHYDRATION_DEG_ASC',
  StemDehydrationDegDesc = 'STEM_DEHYDRATION_DEG_DESC',
  BerryConditionAsc = 'BERRY_CONDITION_ASC',
  BerryConditionDesc = 'BERRY_CONDITION_DESC',
  AutoBerryConditionAsc = 'AUTO_BERRY_CONDITION_ASC',
  AutoBerryConditionDesc = 'AUTO_BERRY_CONDITION_DESC',
  H2OBerriesAsc = 'H2O_BERRIES_ASC',
  H2OBerriesDesc = 'H2O_BERRIES_DESC',
  AutoH2OBerriesAsc = 'AUTO_H2O_BERRIES_ASC',
  AutoH2OBerriesDesc = 'AUTO_H2O_BERRIES_DESC',
  So2DamagePctAsc = 'SO2_DAMAGE_PCT_ASC',
  So2DamagePctDesc = 'SO2_DAMAGE_PCT_DESC',
  AutoSo2DamagePctAsc = 'AUTO_SO2_DAMAGE_PCT_ASC',
  AutoSo2DamagePctDesc = 'AUTO_SO2_DAMAGE_PCT_DESC',
  So2DamageDegAsc = 'SO2_DAMAGE_DEG_ASC',
  So2DamageDegDesc = 'SO2_DAMAGE_DEG_DESC',
  WeakBunchesAsc = 'WEAK_BUNCHES_ASC',
  WeakBunchesDesc = 'WEAK_BUNCHES_DESC',
  AutoWeakBunchesAsc = 'AUTO_WEAK_BUNCHES_ASC',
  AutoWeakBunchesDesc = 'AUTO_WEAK_BUNCHES_DESC',
  SplitsHairlinePctAsc = 'SPLITS_HAIRLINE_PCT_ASC',
  SplitsHairlinePctDesc = 'SPLITS_HAIRLINE_PCT_DESC',
  AutoSplitsHairlinePctAsc = 'AUTO_SPLITS_HAIRLINE_PCT_ASC',
  AutoSplitsHairlinePctDesc = 'AUTO_SPLITS_HAIRLINE_PCT_DESC',
  SplitsWetCrushPctAsc = 'SPLITS_WET_CRUSH_PCT_ASC',
  SplitsWetCrushPctDesc = 'SPLITS_WET_CRUSH_PCT_DESC',
  AutoSplitsWetCrushPctAsc = 'AUTO_SPLITS_WET_CRUSH_PCT_ASC',
  AutoSplitsWetCrushPctDesc = 'AUTO_SPLITS_WET_CRUSH_PCT_DESC',
  SplitsDryPctAsc = 'SPLITS_DRY_PCT_ASC',
  SplitsDryPctDesc = 'SPLITS_DRY_PCT_DESC',
  AutoSplitsDryPctAsc = 'AUTO_SPLITS_DRY_PCT_ASC',
  AutoSplitsDryPctDesc = 'AUTO_SPLITS_DRY_PCT_DESC',
  IntDiscAsc = 'INT_DISC_ASC',
  IntDiscDesc = 'INT_DISC_DESC',
  AutoIntDiscAsc = 'AUTO_INT_DISC_ASC',
  AutoIntDiscDesc = 'AUTO_INT_DISC_DESC',
  IntDiscDegAsc = 'INT_DISC_DEG_ASC',
  IntDiscDegDesc = 'INT_DISC_DEG_DESC',
  DecayMoldBerriesAsc = 'DECAY_MOLD_BERRIES_ASC',
  DecayMoldBerriesDesc = 'DECAY_MOLD_BERRIES_DESC',
  AutoDecayMoldBerriesAsc = 'AUTO_DECAY_MOLD_BERRIES_ASC',
  AutoDecayMoldBerriesDesc = 'AUTO_DECAY_MOLD_BERRIES_DESC',
  DecaySlipskinBerriesAsc = 'DECAY_SLIPSKIN_BERRIES_ASC',
  DecaySlipskinBerriesDesc = 'DECAY_SLIPSKIN_BERRIES_DESC',
  AutoDecaySlipskinBerriesAsc = 'AUTO_DECAY_SLIPSKIN_BERRIES_ASC',
  AutoDecaySlipskinBerriesDesc = 'AUTO_DECAY_SLIPSKIN_BERRIES_DESC',
  DecayNestBerriesAsc = 'DECAY_NEST_BERRIES_ASC',
  DecayNestBerriesDesc = 'DECAY_NEST_BERRIES_DESC',
  AutoDecayNestBerriesAsc = 'AUTO_DECAY_NEST_BERRIES_ASC',
  AutoDecayNestBerriesDesc = 'AUTO_DECAY_NEST_BERRIES_DESC',
  DecayNestDegAsc = 'DECAY_NEST_DEG_ASC',
  DecayNestDegDesc = 'DECAY_NEST_DEG_DESC',
  ShatterPctAsc = 'SHATTER_PCT_ASC',
  ShatterPctDesc = 'SHATTER_PCT_DESC',
  AutoShatterPctAsc = 'AUTO_SHATTER_PCT_ASC',
  AutoShatterPctDesc = 'AUTO_SHATTER_PCT_DESC',
  BrixMinAsc = 'BRIX_MIN_ASC',
  BrixMinDesc = 'BRIX_MIN_DESC',
  BrixMaxAsc = 'BRIX_MAX_ASC',
  BrixMaxDesc = 'BRIX_MAX_DESC',
  BrixMostAsc = 'BRIX_MOST_ASC',
  BrixMostDesc = 'BRIX_MOST_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  AutoOverallQualityAsc = 'AUTO_OVERALL_QUALITY_ASC',
  AutoOverallQualityDesc = 'AUTO_OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  AutoOverallConditionAsc = 'AUTO_OVERALL_CONDITION_ASC',
  AutoOverallConditionDesc = 'AUTO_OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `PsaGrapePallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaGrapePalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<DateFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `grade` field. */
  grade?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `autoOpening` field. */
  autoOpening?: Maybe<StringFilter>;
  /** Filter by the object’s `bunches` field. */
  bunches?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeMin` field. */
  sizeMin?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeMax` field. */
  sizeMax?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeMost` field. */
  sizeMost?: Maybe<StringFilter>;
  /** Filter by the object’s `undersizeBunchesCount` field. */
  undersizeBunchesCount?: Maybe<StringFilter>;
  /** Filter by the object’s `autoUndersizeBerriesBunches` field. */
  autoUndersizeBerriesBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `undersizeBerriesPct` field. */
  undersizeBerriesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `colorMin` field. */
  colorMin?: Maybe<StringFilter>;
  /** Filter by the object’s `colorMax` field. */
  colorMax?: Maybe<StringFilter>;
  /** Filter by the object’s `colorMost` field. */
  colorMost?: Maybe<StringFilter>;
  /** Filter by the object’s `colorConsistency` field. */
  colorConsistency?: Maybe<StringFilter>;
  /** Filter by the object’s `autoColorConsistency` field. */
  autoColorConsistency?: Maybe<StringFilter>;
  /** Filter by the object’s `sunburnBunches` field. */
  sunburnBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `autoSunburnBunches` field. */
  autoSunburnBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `sunburnPct` field. */
  sunburnPct?: Maybe<StringFilter>;
  /** Filter by the object’s `sunburnBunchesDeg` field. */
  sunburnBunchesDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `bunchConformation` field. */
  bunchConformation?: Maybe<StringFilter>;
  /** Filter by the object’s `autoBunchConformation` field. */
  autoBunchConformation?: Maybe<StringFilter>;
  /** Filter by the object’s `stragglyBunches` field. */
  stragglyBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `stragglyPct` field. */
  stragglyPct?: Maybe<StringFilter>;
  /** Filter by the object’s `smallBunches` field. */
  smallBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `russetMarksBunches` field. */
  russetMarksBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `russetMarksPct` field. */
  russetMarksPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoRussetMarksPct` field. */
  autoRussetMarksPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dustPct` field. */
  dustPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoDustPct` field. */
  autoDustPct?: Maybe<StringFilter>;
  /** Filter by the object’s `residuesPct` field. */
  residuesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoResiduesPct` field. */
  autoResiduesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `tightBunches` field. */
  tightBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `autoTightBunches` field. */
  autoTightBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingBunches` field. */
  bruisingBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `autoBruisingBunches` field. */
  autoBruisingBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `stemDehydrationPct` field. */
  stemDehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoStemDehydrationPct` field. */
  autoStemDehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `stemDehydrationDeg` field. */
  stemDehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `berryCondition` field. */
  berryCondition?: Maybe<StringFilter>;
  /** Filter by the object’s `autoBerryCondition` field. */
  autoBerryCondition?: Maybe<StringFilter>;
  /** Filter by the object’s `h2OBerries` field. */
  h2OBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `autoH2OBerries` field. */
  autoH2OBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `so2DamagePct` field. */
  so2DamagePct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoSo2DamagePct` field. */
  autoSo2DamagePct?: Maybe<StringFilter>;
  /** Filter by the object’s `so2DamageDeg` field. */
  so2DamageDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `weakBunches` field. */
  weakBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `autoWeakBunches` field. */
  autoWeakBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `splitsHairlinePct` field. */
  splitsHairlinePct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoSplitsHairlinePct` field. */
  autoSplitsHairlinePct?: Maybe<StringFilter>;
  /** Filter by the object’s `splitsWetCrushPct` field. */
  splitsWetCrushPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoSplitsWetCrushPct` field. */
  autoSplitsWetCrushPct?: Maybe<StringFilter>;
  /** Filter by the object’s `splitsDryPct` field. */
  splitsDryPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoSplitsDryPct` field. */
  autoSplitsDryPct?: Maybe<StringFilter>;
  /** Filter by the object’s `intDisc` field. */
  intDisc?: Maybe<StringFilter>;
  /** Filter by the object’s `autoIntDisc` field. */
  autoIntDisc?: Maybe<StringFilter>;
  /** Filter by the object’s `intDiscDeg` field. */
  intDiscDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `decayMoldBerries` field. */
  decayMoldBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `autoDecayMoldBerries` field. */
  autoDecayMoldBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `decaySlipskinBerries` field. */
  decaySlipskinBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `autoDecaySlipskinBerries` field. */
  autoDecaySlipskinBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `decayNestBerries` field. */
  decayNestBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `autoDecayNestBerries` field. */
  autoDecayNestBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `decayNestDeg` field. */
  decayNestDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `shatterPct` field. */
  shatterPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoShatterPct` field. */
  autoShatterPct?: Maybe<StringFilter>;
  /** Filter by the object’s `brixMin` field. */
  brixMin?: Maybe<StringFilter>;
  /** Filter by the object’s `brixMax` field. */
  brixMax?: Maybe<StringFilter>;
  /** Filter by the object’s `brixMost` field. */
  brixMost?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `autoOverallQuality` field. */
  autoOverallQuality?: Maybe<StringFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `autoOverallCondition` field. */
  autoOverallCondition?: Maybe<StringFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaGrapePalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaGrapePalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaGrapePalletFilter>;
};

/** A connection to a list of `PsaLemonPallet` values. */
export type PsaLemonPalletsConnection = {
  __typename?: 'PsaLemonPalletsConnection';
  /** A list of `PsaLemonPallet` objects. */
  nodes: Array<Maybe<PsaLemonPallet>>;
  /** A list of edges which contains the `PsaLemonPallet` and cursor to aid in pagination. */
  edges: Array<PsaLemonPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaLemonPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PsaLemonPallet = Node & {
  __typename?: 'PsaLemonPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  diameterMinMm?: Maybe<Scalars['String']>;
  diameterMinInches?: Maybe<Scalars['String']>;
  diameterMaxMm?: Maybe<Scalars['String']>;
  diameterMaxInches?: Maybe<Scalars['String']>;
  diameterMostMm?: Maybe<Scalars['String']>;
  diameterMostInches?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  greenHazePieces?: Maybe<Scalars['String']>;
  greenHazePct?: Maybe<Scalars['String']>;
  greenHazeDeg?: Maybe<Scalars['String']>;
  oilSpotsPieces?: Maybe<Scalars['String']>;
  oilSpotsPct?: Maybe<Scalars['String']>;
  oilSpotsDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  dryPulpPieces?: Maybe<Scalars['String']>;
  dryPulpPct?: Maybe<Scalars['String']>;
  dryPulpDeg?: Maybe<Scalars['String']>;
  skinDamagePieces?: Maybe<Scalars['String']>;
  skinDamagePct?: Maybe<Scalars['String']>;
  skinDamageDeg?: Maybe<Scalars['String']>;
  petecaPieces?: Maybe<Scalars['String']>;
  petecaPct?: Maybe<Scalars['String']>;
  petecaDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  sporesPieces?: Maybe<Scalars['String']>;
  sporesPct?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaLemonPalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/** A `PsaLemonPallet` edge in the connection. */
export type PsaLemonPalletsEdge = {
  __typename?: 'PsaLemonPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaLemonPallet` at the end of the edge. */
  node?: Maybe<PsaLemonPallet>;
};

/** Methods to use when ordering `PsaLemonPallet`. */
export enum PsaLemonPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  GradeAsc = 'GRADE_ASC',
  GradeDesc = 'GRADE_DESC',
  InspGradeAsc = 'INSP_GRADE_ASC',
  InspGradeDesc = 'INSP_GRADE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  ColorAsc = 'COLOR_ASC',
  ColorDesc = 'COLOR_DESC',
  DiameterMinMmAsc = 'DIAMETER_MIN_MM_ASC',
  DiameterMinMmDesc = 'DIAMETER_MIN_MM_DESC',
  DiameterMinInchesAsc = 'DIAMETER_MIN_INCHES_ASC',
  DiameterMinInchesDesc = 'DIAMETER_MIN_INCHES_DESC',
  DiameterMaxMmAsc = 'DIAMETER_MAX_MM_ASC',
  DiameterMaxMmDesc = 'DIAMETER_MAX_MM_DESC',
  DiameterMaxInchesAsc = 'DIAMETER_MAX_INCHES_ASC',
  DiameterMaxInchesDesc = 'DIAMETER_MAX_INCHES_DESC',
  DiameterMostMmAsc = 'DIAMETER_MOST_MM_ASC',
  DiameterMostMmDesc = 'DIAMETER_MOST_MM_DESC',
  DiameterMostInchesAsc = 'DIAMETER_MOST_INCHES_ASC',
  DiameterMostInchesDesc = 'DIAMETER_MOST_INCHES_DESC',
  ScarsPiecesAsc = 'SCARS_PIECES_ASC',
  ScarsPiecesDesc = 'SCARS_PIECES_DESC',
  ScarsPctAsc = 'SCARS_PCT_ASC',
  ScarsPctDesc = 'SCARS_PCT_DESC',
  ScarsDegAsc = 'SCARS_DEG_ASC',
  ScarsDegDesc = 'SCARS_DEG_DESC',
  GreenHazePiecesAsc = 'GREEN_HAZE_PIECES_ASC',
  GreenHazePiecesDesc = 'GREEN_HAZE_PIECES_DESC',
  GreenHazePctAsc = 'GREEN_HAZE_PCT_ASC',
  GreenHazePctDesc = 'GREEN_HAZE_PCT_DESC',
  GreenHazeDegAsc = 'GREEN_HAZE_DEG_ASC',
  GreenHazeDegDesc = 'GREEN_HAZE_DEG_DESC',
  OilSpotsPiecesAsc = 'OIL_SPOTS_PIECES_ASC',
  OilSpotsPiecesDesc = 'OIL_SPOTS_PIECES_DESC',
  OilSpotsPctAsc = 'OIL_SPOTS_PCT_ASC',
  OilSpotsPctDesc = 'OIL_SPOTS_PCT_DESC',
  OilSpotsDegAsc = 'OIL_SPOTS_DEG_ASC',
  OilSpotsDegDesc = 'OIL_SPOTS_DEG_DESC',
  CutCountAsc = 'CUT_COUNT_ASC',
  CutCountDesc = 'CUT_COUNT_DESC',
  DryPulpPiecesAsc = 'DRY_PULP_PIECES_ASC',
  DryPulpPiecesDesc = 'DRY_PULP_PIECES_DESC',
  DryPulpPctAsc = 'DRY_PULP_PCT_ASC',
  DryPulpPctDesc = 'DRY_PULP_PCT_DESC',
  DryPulpDegAsc = 'DRY_PULP_DEG_ASC',
  DryPulpDegDesc = 'DRY_PULP_DEG_DESC',
  SkinDamagePiecesAsc = 'SKIN_DAMAGE_PIECES_ASC',
  SkinDamagePiecesDesc = 'SKIN_DAMAGE_PIECES_DESC',
  SkinDamagePctAsc = 'SKIN_DAMAGE_PCT_ASC',
  SkinDamagePctDesc = 'SKIN_DAMAGE_PCT_DESC',
  SkinDamageDegAsc = 'SKIN_DAMAGE_DEG_ASC',
  SkinDamageDegDesc = 'SKIN_DAMAGE_DEG_DESC',
  PetecaPiecesAsc = 'PETECA_PIECES_ASC',
  PetecaPiecesDesc = 'PETECA_PIECES_DESC',
  PetecaPctAsc = 'PETECA_PCT_ASC',
  PetecaPctDesc = 'PETECA_PCT_DESC',
  PetecaDegAsc = 'PETECA_DEG_ASC',
  PetecaDegDesc = 'PETECA_DEG_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  SporesPiecesAsc = 'SPORES_PIECES_ASC',
  SporesPiecesDesc = 'SPORES_PIECES_DESC',
  SporesPctAsc = 'SPORES_PCT_ASC',
  SporesPctDesc = 'SPORES_PCT_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `PsaLemonPallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaLemonPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `grade` field. */
  grade?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrade` field. */
  inspGrade?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `color` field. */
  color?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMinMm` field. */
  diameterMinMm?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMinInches` field. */
  diameterMinInches?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMaxMm` field. */
  diameterMaxMm?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMaxInches` field. */
  diameterMaxInches?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMostMm` field. */
  diameterMostMm?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMostInches` field. */
  diameterMostInches?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPct` field. */
  scarsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `greenHazePieces` field. */
  greenHazePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `greenHazePct` field. */
  greenHazePct?: Maybe<StringFilter>;
  /** Filter by the object’s `greenHazeDeg` field. */
  greenHazeDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `oilSpotsPieces` field. */
  oilSpotsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `oilSpotsPct` field. */
  oilSpotsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `oilSpotsDeg` field. */
  oilSpotsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutCount` field. */
  cutCount?: Maybe<StringFilter>;
  /** Filter by the object’s `dryPulpPieces` field. */
  dryPulpPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dryPulpPct` field. */
  dryPulpPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dryPulpDeg` field. */
  dryPulpDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `skinDamagePieces` field. */
  skinDamagePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `skinDamagePct` field. */
  skinDamagePct?: Maybe<StringFilter>;
  /** Filter by the object’s `skinDamageDeg` field. */
  skinDamageDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `petecaPieces` field. */
  petecaPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `petecaPct` field. */
  petecaPct?: Maybe<StringFilter>;
  /** Filter by the object’s `petecaDeg` field. */
  petecaDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `sporesPieces` field. */
  sporesPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `sporesPct` field. */
  sporesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaLemonPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaLemonPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaLemonPalletFilter>;
};

/** A connection to a list of `PsaPearPallet` values. */
export type PsaPearPalletsConnection = {
  __typename?: 'PsaPearPalletsConnection';
  /** A list of `PsaPearPallet` objects. */
  nodes: Array<Maybe<PsaPearPallet>>;
  /** A list of edges which contains the `PsaPearPallet` and cursor to aid in pagination. */
  edges: Array<PsaPearPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaPearPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PsaPearPallet = Node & {
  __typename?: 'PsaPearPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsRussetPieces?: Maybe<Scalars['String']>;
  scarsRussetPct?: Maybe<Scalars['String']>;
  scarsRussetDeg?: Maybe<Scalars['String']>;
  russetPerPiecePct?: Maybe<Scalars['String']>;
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  stemPuncturesPct?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  turningColorPieces?: Maybe<Scalars['String']>;
  turningColorPct?: Maybe<Scalars['String']>;
  turningColorDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaPearPalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/** A `PsaPearPallet` edge in the connection. */
export type PsaPearPalletsEdge = {
  __typename?: 'PsaPearPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaPearPallet` at the end of the edge. */
  node?: Maybe<PsaPearPallet>;
};

/** Methods to use when ordering `PsaPearPallet`. */
export enum PsaPearPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  RunNumberAsc = 'RUN_NUMBER_ASC',
  RunNumberDesc = 'RUN_NUMBER_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  GradeAsc = 'GRADE_ASC',
  GradeDesc = 'GRADE_DESC',
  InspGradeAsc = 'INSP_GRADE_ASC',
  InspGradeDesc = 'INSP_GRADE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  GroundColorAsc = 'GROUND_COLOR_ASC',
  GroundColorDesc = 'GROUND_COLOR_DESC',
  BlushColorAsc = 'BLUSH_COLOR_ASC',
  BlushColorDesc = 'BLUSH_COLOR_DESC',
  BlushPctAsc = 'BLUSH_PCT_ASC',
  BlushPctDesc = 'BLUSH_PCT_DESC',
  ScarsRussetPiecesAsc = 'SCARS_RUSSET_PIECES_ASC',
  ScarsRussetPiecesDesc = 'SCARS_RUSSET_PIECES_DESC',
  ScarsRussetPctAsc = 'SCARS_RUSSET_PCT_ASC',
  ScarsRussetPctDesc = 'SCARS_RUSSET_PCT_DESC',
  ScarsRussetDegAsc = 'SCARS_RUSSET_DEG_ASC',
  ScarsRussetDegDesc = 'SCARS_RUSSET_DEG_DESC',
  RussetPerPiecePctAsc = 'RUSSET_PER_PIECE_PCT_ASC',
  RussetPerPiecePctDesc = 'RUSSET_PER_PIECE_PCT_DESC',
  StemPuncturesPiecesAsc = 'STEM_PUNCTURES_PIECES_ASC',
  StemPuncturesPiecesDesc = 'STEM_PUNCTURES_PIECES_DESC',
  StemPuncturesPctAsc = 'STEM_PUNCTURES_PCT_ASC',
  StemPuncturesPctDesc = 'STEM_PUNCTURES_PCT_DESC',
  CutsPiecesAsc = 'CUTS_PIECES_ASC',
  CutsPiecesDesc = 'CUTS_PIECES_DESC',
  CutsPctAsc = 'CUTS_PCT_ASC',
  CutsPctDesc = 'CUTS_PCT_DESC',
  CutsDegAsc = 'CUTS_DEG_ASC',
  CutsDegDesc = 'CUTS_DEG_DESC',
  TurningColorPiecesAsc = 'TURNING_COLOR_PIECES_ASC',
  TurningColorPiecesDesc = 'TURNING_COLOR_PIECES_DESC',
  TurningColorPctAsc = 'TURNING_COLOR_PCT_ASC',
  TurningColorPctDesc = 'TURNING_COLOR_PCT_DESC',
  TurningColorDegAsc = 'TURNING_COLOR_DEG_ASC',
  TurningColorDegDesc = 'TURNING_COLOR_DEG_DESC',
  DehydrationPiecesAsc = 'DEHYDRATION_PIECES_ASC',
  DehydrationPiecesDesc = 'DEHYDRATION_PIECES_DESC',
  DehydrationPctAsc = 'DEHYDRATION_PCT_ASC',
  DehydrationPctDesc = 'DEHYDRATION_PCT_DESC',
  DehydrationDegAsc = 'DEHYDRATION_DEG_ASC',
  DehydrationDegDesc = 'DEHYDRATION_DEG_DESC',
  BruisingPiecesAsc = 'BRUISING_PIECES_ASC',
  BruisingPiecesDesc = 'BRUISING_PIECES_DESC',
  BruisingPctAsc = 'BRUISING_PCT_ASC',
  BruisingPctDesc = 'BRUISING_PCT_DESC',
  BruisingDegAsc = 'BRUISING_DEG_ASC',
  BruisingDegDesc = 'BRUISING_DEG_DESC',
  CutCountAsc = 'CUT_COUNT_ASC',
  CutCountDesc = 'CUT_COUNT_DESC',
  InternalDamagePiecesAsc = 'INTERNAL_DAMAGE_PIECES_ASC',
  InternalDamagePiecesDesc = 'INTERNAL_DAMAGE_PIECES_DESC',
  InternalDamagePerAsc = 'INTERNAL_DAMAGE_PER_ASC',
  InternalDamagePerDesc = 'INTERNAL_DAMAGE_PER_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  Pressure1Asc = 'PRESSURE1_ASC',
  Pressure1Desc = 'PRESSURE1_DESC',
  Pressure2Asc = 'PRESSURE2_ASC',
  Pressure2Desc = 'PRESSURE2_DESC',
  Pressure3Asc = 'PRESSURE3_ASC',
  Pressure3Desc = 'PRESSURE3_DESC',
  Pressure4Asc = 'PRESSURE4_ASC',
  Pressure4Desc = 'PRESSURE4_DESC',
  Pressure5Asc = 'PRESSURE5_ASC',
  Pressure5Desc = 'PRESSURE5_DESC',
  Pressure6Asc = 'PRESSURE6_ASC',
  Pressure6Desc = 'PRESSURE6_DESC',
  PressuresMinAsc = 'PRESSURES_MIN_ASC',
  PressuresMinDesc = 'PRESSURES_MIN_DESC',
  PressuresMaxAsc = 'PRESSURES_MAX_ASC',
  PressuresMaxDesc = 'PRESSURES_MAX_DESC',
  PressuresAvgAsc = 'PRESSURES_AVG_ASC',
  PressuresAvgDesc = 'PRESSURES_AVG_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `PsaPearPallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaPearPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `runNumber` field. */
  runNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `grade` field. */
  grade?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrade` field. */
  inspGrade?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `groundColor` field. */
  groundColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushColor` field. */
  blushColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushPct` field. */
  blushPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsRussetPieces` field. */
  scarsRussetPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsRussetPct` field. */
  scarsRussetPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsRussetDeg` field. */
  scarsRussetDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `russetPerPiecePct` field. */
  russetPerPiecePct?: Maybe<StringFilter>;
  /** Filter by the object’s `stemPuncturesPieces` field. */
  stemPuncturesPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `stemPuncturesPct` field. */
  stemPuncturesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsPieces` field. */
  cutsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsPct` field. */
  cutsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsDeg` field. */
  cutsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `turningColorPieces` field. */
  turningColorPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `turningColorPct` field. */
  turningColorPct?: Maybe<StringFilter>;
  /** Filter by the object’s `turningColorDeg` field. */
  turningColorDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutCount` field. */
  cutCount?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure1` field. */
  pressure1?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure2` field. */
  pressure2?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure3` field. */
  pressure3?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure4` field. */
  pressure4?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure5` field. */
  pressure5?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure6` field. */
  pressure6?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaPearPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaPearPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaPearPalletFilter>;
};

/** A connection to a list of `PsaPersimmonPallet` values. */
export type PsaPersimmonPalletsConnection = {
  __typename?: 'PsaPersimmonPalletsConnection';
  /** A list of `PsaPersimmonPallet` objects. */
  nodes: Array<Maybe<PsaPersimmonPallet>>;
  /** A list of edges which contains the `PsaPersimmonPallet` and cursor to aid in pagination. */
  edges: Array<PsaPersimmonPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaPersimmonPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PsaPersimmonPallet = Node & {
  __typename?: 'PsaPersimmonPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  scarsMarksPieces?: Maybe<Scalars['String']>;
  scarsMarksPct?: Maybe<Scalars['String']>;
  scarsMarksDeg?: Maybe<Scalars['String']>;
  greenColorPieces?: Maybe<Scalars['String']>;
  greenColor?: Maybe<Scalars['String']>;
  greenColorDeg?: Maybe<Scalars['String']>;
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  cutsSplitsPct?: Maybe<Scalars['String']>;
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  seedsPieces?: Maybe<Scalars['String']>;
  seedsPct?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  internalDamageDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaPersimmonPalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/** A `PsaPersimmonPallet` edge in the connection. */
export type PsaPersimmonPalletsEdge = {
  __typename?: 'PsaPersimmonPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaPersimmonPallet` at the end of the edge. */
  node?: Maybe<PsaPersimmonPallet>;
};

/** Methods to use when ordering `PsaPersimmonPallet`. */
export enum PsaPersimmonPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  ColorAsc = 'COLOR_ASC',
  ColorDesc = 'COLOR_DESC',
  ScarsMarksPiecesAsc = 'SCARS_MARKS_PIECES_ASC',
  ScarsMarksPiecesDesc = 'SCARS_MARKS_PIECES_DESC',
  ScarsMarksPctAsc = 'SCARS_MARKS_PCT_ASC',
  ScarsMarksPctDesc = 'SCARS_MARKS_PCT_DESC',
  ScarsMarksDegAsc = 'SCARS_MARKS_DEG_ASC',
  ScarsMarksDegDesc = 'SCARS_MARKS_DEG_DESC',
  GreenColorPiecesAsc = 'GREEN_COLOR_PIECES_ASC',
  GreenColorPiecesDesc = 'GREEN_COLOR_PIECES_DESC',
  GreenColorAsc = 'GREEN_COLOR_ASC',
  GreenColorDesc = 'GREEN_COLOR_DESC',
  GreenColorDegAsc = 'GREEN_COLOR_DEG_ASC',
  GreenColorDegDesc = 'GREEN_COLOR_DEG_DESC',
  CutsSplitsPiecesAsc = 'CUTS_SPLITS_PIECES_ASC',
  CutsSplitsPiecesDesc = 'CUTS_SPLITS_PIECES_DESC',
  CutsSplitsPctAsc = 'CUTS_SPLITS_PCT_ASC',
  CutsSplitsPctDesc = 'CUTS_SPLITS_PCT_DESC',
  CutsSplitsDegAsc = 'CUTS_SPLITS_DEG_ASC',
  CutsSplitsDegDesc = 'CUTS_SPLITS_DEG_DESC',
  BruisingPiecesAsc = 'BRUISING_PIECES_ASC',
  BruisingPiecesDesc = 'BRUISING_PIECES_DESC',
  BruisingPctAsc = 'BRUISING_PCT_ASC',
  BruisingPctDesc = 'BRUISING_PCT_DESC',
  BruisingDegAsc = 'BRUISING_DEG_ASC',
  BruisingDegDesc = 'BRUISING_DEG_DESC',
  DehydrationPiecesAsc = 'DEHYDRATION_PIECES_ASC',
  DehydrationPiecesDesc = 'DEHYDRATION_PIECES_DESC',
  DehydrationPctAsc = 'DEHYDRATION_PCT_ASC',
  DehydrationPctDesc = 'DEHYDRATION_PCT_DESC',
  DehydrationDegAsc = 'DEHYDRATION_DEG_ASC',
  DehydrationDegDesc = 'DEHYDRATION_DEG_DESC',
  CutCountAsc = 'CUT_COUNT_ASC',
  CutCountDesc = 'CUT_COUNT_DESC',
  SeedsPiecesAsc = 'SEEDS_PIECES_ASC',
  SeedsPiecesDesc = 'SEEDS_PIECES_DESC',
  SeedsPctAsc = 'SEEDS_PCT_ASC',
  SeedsPctDesc = 'SEEDS_PCT_DESC',
  InternalDamagePiecesAsc = 'INTERNAL_DAMAGE_PIECES_ASC',
  InternalDamagePiecesDesc = 'INTERNAL_DAMAGE_PIECES_DESC',
  InternalDamagePerAsc = 'INTERNAL_DAMAGE_PER_ASC',
  InternalDamagePerDesc = 'INTERNAL_DAMAGE_PER_DESC',
  InternalDamageDegAsc = 'INTERNAL_DAMAGE_DEG_ASC',
  InternalDamageDegDesc = 'INTERNAL_DAMAGE_DEG_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  BrixAsc = 'BRIX_ASC',
  BrixDesc = 'BRIX_DESC',
  Pressure1Asc = 'PRESSURE1_ASC',
  Pressure1Desc = 'PRESSURE1_DESC',
  Pressure2Asc = 'PRESSURE2_ASC',
  Pressure2Desc = 'PRESSURE2_DESC',
  Pressure3Asc = 'PRESSURE3_ASC',
  Pressure3Desc = 'PRESSURE3_DESC',
  Pressure4Asc = 'PRESSURE4_ASC',
  Pressure4Desc = 'PRESSURE4_DESC',
  Pressure5Asc = 'PRESSURE5_ASC',
  Pressure5Desc = 'PRESSURE5_DESC',
  Pressure6Asc = 'PRESSURE6_ASC',
  Pressure6Desc = 'PRESSURE6_DESC',
  PressuresMinAsc = 'PRESSURES_MIN_ASC',
  PressuresMinDesc = 'PRESSURES_MIN_DESC',
  PressuresMaxAsc = 'PRESSURES_MAX_ASC',
  PressuresMaxDesc = 'PRESSURES_MAX_DESC',
  PressuresAvgAsc = 'PRESSURES_AVG_ASC',
  PressuresAvgDesc = 'PRESSURES_AVG_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `PsaPersimmonPallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaPersimmonPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `color` field. */
  color?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsMarksPieces` field. */
  scarsMarksPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsMarksPct` field. */
  scarsMarksPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsMarksDeg` field. */
  scarsMarksDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `greenColorPieces` field. */
  greenColorPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `greenColor` field. */
  greenColor?: Maybe<StringFilter>;
  /** Filter by the object’s `greenColorDeg` field. */
  greenColorDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsSplitsPieces` field. */
  cutsSplitsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsSplitsPct` field. */
  cutsSplitsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsSplitsDeg` field. */
  cutsSplitsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutCount` field. */
  cutCount?: Maybe<StringFilter>;
  /** Filter by the object’s `seedsPieces` field. */
  seedsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `seedsPct` field. */
  seedsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamageDeg` field. */
  internalDamageDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `brix` field. */
  brix?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure1` field. */
  pressure1?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure2` field. */
  pressure2?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure3` field. */
  pressure3?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure4` field. */
  pressure4?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure5` field. */
  pressure5?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure6` field. */
  pressure6?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaPersimmonPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaPersimmonPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaPersimmonPalletFilter>;
};

/** A connection to a list of `PsaPomegranatePallet` values. */
export type PsaPomegranatePalletsConnection = {
  __typename?: 'PsaPomegranatePalletsConnection';
  /** A list of `PsaPomegranatePallet` objects. */
  nodes: Array<Maybe<PsaPomegranatePallet>>;
  /** A list of edges which contains the `PsaPomegranatePallet` and cursor to aid in pagination. */
  edges: Array<PsaPomegranatePalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaPomegranatePallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PsaPomegranatePallet = Node & {
  __typename?: 'PsaPomegranatePallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  arilsColor?: Maybe<Scalars['String']>;
  scarsRussetPieces?: Maybe<Scalars['String']>;
  scarsRussetPct?: Maybe<Scalars['String']>;
  scarsRussetDeg?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  sunScaldPieces?: Maybe<Scalars['String']>;
  sunScaldPct?: Maybe<Scalars['String']>;
  sunScaldDeg?: Maybe<Scalars['String']>;
  scaldPieces?: Maybe<Scalars['String']>;
  scaldPct?: Maybe<Scalars['String']>;
  scaldDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brixMin?: Maybe<Scalars['String']>;
  brixMax?: Maybe<Scalars['String']>;
  brixMost?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaPomegranatePalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/** A `PsaPomegranatePallet` edge in the connection. */
export type PsaPomegranatePalletsEdge = {
  __typename?: 'PsaPomegranatePalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaPomegranatePallet` at the end of the edge. */
  node?: Maybe<PsaPomegranatePallet>;
};

/** Methods to use when ordering `PsaPomegranatePallet`. */
export enum PsaPomegranatePalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  GradeAsc = 'GRADE_ASC',
  GradeDesc = 'GRADE_DESC',
  InspGradeAsc = 'INSP_GRADE_ASC',
  InspGradeDesc = 'INSP_GRADE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  BlushColorAsc = 'BLUSH_COLOR_ASC',
  BlushColorDesc = 'BLUSH_COLOR_DESC',
  BlushPctAsc = 'BLUSH_PCT_ASC',
  BlushPctDesc = 'BLUSH_PCT_DESC',
  ArilsColorAsc = 'ARILS_COLOR_ASC',
  ArilsColorDesc = 'ARILS_COLOR_DESC',
  ScarsRussetPiecesAsc = 'SCARS_RUSSET_PIECES_ASC',
  ScarsRussetPiecesDesc = 'SCARS_RUSSET_PIECES_DESC',
  ScarsRussetPctAsc = 'SCARS_RUSSET_PCT_ASC',
  ScarsRussetPctDesc = 'SCARS_RUSSET_PCT_DESC',
  ScarsRussetDegAsc = 'SCARS_RUSSET_DEG_ASC',
  ScarsRussetDegDesc = 'SCARS_RUSSET_DEG_DESC',
  CutsPiecesAsc = 'CUTS_PIECES_ASC',
  CutsPiecesDesc = 'CUTS_PIECES_DESC',
  CutsPctAsc = 'CUTS_PCT_ASC',
  CutsPctDesc = 'CUTS_PCT_DESC',
  CutsDegAsc = 'CUTS_DEG_ASC',
  CutsDegDesc = 'CUTS_DEG_DESC',
  SunScaldPiecesAsc = 'SUN_SCALD_PIECES_ASC',
  SunScaldPiecesDesc = 'SUN_SCALD_PIECES_DESC',
  SunScaldPctAsc = 'SUN_SCALD_PCT_ASC',
  SunScaldPctDesc = 'SUN_SCALD_PCT_DESC',
  SunScaldDegAsc = 'SUN_SCALD_DEG_ASC',
  SunScaldDegDesc = 'SUN_SCALD_DEG_DESC',
  ScaldPiecesAsc = 'SCALD_PIECES_ASC',
  ScaldPiecesDesc = 'SCALD_PIECES_DESC',
  ScaldPctAsc = 'SCALD_PCT_ASC',
  ScaldPctDesc = 'SCALD_PCT_DESC',
  ScaldDegAsc = 'SCALD_DEG_ASC',
  ScaldDegDesc = 'SCALD_DEG_DESC',
  BruisingPiecesAsc = 'BRUISING_PIECES_ASC',
  BruisingPiecesDesc = 'BRUISING_PIECES_DESC',
  BruisingPctAsc = 'BRUISING_PCT_ASC',
  BruisingPctDesc = 'BRUISING_PCT_DESC',
  BruisingDegAsc = 'BRUISING_DEG_ASC',
  BruisingDegDesc = 'BRUISING_DEG_DESC',
  DehydrationPiecesAsc = 'DEHYDRATION_PIECES_ASC',
  DehydrationPiecesDesc = 'DEHYDRATION_PIECES_DESC',
  DehydrationPctAsc = 'DEHYDRATION_PCT_ASC',
  DehydrationPctDesc = 'DEHYDRATION_PCT_DESC',
  DehydrationDegAsc = 'DEHYDRATION_DEG_ASC',
  DehydrationDegDesc = 'DEHYDRATION_DEG_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  BrixMinAsc = 'BRIX_MIN_ASC',
  BrixMinDesc = 'BRIX_MIN_DESC',
  BrixMaxAsc = 'BRIX_MAX_ASC',
  BrixMaxDesc = 'BRIX_MAX_DESC',
  BrixMostAsc = 'BRIX_MOST_ASC',
  BrixMostDesc = 'BRIX_MOST_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `PsaPomegranatePallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaPomegranatePalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `grade` field. */
  grade?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrade` field. */
  inspGrade?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `blushColor` field. */
  blushColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushPct` field. */
  blushPct?: Maybe<StringFilter>;
  /** Filter by the object’s `arilsColor` field. */
  arilsColor?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsRussetPieces` field. */
  scarsRussetPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsRussetPct` field. */
  scarsRussetPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsRussetDeg` field. */
  scarsRussetDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsPieces` field. */
  cutsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsPct` field. */
  cutsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsDeg` field. */
  cutsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `sunScaldPieces` field. */
  sunScaldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `sunScaldPct` field. */
  sunScaldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `sunScaldDeg` field. */
  sunScaldDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `scaldPieces` field. */
  scaldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scaldPct` field. */
  scaldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scaldDeg` field. */
  scaldDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `brixMin` field. */
  brixMin?: Maybe<StringFilter>;
  /** Filter by the object’s `brixMax` field. */
  brixMax?: Maybe<StringFilter>;
  /** Filter by the object’s `brixMost` field. */
  brixMost?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaPomegranatePalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaPomegranatePalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaPomegranatePalletFilter>;
};

/** A connection to a list of `PsaStoneFruitPallet` values. */
export type PsaStoneFruitPalletsConnection = {
  __typename?: 'PsaStoneFruitPalletsConnection';
  /** A list of `PsaStoneFruitPallet` objects. */
  nodes: Array<Maybe<PsaStoneFruitPallet>>;
  /** A list of edges which contains the `PsaStoneFruitPallet` and cursor to aid in pagination. */
  edges: Array<PsaStoneFruitPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaStoneFruitPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PsaStoneFruitPallet = Node & {
  __typename?: 'PsaStoneFruitPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  ripening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  cutsSplitsPct?: Maybe<Scalars['String']>;
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  splitPitPieces?: Maybe<Scalars['String']>;
  splitPitPct?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  softTipsPieces?: Maybe<Scalars['String']>;
  softTipsPct?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  mealinessPieces?: Maybe<Scalars['String']>;
  mealinessPct?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaStoneFruitPalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/** A `PsaStoneFruitPallet` edge in the connection. */
export type PsaStoneFruitPalletsEdge = {
  __typename?: 'PsaStoneFruitPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaStoneFruitPallet` at the end of the edge. */
  node?: Maybe<PsaStoneFruitPallet>;
};

/** Methods to use when ordering `PsaStoneFruitPallet`. */
export enum PsaStoneFruitPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  RipeningAsc = 'RIPENING_ASC',
  RipeningDesc = 'RIPENING_DESC',
  GroundColorAsc = 'GROUND_COLOR_ASC',
  GroundColorDesc = 'GROUND_COLOR_DESC',
  BlushColorAsc = 'BLUSH_COLOR_ASC',
  BlushColorDesc = 'BLUSH_COLOR_DESC',
  BlushPctAsc = 'BLUSH_PCT_ASC',
  BlushPctDesc = 'BLUSH_PCT_DESC',
  ScarsPiecesAsc = 'SCARS_PIECES_ASC',
  ScarsPiecesDesc = 'SCARS_PIECES_DESC',
  ScarsPctAsc = 'SCARS_PCT_ASC',
  ScarsPctDesc = 'SCARS_PCT_DESC',
  ScarsDegAsc = 'SCARS_DEG_ASC',
  ScarsDegDesc = 'SCARS_DEG_DESC',
  CutsSplitsPiecesAsc = 'CUTS_SPLITS_PIECES_ASC',
  CutsSplitsPiecesDesc = 'CUTS_SPLITS_PIECES_DESC',
  CutsSplitsPctAsc = 'CUTS_SPLITS_PCT_ASC',
  CutsSplitsPctDesc = 'CUTS_SPLITS_PCT_DESC',
  CutsSplitsDegAsc = 'CUTS_SPLITS_DEG_ASC',
  CutsSplitsDegDesc = 'CUTS_SPLITS_DEG_DESC',
  SplitPitPiecesAsc = 'SPLIT_PIT_PIECES_ASC',
  SplitPitPiecesDesc = 'SPLIT_PIT_PIECES_DESC',
  SplitPitPctAsc = 'SPLIT_PIT_PCT_ASC',
  SplitPitPctDesc = 'SPLIT_PIT_PCT_DESC',
  BruisingPiecesAsc = 'BRUISING_PIECES_ASC',
  BruisingPiecesDesc = 'BRUISING_PIECES_DESC',
  BruisingPctAsc = 'BRUISING_PCT_ASC',
  BruisingPctDesc = 'BRUISING_PCT_DESC',
  BruisingDegAsc = 'BRUISING_DEG_ASC',
  BruisingDegDesc = 'BRUISING_DEG_DESC',
  SoftTipsPiecesAsc = 'SOFT_TIPS_PIECES_ASC',
  SoftTipsPiecesDesc = 'SOFT_TIPS_PIECES_DESC',
  SoftTipsPctAsc = 'SOFT_TIPS_PCT_ASC',
  SoftTipsPctDesc = 'SOFT_TIPS_PCT_DESC',
  DehydrationPiecesAsc = 'DEHYDRATION_PIECES_ASC',
  DehydrationPiecesDesc = 'DEHYDRATION_PIECES_DESC',
  DehydrationPctAsc = 'DEHYDRATION_PCT_ASC',
  DehydrationPctDesc = 'DEHYDRATION_PCT_DESC',
  DehydrationDegAsc = 'DEHYDRATION_DEG_ASC',
  DehydrationDegDesc = 'DEHYDRATION_DEG_DESC',
  CutCountAsc = 'CUT_COUNT_ASC',
  CutCountDesc = 'CUT_COUNT_DESC',
  InternalDamagePiecesAsc = 'INTERNAL_DAMAGE_PIECES_ASC',
  InternalDamagePiecesDesc = 'INTERNAL_DAMAGE_PIECES_DESC',
  InternalDamagePerAsc = 'INTERNAL_DAMAGE_PER_ASC',
  InternalDamagePerDesc = 'INTERNAL_DAMAGE_PER_DESC',
  MealinessPiecesAsc = 'MEALINESS_PIECES_ASC',
  MealinessPiecesDesc = 'MEALINESS_PIECES_DESC',
  MealinessPctAsc = 'MEALINESS_PCT_ASC',
  MealinessPctDesc = 'MEALINESS_PCT_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  BrixAsc = 'BRIX_ASC',
  BrixDesc = 'BRIX_DESC',
  Pressure1Asc = 'PRESSURE1_ASC',
  Pressure1Desc = 'PRESSURE1_DESC',
  Pressure2Asc = 'PRESSURE2_ASC',
  Pressure2Desc = 'PRESSURE2_DESC',
  Pressure3Asc = 'PRESSURE3_ASC',
  Pressure3Desc = 'PRESSURE3_DESC',
  Pressure4Asc = 'PRESSURE4_ASC',
  Pressure4Desc = 'PRESSURE4_DESC',
  Pressure5Asc = 'PRESSURE5_ASC',
  Pressure5Desc = 'PRESSURE5_DESC',
  Pressure6Asc = 'PRESSURE6_ASC',
  Pressure6Desc = 'PRESSURE6_DESC',
  PressuresMinAsc = 'PRESSURES_MIN_ASC',
  PressuresMinDesc = 'PRESSURES_MIN_DESC',
  PressuresMaxAsc = 'PRESSURES_MAX_ASC',
  PressuresMaxDesc = 'PRESSURES_MAX_DESC',
  PressuresAvgAsc = 'PRESSURES_AVG_ASC',
  PressuresAvgDesc = 'PRESSURES_AVG_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `PsaStoneFruitPallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaStoneFruitPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `ripening` field. */
  ripening?: Maybe<StringFilter>;
  /** Filter by the object’s `groundColor` field. */
  groundColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushColor` field. */
  blushColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushPct` field. */
  blushPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPct` field. */
  scarsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsSplitsPieces` field. */
  cutsSplitsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsSplitsPct` field. */
  cutsSplitsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsSplitsDeg` field. */
  cutsSplitsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `splitPitPieces` field. */
  splitPitPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `splitPitPct` field. */
  splitPitPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `softTipsPieces` field. */
  softTipsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `softTipsPct` field. */
  softTipsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutCount` field. */
  cutCount?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<StringFilter>;
  /** Filter by the object’s `mealinessPieces` field. */
  mealinessPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `mealinessPct` field. */
  mealinessPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `brix` field. */
  brix?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure1` field. */
  pressure1?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure2` field. */
  pressure2?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure3` field. */
  pressure3?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure4` field. */
  pressure4?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure5` field. */
  pressure5?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure6` field. */
  pressure6?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaStoneFruitPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaStoneFruitPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaStoneFruitPalletFilter>;
};

export type Vessel = Node & {
  __typename?: 'Vessel';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  vesselCode: Scalars['String'];
  vesselName?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  dischargeDate?: Maybe<Scalars['Date']>;
  coast?: Maybe<Scalars['String']>;
  country?: Maybe<Country>;
  /** Reads and enables pagination through a set of `InventoryItem`. */
  inventoryItems: InventoryItemsConnection;
  /** Reads and enables pagination through a set of `Pallet`. */
  pallets: PalletsConnection;
  searchText?: Maybe<Scalars['String']>;
  warehouse?: Maybe<Warehouse>;
};


export type VesselInventoryItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<InventoryItemFilter>;
};


export type VesselPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PalletFilter>;
};

/** A connection to a list of `InventoryItem` values. */
export type InventoryItemsConnection = {
  __typename?: 'InventoryItemsConnection';
  /** A list of `InventoryItem` objects. */
  nodes: Array<Maybe<InventoryItem>>;
  /** A list of edges which contains the `InventoryItem` and cursor to aid in pagination. */
  edges: Array<InventoryItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InventoryItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type InventoryItem = Node & {
  __typename?: 'InventoryItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  productId?: Maybe<Scalars['String']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  palletsReceived?: Maybe<Scalars['BigFloat']>;
  palletsCommitted?: Maybe<Scalars['BigFloat']>;
  palletsOnHand?: Maybe<Scalars['BigFloat']>;
  palletsAvailable?: Maybe<Scalars['BigFloat']>;
  palletsShipped?: Maybe<Scalars['BigFloat']>;
  palletsTransferredIn?: Maybe<Scalars['BigFloat']>;
  palletsTransferredOut?: Maybe<Scalars['BigFloat']>;
  plu?: Maybe<Scalars['Boolean']>;
  countryId?: Maybe<Scalars['String']>;
  specialLotNumber?: Maybe<Scalars['String']>;
  coast?: Maybe<Scalars['String']>;
  storageRank?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  country?: Maybe<Country>;
  /** Reads and enables pagination through a set of `Pallet`. */
  pallets: PalletsConnection;
  product?: Maybe<ProductMaster>;
  shipper?: Maybe<Shipper>;
  vessel?: Maybe<Vessel>;
  warehouse?: Maybe<Warehouse>;
};


export type InventoryItemPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PalletFilter>;
};

/** A connection to a list of `Pallet` values. */
export type PalletsConnection = {
  __typename?: 'PalletsConnection';
  /** A list of `Pallet` objects. */
  nodes: Array<Maybe<Pallet>>;
  /** A list of edges which contains the `Pallet` and cursor to aid in pagination. */
  edges: Array<PalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Pallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Pallet = {
  __typename?: 'Pallet';
  id?: Maybe<Scalars['BigInt']>;
  vesselCode?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  productId?: Maybe<Scalars['String']>;
  currentBoxQuantity?: Maybe<Scalars['BigFloat']>;
  receivedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  returnedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  room?: Maybe<Scalars['String']>;
  section?: Maybe<Scalars['String']>;
  row?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  dateTransferredToStorage?: Maybe<Scalars['Date']>;
  orderId?: Maybe<Scalars['String']>;
  backOrderId?: Maybe<Scalars['String']>;
  shipped?: Maybe<Scalars['Boolean']>;
  age?: Maybe<Scalars['BigFloat']>;
  volumeDiscountCode?: Maybe<Scalars['String']>;
  originalLocationId?: Maybe<Scalars['String']>;
  filler?: Maybe<Scalars['String']>;
  growerId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  billOfLading?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  temperatureRecording?: Maybe<Scalars['String']>;
  originalLocation?: Maybe<Warehouse>;
  /** Reads and enables pagination through a set of `PalletSection`. */
  palletSections: PalletSectionsConnection;
  product?: Maybe<ProductMaster>;
  searchText?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
  vessel?: Maybe<Vessel>;
  warehouse?: Maybe<Warehouse>;
};


export type PalletPalletSectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PalletSectionFilter>;
};

/** A connection to a list of `PalletSection` values. */
export type PalletSectionsConnection = {
  __typename?: 'PalletSectionsConnection';
  /** A list of `PalletSection` objects. */
  nodes: Array<Maybe<PalletSection>>;
  /** A list of edges which contains the `PalletSection` and cursor to aid in pagination. */
  edges: Array<PalletSectionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PalletSection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PalletSection = Node & {
  __typename?: 'PalletSection';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  palletId: Scalars['String'];
  growerId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  sizeId?: Maybe<Scalars['String']>;
  boxQuantity?: Maybe<Scalars['BigFloat']>;
  packDate?: Maybe<Scalars['String']>;
  variety?: Maybe<ProductVariety>;
};

export type ProductVariety = Node & {
  __typename?: 'ProductVariety';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  varietyDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  customerLetterSequence?: Maybe<Scalars['String']>;
  summaryCode?: Maybe<Scalars['String']>;
  varietyGroup?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** A `PalletSection` edge in the connection. */
export type PalletSectionsEdge = {
  __typename?: 'PalletSectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PalletSection` at the end of the edge. */
  node?: Maybe<PalletSection>;
};

/** A filter to be used against `PalletSection` object types. All fields are combined with a logical ‘and.’ */
export type PalletSectionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerId` field. */
  growerId?: Maybe<StringFilter>;
  /** Filter by the object’s `varietyId` field. */
  varietyId?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeId` field. */
  sizeId?: Maybe<StringFilter>;
  /** Filter by the object’s `boxQuantity` field. */
  boxQuantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PalletSectionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PalletSectionFilter>>;
  /** Negates the expression. */
  not?: Maybe<PalletSectionFilter>;
};

export type ProductMaster = Node & {
  __typename?: 'ProductMaster';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  defaultPalletQuantity?: Maybe<Scalars['String']>;
  lotNumber?: Maybe<Scalars['String']>;
  packType?: Maybe<PackMaster>;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `ProductSize`. */
  sizes: ProductSizesConnection;
  species?: Maybe<ProductSpecies>;
  variety?: Maybe<ProductVariety>;
};


export type ProductMasterSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<ProductSizeFilter>;
};

export type PackMaster = Node & {
  __typename?: 'PackMaster';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  labelCodeId?: Maybe<Scalars['String']>;
  customerCodeId?: Maybe<Scalars['String']>;
  boxTypeId?: Maybe<Scalars['String']>;
  boxStyleId?: Maybe<Scalars['String']>;
  packStyleId?: Maybe<Scalars['String']>;
  outCodeId?: Maybe<Scalars['String']>;
  outQuantity?: Maybe<Scalars['String']>;
  outWeight?: Maybe<Scalars['String']>;
  productionCodeId?: Maybe<Scalars['String']>;
  treeRipeId?: Maybe<Scalars['String']>;
  gradeCodeId?: Maybe<Scalars['String']>;
  maCodeId?: Maybe<Scalars['String']>;
  linerCodeId?: Maybe<Scalars['String']>;
  netWeightContents?: Maybe<Scalars['BigFloat']>;
  netWeightBox?: Maybe<Scalars['BigFloat']>;
  boxLength?: Maybe<Scalars['BigFloat']>;
  boxWidth?: Maybe<Scalars['BigFloat']>;
  boxHeight?: Maybe<Scalars['BigFloat']>;
  palletTypeId?: Maybe<Scalars['String']>;
  defaultPalletQuantity?: Maybe<Scalars['BigFloat']>;
  pluUpcCode?: Maybe<Scalars['String']>;
  destinationCodeId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  oldLabelCode?: Maybe<Scalars['String']>;
  jvPackCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  speciesId?: Maybe<Scalars['String']>;
  holdCodeId?: Maybe<Scalars['String']>;
  atmosphere?: Maybe<PackAtmosphere>;
  boxStyle?: Maybe<PackBoxStyle>;
  boxType?: Maybe<PackBoxType>;
  customerSpecial?: Maybe<PackSpecial>;
  destination?: Maybe<PackDestination>;
  grade?: Maybe<PackGrade>;
  hold?: Maybe<PackHold>;
  label?: Maybe<PackLabel>;
  liner?: Maybe<PackLiner>;
  out?: Maybe<PackOut>;
  packStyle?: Maybe<PackStyle>;
  palletType?: Maybe<PackPalletType>;
  production?: Maybe<PackProduction>;
  shipper?: Maybe<Shipper>;
  species?: Maybe<ProductSpecies>;
  treeRipe?: Maybe<PackTreeRipe>;
  variety?: Maybe<ProductVariety>;
};

export type PackAtmosphere = Node & {
  __typename?: 'PackAtmosphere';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  maCode?: Maybe<Scalars['String']>;
  maDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

export type PackBoxStyle = Node & {
  __typename?: 'PackBoxStyle';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  boxStyle?: Maybe<Scalars['String']>;
  boxDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

export type PackBoxType = Node & {
  __typename?: 'PackBoxType';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  boxType?: Maybe<Scalars['String']>;
  boxDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

export type PackSpecial = Node & {
  __typename?: 'PackSpecial';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  customerCode?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  customer?: Maybe<Customer>;
  shipper?: Maybe<Shipper>;
};

export type PackDestination = Node & {
  __typename?: 'PackDestination';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  destinationCode?: Maybe<Scalars['String']>;
  destinationDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

export type PackGrade = Node & {
  __typename?: 'PackGrade';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  gradeCode?: Maybe<Scalars['String']>;
  gradeDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

export type PackHold = Node & {
  __typename?: 'PackHold';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  holdCode?: Maybe<Scalars['String']>;
  holdDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

export type PackLabel = Node & {
  __typename?: 'PackLabel';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  labelCode?: Maybe<Scalars['String']>;
  labelName?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

export type PackLiner = Node & {
  __typename?: 'PackLiner';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  linerCode?: Maybe<Scalars['String']>;
  linerDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

export type PackOut = Node & {
  __typename?: 'PackOut';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  outCode?: Maybe<Scalars['String']>;
  outDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

export type PackStyle = Node & {
  __typename?: 'PackStyle';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  packStyle?: Maybe<Scalars['String']>;
  styleDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

export type PackPalletType = Node & {
  __typename?: 'PackPalletType';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  palletType?: Maybe<Scalars['String']>;
  palletTypeDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

export type PackProduction = Node & {
  __typename?: 'PackProduction';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  productionCode?: Maybe<Scalars['String']>;
  productionDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

export type ProductSpecies = Node & {
  __typename?: 'ProductSpecies';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  speciesDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  fdaProductCode?: Maybe<Scalars['String']>;
  fdaIndustryCode?: Maybe<Scalars['String']>;
  defaultTemperature?: Maybe<Scalars['String']>;
};

export type PackTreeRipe = Node & {
  __typename?: 'PackTreeRipe';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  treeRipe?: Maybe<Scalars['String']>;
  treeRipeDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/** A connection to a list of `ProductSize` values. */
export type ProductSizesConnection = {
  __typename?: 'ProductSizesConnection';
  /** A list of `ProductSize` objects. */
  nodes: Array<Maybe<ProductSize>>;
  /** A list of edges which contains the `ProductSize` and cursor to aid in pagination. */
  edges: Array<ProductSizesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ProductSize = Node & {
  __typename?: 'ProductSize';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  speciesId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  jvCode?: Maybe<Scalars['String']>;
  jvDescription?: Maybe<Scalars['String']>;
  shipperCode?: Maybe<Scalars['String']>;
  shipperDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
  species?: Maybe<ProductSpecies>;
  variety?: Maybe<ProductVariety>;
};

/** A `ProductSize` edge in the connection. */
export type ProductSizesEdge = {
  __typename?: 'ProductSizesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductSize` at the end of the edge. */
  node?: Maybe<ProductSize>;
};

/** A filter to be used against `ProductSize` object types. All fields are combined with a logical ‘and.’ */
export type ProductSizeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `speciesId` field. */
  speciesId?: Maybe<StringFilter>;
  /** Filter by the object’s `varietyId` field. */
  varietyId?: Maybe<StringFilter>;
  /** Filter by the object’s `jvCode` field. */
  jvCode?: Maybe<StringFilter>;
  /** Filter by the object’s `jvDescription` field. */
  jvDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperCode` field. */
  shipperCode?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperDescription` field. */
  shipperDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Filter by the object’s `combineDescription` field. */
  combineDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProductSizeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProductSizeFilter>>;
  /** Negates the expression. */
  not?: Maybe<ProductSizeFilter>;
};

/** A `Pallet` edge in the connection. */
export type PalletsEdge = {
  __typename?: 'PalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Pallet` at the end of the edge. */
  node?: Maybe<Pallet>;
};

/** A filter to be used against `Pallet` object types. All fields are combined with a logical ‘and.’ */
export type PalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `productId` field. */
  productId?: Maybe<StringFilter>;
  /** Filter by the object’s `currentBoxQuantity` field. */
  currentBoxQuantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `receivedBoxQuantity` field. */
  receivedBoxQuantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `returnedBoxQuantity` field. */
  returnedBoxQuantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `locationId` field. */
  locationId?: Maybe<StringFilter>;
  /** Filter by the object’s `room` field. */
  room?: Maybe<StringFilter>;
  /** Filter by the object’s `section` field. */
  section?: Maybe<StringFilter>;
  /** Filter by the object’s `row` field. */
  row?: Maybe<StringFilter>;
  /** Filter by the object’s `jvLotNumber` field. */
  jvLotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `dateTransferredToStorage` field. */
  dateTransferredToStorage?: Maybe<DateFilter>;
  /** Filter by the object’s `orderId` field. */
  orderId?: Maybe<StringFilter>;
  /** Filter by the object’s `backOrderId` field. */
  backOrderId?: Maybe<StringFilter>;
  /** Filter by the object’s `shipped` field. */
  shipped?: Maybe<BooleanFilter>;
  /** Filter by the object’s `age` field. */
  age?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `volumeDiscountCode` field. */
  volumeDiscountCode?: Maybe<StringFilter>;
  /** Filter by the object’s `originalLocationId` field. */
  originalLocationId?: Maybe<StringFilter>;
  /** Filter by the object’s `filler` field. */
  filler?: Maybe<StringFilter>;
  /** Filter by the object’s `growerId` field. */
  growerId?: Maybe<StringFilter>;
  /** Filter by the object’s `oldPackCode` field. */
  oldPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `billOfLading` field. */
  billOfLading?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `temperatureRecording` field. */
  temperatureRecording?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PalletFilter>;
};

/** A `InventoryItem` edge in the connection. */
export type InventoryItemsEdge = {
  __typename?: 'InventoryItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `InventoryItem` at the end of the edge. */
  node?: Maybe<InventoryItem>;
};

/** A filter to be used against `InventoryItem` object types. All fields are combined with a logical ‘and.’ */
export type InventoryItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `productId` field. */
  productId?: Maybe<StringFilter>;
  /** Filter by the object’s `locationId` field. */
  locationId?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `jvLotNumber` field. */
  jvLotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `palletsReceived` field. */
  palletsReceived?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletsCommitted` field. */
  palletsCommitted?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletsOnHand` field. */
  palletsOnHand?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletsAvailable` field. */
  palletsAvailable?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletsShipped` field. */
  palletsShipped?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletsTransferredIn` field. */
  palletsTransferredIn?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletsTransferredOut` field. */
  palletsTransferredOut?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<BooleanFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<StringFilter>;
  /** Filter by the object’s `specialLotNumber` field. */
  specialLotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `coast` field. */
  coast?: Maybe<StringFilter>;
  /** Filter by the object’s `storageRank` field. */
  storageRank?: Maybe<StringFilter>;
  /** Filter by the object’s `warehouseId` field. */
  warehouseId?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<InventoryItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<InventoryItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<InventoryItemFilter>;
};

/** A `PsaArrivalReport` edge in the connection. */
export type PsaArrivalReportsEdge = {
  __typename?: 'PsaArrivalReportsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaArrivalReport` at the end of the edge. */
  node?: Maybe<PsaArrivalReport>;
};

/** Methods to use when ordering `PsaArrivalReport`. */
export enum PsaArrivalReportsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ReportDateAsc = 'REPORT_DATE_ASC',
  ReportDateDesc = 'REPORT_DATE_DESC',
  LocationNameAsc = 'LOCATION_NAME_ASC',
  LocationNameDesc = 'LOCATION_NAME_DESC',
  ArrivalCodeAsc = 'ARRIVAL_CODE_ASC',
  ArrivalCodeDesc = 'ARRIVAL_CODE_DESC',
  ArrivalNameAsc = 'ARRIVAL_NAME_ASC',
  ArrivalNameDesc = 'ARRIVAL_NAME_DESC',
  ExporterIdAsc = 'EXPORTER_ID_ASC',
  ExporterIdDesc = 'EXPORTER_ID_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  ConditionRangeAsc = 'CONDITION_RANGE_ASC',
  ConditionRangeDesc = 'CONDITION_RANGE_DESC',
  QualityRangeAsc = 'QUALITY_RANGE_ASC',
  QualityRangeDesc = 'QUALITY_RANGE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PsaArrivalReport` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaArrivalReportCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `reportDate` field. */
  reportDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `locationName` field. */
  locationName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrivalCode` field. */
  arrivalCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrivalName` field. */
  arrivalName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterId` field. */
  exporterId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PsaArrivalReport` object types. All fields are combined with a logical ‘and.’ */
export type PsaArrivalReportFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `reportDate` field. */
  reportDate?: Maybe<DateFilter>;
  /** Filter by the object’s `locationName` field. */
  locationName?: Maybe<StringFilter>;
  /** Filter by the object’s `arrivalCode` field. */
  arrivalCode?: Maybe<StringFilter>;
  /** Filter by the object’s `arrivalName` field. */
  arrivalName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterId` field. */
  exporterId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodityList` field. */
  commodityList?: Maybe<StringListFilter>;
  /** Filter by the object’s `conditionRange` field. */
  conditionRange?: Maybe<StringFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `qualityRange` field. */
  qualityRange?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaArrivalReportFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaArrivalReportFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaArrivalReportFilter>;
};

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Contains the specified list of values. */
  contains?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Contained by the specified list of values. */
  containedBy?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Any array item is equal to the specified value. */
  anyEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: Maybe<Scalars['String']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: Maybe<Scalars['String']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `PsaCherryPallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaCherryPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeMin` field. */
  sizeMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeMax` field. */
  sizeMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeMost` field. */
  sizeMost?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `color` field. */
  color?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsMarksPieces` field. */
  scarsMarksPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsMarksPct` field. */
  scarsMarksPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsMarksDeg` field. */
  scarsMarksDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `misshapenPieces` field. */
  misshapenPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `misshapenPct` field. */
  misshapenPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemlessPieces` field. */
  stemlessPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemlessPct` field. */
  stemlessPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitsPieces` field. */
  splitsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitsPct` field. */
  splitsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitsDeg` field. */
  splitsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `firmness` field. */
  firmness?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pittingBruisingPieces` field. */
  pittingBruisingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pittingBruisingPct` field. */
  pittingBruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pittingBruisingDeg` field. */
  pittingBruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemDehydrationPieces` field. */
  stemDehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemDehydrationPct` field. */
  stemDehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemDehydrationDeg` field. */
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `PsaCitrusPallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaCitrusPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `color` field. */
  color?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMinMm` field. */
  diameterMinMm?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMinInches` field. */
  diameterMinInches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMaxMm` field. */
  diameterMaxMm?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMaxInches` field. */
  diameterMaxInches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMostMm` field. */
  diameterMostMm?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMostInches` field. */
  diameterMostInches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPct` field. */
  scarsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenHazePieces` field. */
  greenHazePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenHazePct` field. */
  greenHazePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenHazeDeg` field. */
  greenHazeDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oilSpotsPieces` field. */
  oilSpotsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oilSpotsPct` field. */
  oilSpotsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oilSpotsDeg` field. */
  oilSpotsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutCount` field. */
  cutCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dryPulpPieces` field. */
  dryPulpPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dryPulpPct` field. */
  dryPulpPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dryPulpDeg` field. */
  dryPulpDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `seedsPieces` field. */
  seedsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `seedsPct` field. */
  seedsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skinBreakdownPieces` field. */
  skinBreakdownPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skinBreakdownPct` field. */
  skinBreakdownPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skinBreakdownDeg` field. */
  skinBreakdownDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `creasingPieces` field. */
  creasingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `creasingPct` field. */
  creasingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `creasingDeg` field. */
  creasingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `puffinessPieces` field. */
  puffinessPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `puffinessPct` field. */
  puffinessPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `puffinessDeg` field. */
  puffinessDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sporesPieces` field. */
  sporesPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sporesPct` field. */
  sporesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brix` field. */
  brix?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `PsaGrapePallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaGrapePalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `grade` field. */
  grade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoOpening` field. */
  autoOpening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bunches` field. */
  bunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeMin` field. */
  sizeMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeMax` field. */
  sizeMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeMost` field. */
  sizeMost?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `undersizeBunchesCount` field. */
  undersizeBunchesCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoUndersizeBerriesBunches` field. */
  autoUndersizeBerriesBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `undersizeBerriesPct` field. */
  undersizeBerriesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `colorMin` field. */
  colorMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `colorMax` field. */
  colorMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `colorMost` field. */
  colorMost?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `colorConsistency` field. */
  colorConsistency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoColorConsistency` field. */
  autoColorConsistency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunburnBunches` field. */
  sunburnBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoSunburnBunches` field. */
  autoSunburnBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunburnPct` field. */
  sunburnPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunburnBunchesDeg` field. */
  sunburnBunchesDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bunchConformation` field. */
  bunchConformation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoBunchConformation` field. */
  autoBunchConformation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stragglyBunches` field. */
  stragglyBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stragglyPct` field. */
  stragglyPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `smallBunches` field. */
  smallBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `russetMarksBunches` field. */
  russetMarksBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `russetMarksPct` field. */
  russetMarksPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoRussetMarksPct` field. */
  autoRussetMarksPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dustPct` field. */
  dustPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoDustPct` field. */
  autoDustPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `residuesPct` field. */
  residuesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoResiduesPct` field. */
  autoResiduesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `tightBunches` field. */
  tightBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoTightBunches` field. */
  autoTightBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingBunches` field. */
  bruisingBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoBruisingBunches` field. */
  autoBruisingBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemDehydrationPct` field. */
  stemDehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoStemDehydrationPct` field. */
  autoStemDehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemDehydrationDeg` field. */
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `berryCondition` field. */
  berryCondition?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoBerryCondition` field. */
  autoBerryCondition?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `h2OBerries` field. */
  h2OBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoH2OBerries` field. */
  autoH2OBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `so2DamagePct` field. */
  so2DamagePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoSo2DamagePct` field. */
  autoSo2DamagePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `so2DamageDeg` field. */
  so2DamageDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weakBunches` field. */
  weakBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoWeakBunches` field. */
  autoWeakBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitsHairlinePct` field. */
  splitsHairlinePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoSplitsHairlinePct` field. */
  autoSplitsHairlinePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitsWetCrushPct` field. */
  splitsWetCrushPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoSplitsWetCrushPct` field. */
  autoSplitsWetCrushPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitsDryPct` field. */
  splitsDryPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoSplitsDryPct` field. */
  autoSplitsDryPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `intDisc` field. */
  intDisc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoIntDisc` field. */
  autoIntDisc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `intDiscDeg` field. */
  intDiscDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayMoldBerries` field. */
  decayMoldBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoDecayMoldBerries` field. */
  autoDecayMoldBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decaySlipskinBerries` field. */
  decaySlipskinBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoDecaySlipskinBerries` field. */
  autoDecaySlipskinBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayNestBerries` field. */
  decayNestBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoDecayNestBerries` field. */
  autoDecayNestBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayNestDeg` field. */
  decayNestDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shatterPct` field. */
  shatterPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoShatterPct` field. */
  autoShatterPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixMin` field. */
  brixMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixMax` field. */
  brixMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixMost` field. */
  brixMost?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `autoOverallQuality` field. */
  autoOverallQuality?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `autoOverallCondition` field. */
  autoOverallCondition?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `PsaLemonPallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaLemonPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `grade` field. */
  grade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrade` field. */
  inspGrade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `color` field. */
  color?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMinMm` field. */
  diameterMinMm?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMinInches` field. */
  diameterMinInches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMaxMm` field. */
  diameterMaxMm?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMaxInches` field. */
  diameterMaxInches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMostMm` field. */
  diameterMostMm?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMostInches` field. */
  diameterMostInches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPct` field. */
  scarsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenHazePieces` field. */
  greenHazePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenHazePct` field. */
  greenHazePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenHazeDeg` field. */
  greenHazeDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oilSpotsPieces` field. */
  oilSpotsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oilSpotsPct` field. */
  oilSpotsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oilSpotsDeg` field. */
  oilSpotsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutCount` field. */
  cutCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dryPulpPieces` field. */
  dryPulpPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dryPulpPct` field. */
  dryPulpPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dryPulpDeg` field. */
  dryPulpDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skinDamagePieces` field. */
  skinDamagePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skinDamagePct` field. */
  skinDamagePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skinDamageDeg` field. */
  skinDamageDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `petecaPieces` field. */
  petecaPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `petecaPct` field. */
  petecaPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `petecaDeg` field. */
  petecaDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sporesPieces` field. */
  sporesPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sporesPct` field. */
  sporesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `PsaPearPallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaPearPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `runNumber` field. */
  runNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `grade` field. */
  grade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrade` field. */
  inspGrade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `groundColor` field. */
  groundColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushColor` field. */
  blushColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushPct` field. */
  blushPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsRussetPieces` field. */
  scarsRussetPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsRussetPct` field. */
  scarsRussetPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsRussetDeg` field. */
  scarsRussetDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `russetPerPiecePct` field. */
  russetPerPiecePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemPuncturesPieces` field. */
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemPuncturesPct` field. */
  stemPuncturesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsPieces` field. */
  cutsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsPct` field. */
  cutsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsDeg` field. */
  cutsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `turningColorPieces` field. */
  turningColorPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `turningColorPct` field. */
  turningColorPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `turningColorDeg` field. */
  turningColorDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutCount` field. */
  cutCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure1` field. */
  pressure1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure2` field. */
  pressure2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure3` field. */
  pressure3?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure4` field. */
  pressure4?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure5` field. */
  pressure5?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure6` field. */
  pressure6?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `PsaPersimmonPallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaPersimmonPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `color` field. */
  color?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsMarksPieces` field. */
  scarsMarksPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsMarksPct` field. */
  scarsMarksPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsMarksDeg` field. */
  scarsMarksDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenColorPieces` field. */
  greenColorPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenColor` field. */
  greenColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenColorDeg` field. */
  greenColorDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsSplitsPieces` field. */
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsSplitsPct` field. */
  cutsSplitsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsSplitsDeg` field. */
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutCount` field. */
  cutCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `seedsPieces` field. */
  seedsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `seedsPct` field. */
  seedsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamageDeg` field. */
  internalDamageDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brix` field. */
  brix?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure1` field. */
  pressure1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure2` field. */
  pressure2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure3` field. */
  pressure3?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure4` field. */
  pressure4?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure5` field. */
  pressure5?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure6` field. */
  pressure6?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `PsaPomegranatePallet` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type PsaPomegranatePalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `grade` field. */
  grade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrade` field. */
  inspGrade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushColor` field. */
  blushColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushPct` field. */
  blushPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arilsColor` field. */
  arilsColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsRussetPieces` field. */
  scarsRussetPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsRussetPct` field. */
  scarsRussetPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsRussetDeg` field. */
  scarsRussetDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsPieces` field. */
  cutsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsPct` field. */
  cutsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsDeg` field. */
  cutsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunScaldPieces` field. */
  sunScaldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunScaldPct` field. */
  sunScaldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunScaldDeg` field. */
  sunScaldDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scaldPieces` field. */
  scaldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scaldPct` field. */
  scaldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scaldDeg` field. */
  scaldDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixMin` field. */
  brixMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixMax` field. */
  brixMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixMost` field. */
  brixMost?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `PsaStoneFruitPallet` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type PsaStoneFruitPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `ripening` field. */
  ripening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `groundColor` field. */
  groundColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushColor` field. */
  blushColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushPct` field. */
  blushPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPct` field. */
  scarsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsSplitsPieces` field. */
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsSplitsPct` field. */
  cutsSplitsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsSplitsDeg` field. */
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitPitPieces` field. */
  splitPitPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitPitPct` field. */
  splitPitPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `softTipsPieces` field. */
  softTipsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `softTipsPct` field. */
  softTipsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutCount` field. */
  cutCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `mealinessPieces` field. */
  mealinessPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `mealinessPct` field. */
  mealinessPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brix` field. */
  brix?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure1` field. */
  pressure1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure2` field. */
  pressure2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure3` field. */
  pressure3?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure4` field. */
  pressure4?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure5` field. */
  pressure5?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure6` field. */
  pressure6?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A connection to a list of `AgendaItem` values. */
export type AgendaItemsConnection = {
  __typename?: 'AgendaItemsConnection';
  /** A list of `AgendaItem` objects. */
  nodes: Array<Maybe<AgendaItem>>;
  /** A list of edges which contains the `AgendaItem` and cursor to aid in pagination. */
  edges: Array<AgendaItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AgendaItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type AgendaItem = Node & {
  __typename?: 'AgendaItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  content: Scalars['String'];
  itemDate: Scalars['Date'];
  sortOrder: Scalars['Int'];
};

/** A `AgendaItem` edge in the connection. */
export type AgendaItemsEdge = {
  __typename?: 'AgendaItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `AgendaItem` at the end of the edge. */
  node?: Maybe<AgendaItem>;
};

/** Methods to use when ordering `AgendaItem`. */
export enum AgendaItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  ItemDateAsc = 'ITEM_DATE_ASC',
  ItemDateDesc = 'ITEM_DATE_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `AgendaItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AgendaItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `content` field. */
  content?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `itemDate` field. */
  itemDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `AgendaItem` object types. All fields are combined with a logical ‘and.’ */
export type AgendaItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `content` field. */
  content?: Maybe<StringFilter>;
  /** Filter by the object’s `itemDate` field. */
  itemDate?: Maybe<DateFilter>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: Maybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AgendaItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AgendaItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<AgendaItemFilter>;
};

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Int']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Int']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Int']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Int']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Int']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Int']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `CalendarEvent` values. */
export type CalendarEventsConnection = {
  __typename?: 'CalendarEventsConnection';
  /** A list of `CalendarEvent` objects. */
  nodes: Array<Maybe<CalendarEvent>>;
  /** A list of edges which contains the `CalendarEvent` and cursor to aid in pagination. */
  edges: Array<CalendarEventsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CalendarEvent` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CalendarEvent = Node & {
  __typename?: 'CalendarEvent';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  title?: Maybe<Scalars['String']>;
  eventDescription?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['Datetime']>;
  endDate?: Maybe<Scalars['Datetime']>;
  allDay?: Maybe<Scalars['Boolean']>;
  rrule?: Maybe<Scalars['String']>;
};

/** A `CalendarEvent` edge in the connection. */
export type CalendarEventsEdge = {
  __typename?: 'CalendarEventsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CalendarEvent` at the end of the edge. */
  node?: Maybe<CalendarEvent>;
};

/** Methods to use when ordering `CalendarEvent`. */
export enum CalendarEventsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  EventDescriptionAsc = 'EVENT_DESCRIPTION_ASC',
  EventDescriptionDesc = 'EVENT_DESCRIPTION_DESC',
  StartDateAsc = 'START_DATE_ASC',
  StartDateDesc = 'START_DATE_DESC',
  EndDateAsc = 'END_DATE_ASC',
  EndDateDesc = 'END_DATE_DESC',
  AllDayAsc = 'ALL_DAY_ASC',
  AllDayDesc = 'ALL_DAY_DESC',
  RruleAsc = 'RRULE_ASC',
  RruleDesc = 'RRULE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `CalendarEvent` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CalendarEventCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `eventDescription` field. */
  eventDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `allDay` field. */
  allDay?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `rrule` field. */
  rrule?: Maybe<Scalars['String']>;
};

/** A filter to be used against `CalendarEvent` object types. All fields are combined with a logical ‘and.’ */
export type CalendarEventFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `eventDescription` field. */
  eventDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `startDate` field. */
  startDate?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `endDate` field. */
  endDate?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `allDay` field. */
  allDay?: Maybe<BooleanFilter>;
  /** Filter by the object’s `rrule` field. */
  rrule?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CalendarEventFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CalendarEventFilter>>;
  /** Negates the expression. */
  not?: Maybe<CalendarEventFilter>;
};

/** A connection to a list of `PriceCategory` values. */
export type PriceCategoriesConnection = {
  __typename?: 'PriceCategoriesConnection';
  /** A list of `PriceCategory` objects. */
  nodes: Array<Maybe<PriceCategory>>;
  /** A list of edges which contains the `PriceCategory` and cursor to aid in pagination. */
  edges: Array<PriceCategoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PriceCategory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PriceCategory = Node & {
  __typename?: 'PriceCategory';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  categoryName: Scalars['String'];
  sortOrder: Scalars['Int'];
  /** Reads and enables pagination through a set of `PriceProduct`. */
  priceProductsByCategoryId: PriceProductsConnection;
};


export type PriceCategoryPriceProductsByCategoryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceProductsOrderBy>>;
  condition?: Maybe<PriceProductCondition>;
  filter?: Maybe<PriceProductFilter>;
};

/** A connection to a list of `PriceProduct` values. */
export type PriceProductsConnection = {
  __typename?: 'PriceProductsConnection';
  /** A list of `PriceProduct` objects. */
  nodes: Array<Maybe<PriceProduct>>;
  /** A list of edges which contains the `PriceProduct` and cursor to aid in pagination. */
  edges: Array<PriceProductsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PriceProduct` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PriceProduct = Node & {
  __typename?: 'PriceProduct';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  categoryId: Scalars['BigInt'];
  color: Scalars['String'];
  productName: Scalars['String'];
  sortOrder: Scalars['Int'];
  /** Reads a single `PriceCategory` that is related to this `PriceProduct`. */
  category?: Maybe<PriceCategory>;
  /** Reads and enables pagination through a set of `PriceSize`. */
  priceSizesByProductId: PriceSizesConnection;
  productRootId?: Maybe<Scalars['BigInt']>;
};


export type PriceProductPriceSizesByProductIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceSizesOrderBy>>;
  condition?: Maybe<PriceSizeCondition>;
  filter?: Maybe<PriceSizeFilter>;
};

/** A connection to a list of `PriceSize` values. */
export type PriceSizesConnection = {
  __typename?: 'PriceSizesConnection';
  /** A list of `PriceSize` objects. */
  nodes: Array<Maybe<PriceSize>>;
  /** A list of edges which contains the `PriceSize` and cursor to aid in pagination. */
  edges: Array<PriceSizesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PriceSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PriceSize = Node & {
  __typename?: 'PriceSize';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  productId: Scalars['BigInt'];
  sizeName: Scalars['String'];
  sortOrder: Scalars['Int'];
  /** Reads a single `PriceProduct` that is related to this `PriceSize`. */
  product?: Maybe<PriceProduct>;
  /** Reads and enables pagination through a set of `PriceEntry`. */
  priceEntriesBySizeId: PriceEntriesConnection;
};


export type PriceSizePriceEntriesBySizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceEntriesOrderBy>>;
  condition?: Maybe<PriceEntryCondition>;
  filter?: Maybe<PriceEntryFilter>;
};

/** A connection to a list of `PriceEntry` values. */
export type PriceEntriesConnection = {
  __typename?: 'PriceEntriesConnection';
  /** A list of `PriceEntry` objects. */
  nodes: Array<Maybe<PriceEntry>>;
  /** A list of edges which contains the `PriceEntry` and cursor to aid in pagination. */
  edges: Array<PriceEntriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PriceEntry` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PriceEntry = Node & {
  __typename?: 'PriceEntry';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  sizeId: Scalars['BigInt'];
  entryDate: Scalars['Date'];
  entryDescription: Scalars['String'];
  content: Scalars['String'];
  highlight: Scalars['Boolean'];
  /** Reads a single `PriceSize` that is related to this `PriceEntry`. */
  size?: Maybe<PriceSize>;
};

/** A `PriceEntry` edge in the connection. */
export type PriceEntriesEdge = {
  __typename?: 'PriceEntriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PriceEntry` at the end of the edge. */
  node?: Maybe<PriceEntry>;
};

/** Methods to use when ordering `PriceEntry`. */
export enum PriceEntriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SizeIdAsc = 'SIZE_ID_ASC',
  SizeIdDesc = 'SIZE_ID_DESC',
  EntryDateAsc = 'ENTRY_DATE_ASC',
  EntryDateDesc = 'ENTRY_DATE_DESC',
  EntryDescriptionAsc = 'ENTRY_DESCRIPTION_ASC',
  EntryDescriptionDesc = 'ENTRY_DESCRIPTION_DESC',
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  HighlightAsc = 'HIGHLIGHT_ASC',
  HighlightDesc = 'HIGHLIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PriceEntry` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PriceEntryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sizeId` field. */
  sizeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `entryDate` field. */
  entryDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `entryDescription` field. */
  entryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `highlight` field. */
  highlight?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `PriceEntry` object types. All fields are combined with a logical ‘and.’ */
export type PriceEntryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `sizeId` field. */
  sizeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `entryDate` field. */
  entryDate?: Maybe<DateFilter>;
  /** Filter by the object’s `entryDescription` field. */
  entryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `content` field. */
  content?: Maybe<StringFilter>;
  /** Filter by the object’s `highlight` field. */
  highlight?: Maybe<BooleanFilter>;
  /** Filter by the object’s `size` relation. */
  size?: Maybe<PriceSizeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PriceEntryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PriceEntryFilter>>;
  /** Negates the expression. */
  not?: Maybe<PriceEntryFilter>;
};

/** A filter to be used against `PriceSize` object types. All fields are combined with a logical ‘and.’ */
export type PriceSizeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `productId` field. */
  productId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `sizeName` field. */
  sizeName?: Maybe<StringFilter>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: Maybe<IntFilter>;
  /** Filter by the object’s `priceEntriesBySizeId` relation. */
  priceEntriesBySizeId?: Maybe<PriceSizeToManyPriceEntryFilter>;
  /** Some related `priceEntriesBySizeId` exist. */
  priceEntriesBySizeIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `product` relation. */
  product?: Maybe<PriceProductFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PriceSizeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PriceSizeFilter>>;
  /** Negates the expression. */
  not?: Maybe<PriceSizeFilter>;
};

/** A filter to be used against many `PriceEntry` object types. All fields are combined with a logical ‘and.’ */
export type PriceSizeToManyPriceEntryFilter = {
  /** Every related `PriceEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PriceEntryFilter>;
  /** Some related `PriceEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PriceEntryFilter>;
  /** No related `PriceEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PriceEntryFilter>;
};

/** A filter to be used against `PriceProduct` object types. All fields are combined with a logical ‘and.’ */
export type PriceProductFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `color` field. */
  color?: Maybe<StringFilter>;
  /** Filter by the object’s `productName` field. */
  productName?: Maybe<StringFilter>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: Maybe<IntFilter>;
  /** Filter by the object’s `productRootId` field. */
  productRootId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `priceSizesByProductId` relation. */
  priceSizesByProductId?: Maybe<PriceProductToManyPriceSizeFilter>;
  /** Some related `priceSizesByProductId` exist. */
  priceSizesByProductIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `category` relation. */
  category?: Maybe<PriceCategoryFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PriceProductFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PriceProductFilter>>;
  /** Negates the expression. */
  not?: Maybe<PriceProductFilter>;
};

/** A filter to be used against many `PriceSize` object types. All fields are combined with a logical ‘and.’ */
export type PriceProductToManyPriceSizeFilter = {
  /** Every related `PriceSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PriceSizeFilter>;
  /** Some related `PriceSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PriceSizeFilter>;
  /** No related `PriceSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PriceSizeFilter>;
};

/** A filter to be used against `PriceCategory` object types. All fields are combined with a logical ‘and.’ */
export type PriceCategoryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `categoryName` field. */
  categoryName?: Maybe<StringFilter>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: Maybe<IntFilter>;
  /** Filter by the object’s `priceProductsByCategoryId` relation. */
  priceProductsByCategoryId?: Maybe<PriceCategoryToManyPriceProductFilter>;
  /** Some related `priceProductsByCategoryId` exist. */
  priceProductsByCategoryIdExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PriceCategoryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PriceCategoryFilter>>;
  /** Negates the expression. */
  not?: Maybe<PriceCategoryFilter>;
};

/** A filter to be used against many `PriceProduct` object types. All fields are combined with a logical ‘and.’ */
export type PriceCategoryToManyPriceProductFilter = {
  /** Every related `PriceProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PriceProductFilter>;
  /** Some related `PriceProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PriceProductFilter>;
  /** No related `PriceProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PriceProductFilter>;
};

/** A `PriceSize` edge in the connection. */
export type PriceSizesEdge = {
  __typename?: 'PriceSizesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PriceSize` at the end of the edge. */
  node?: Maybe<PriceSize>;
};

/** Methods to use when ordering `PriceSize`. */
export enum PriceSizesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ProductIdAsc = 'PRODUCT_ID_ASC',
  ProductIdDesc = 'PRODUCT_ID_DESC',
  SizeNameAsc = 'SIZE_NAME_ASC',
  SizeNameDesc = 'SIZE_NAME_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PriceSize` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PriceSizeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `productId` field. */
  productId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sizeName` field. */
  sizeName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: Maybe<Scalars['Int']>;
};

/** A `PriceProduct` edge in the connection. */
export type PriceProductsEdge = {
  __typename?: 'PriceProductsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PriceProduct` at the end of the edge. */
  node?: Maybe<PriceProduct>;
};

/** Methods to use when ordering `PriceProduct`. */
export enum PriceProductsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  ColorAsc = 'COLOR_ASC',
  ColorDesc = 'COLOR_DESC',
  ProductNameAsc = 'PRODUCT_NAME_ASC',
  ProductNameDesc = 'PRODUCT_NAME_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PriceProduct` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PriceProductCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `color` field. */
  color?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productName` field. */
  productName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: Maybe<Scalars['Int']>;
};

/** A `PriceCategory` edge in the connection. */
export type PriceCategoriesEdge = {
  __typename?: 'PriceCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PriceCategory` at the end of the edge. */
  node?: Maybe<PriceCategory>;
};

/** Methods to use when ordering `PriceCategory`. */
export enum PriceCategoriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CategoryNameAsc = 'CATEGORY_NAME_ASC',
  CategoryNameDesc = 'CATEGORY_NAME_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PriceCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PriceCategoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `categoryName` field. */
  categoryName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: Maybe<Scalars['Int']>;
};

/** Methods to use when ordering `InventoryItem`. */
export enum InventoryItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ProductIdAsc = 'PRODUCT_ID_ASC',
  ProductIdDesc = 'PRODUCT_ID_DESC',
  LocationIdAsc = 'LOCATION_ID_ASC',
  LocationIdDesc = 'LOCATION_ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  JvLotNumberAsc = 'JV_LOT_NUMBER_ASC',
  JvLotNumberDesc = 'JV_LOT_NUMBER_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PalletsReceivedAsc = 'PALLETS_RECEIVED_ASC',
  PalletsReceivedDesc = 'PALLETS_RECEIVED_DESC',
  PalletsCommittedAsc = 'PALLETS_COMMITTED_ASC',
  PalletsCommittedDesc = 'PALLETS_COMMITTED_DESC',
  PalletsOnHandAsc = 'PALLETS_ON_HAND_ASC',
  PalletsOnHandDesc = 'PALLETS_ON_HAND_DESC',
  PalletsAvailableAsc = 'PALLETS_AVAILABLE_ASC',
  PalletsAvailableDesc = 'PALLETS_AVAILABLE_DESC',
  PalletsShippedAsc = 'PALLETS_SHIPPED_ASC',
  PalletsShippedDesc = 'PALLETS_SHIPPED_DESC',
  PalletsTransferredInAsc = 'PALLETS_TRANSFERRED_IN_ASC',
  PalletsTransferredInDesc = 'PALLETS_TRANSFERRED_IN_DESC',
  PalletsTransferredOutAsc = 'PALLETS_TRANSFERRED_OUT_ASC',
  PalletsTransferredOutDesc = 'PALLETS_TRANSFERRED_OUT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  SpecialLotNumberAsc = 'SPECIAL_LOT_NUMBER_ASC',
  SpecialLotNumberDesc = 'SPECIAL_LOT_NUMBER_DESC',
  CoastAsc = 'COAST_ASC',
  CoastDesc = 'COAST_DESC',
  StorageRankAsc = 'STORAGE_RANK_ASC',
  StorageRankDesc = 'STORAGE_RANK_DESC',
  WarehouseIdAsc = 'WAREHOUSE_ID_ASC',
  WarehouseIdDesc = 'WAREHOUSE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `InventoryItem` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InventoryItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `productId` field. */
  productId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `jvLotNumber` field. */
  jvLotNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletsReceived` field. */
  palletsReceived?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletsCommitted` field. */
  palletsCommitted?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletsOnHand` field. */
  palletsOnHand?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletsAvailable` field. */
  palletsAvailable?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletsShipped` field. */
  palletsShipped?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletsTransferredIn` field. */
  palletsTransferredIn?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletsTransferredOut` field. */
  palletsTransferredOut?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `specialLotNumber` field. */
  specialLotNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `coast` field. */
  coast?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `storageRank` field. */
  storageRank?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `warehouseId` field. */
  warehouseId?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackAtmosphere` values. */
export type PackAtmospheresConnection = {
  __typename?: 'PackAtmospheresConnection';
  /** A list of `PackAtmosphere` objects. */
  nodes: Array<Maybe<PackAtmosphere>>;
  /** A list of edges which contains the `PackAtmosphere` and cursor to aid in pagination. */
  edges: Array<PackAtmospheresEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackAtmosphere` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackAtmosphere` edge in the connection. */
export type PackAtmospheresEdge = {
  __typename?: 'PackAtmospheresEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackAtmosphere` at the end of the edge. */
  node?: Maybe<PackAtmosphere>;
};

/** Methods to use when ordering `PackAtmosphere`. */
export enum PackAtmospheresOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  MaCodeAsc = 'MA_CODE_ASC',
  MaCodeDesc = 'MA_CODE_DESC',
  MaDescriptionAsc = 'MA_DESCRIPTION_ASC',
  MaDescriptionDesc = 'MA_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackAtmosphere` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PackAtmosphereCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `maCode` field. */
  maCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `maDescription` field. */
  maDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackAtmosphere` object types. All fields are combined with a logical ‘and.’ */
export type PackAtmosphereFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `maCode` field. */
  maCode?: Maybe<StringFilter>;
  /** Filter by the object’s `maDescription` field. */
  maDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackAtmosphereFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackAtmosphereFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackAtmosphereFilter>;
};

/** A connection to a list of `PackBoxStyle` values. */
export type PackBoxStylesConnection = {
  __typename?: 'PackBoxStylesConnection';
  /** A list of `PackBoxStyle` objects. */
  nodes: Array<Maybe<PackBoxStyle>>;
  /** A list of edges which contains the `PackBoxStyle` and cursor to aid in pagination. */
  edges: Array<PackBoxStylesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackBoxStyle` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackBoxStyle` edge in the connection. */
export type PackBoxStylesEdge = {
  __typename?: 'PackBoxStylesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackBoxStyle` at the end of the edge. */
  node?: Maybe<PackBoxStyle>;
};

/** Methods to use when ordering `PackBoxStyle`. */
export enum PackBoxStylesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  BoxStyleAsc = 'BOX_STYLE_ASC',
  BoxStyleDesc = 'BOX_STYLE_DESC',
  BoxDescriptionAsc = 'BOX_DESCRIPTION_ASC',
  BoxDescriptionDesc = 'BOX_DESCRIPTION_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  CombineDescriptionAsc = 'COMBINE_DESCRIPTION_ASC',
  CombineDescriptionDesc = 'COMBINE_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackBoxStyle` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PackBoxStyleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxStyle` field. */
  boxStyle?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxDescription` field. */
  boxDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineDescription` field. */
  combineDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackBoxStyle` object types. All fields are combined with a logical ‘and.’ */
export type PackBoxStyleFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `boxStyle` field. */
  boxStyle?: Maybe<StringFilter>;
  /** Filter by the object’s `boxDescription` field. */
  boxDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Filter by the object’s `combineDescription` field. */
  combineDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackBoxStyleFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackBoxStyleFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackBoxStyleFilter>;
};

/** A connection to a list of `PackBoxType` values. */
export type PackBoxTypesConnection = {
  __typename?: 'PackBoxTypesConnection';
  /** A list of `PackBoxType` objects. */
  nodes: Array<Maybe<PackBoxType>>;
  /** A list of edges which contains the `PackBoxType` and cursor to aid in pagination. */
  edges: Array<PackBoxTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackBoxType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackBoxType` edge in the connection. */
export type PackBoxTypesEdge = {
  __typename?: 'PackBoxTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackBoxType` at the end of the edge. */
  node?: Maybe<PackBoxType>;
};

/** Methods to use when ordering `PackBoxType`. */
export enum PackBoxTypesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  BoxTypeAsc = 'BOX_TYPE_ASC',
  BoxTypeDesc = 'BOX_TYPE_DESC',
  BoxDescriptionAsc = 'BOX_DESCRIPTION_ASC',
  BoxDescriptionDesc = 'BOX_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackBoxType` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackBoxTypeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxType` field. */
  boxType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxDescription` field. */
  boxDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackBoxType` object types. All fields are combined with a logical ‘and.’ */
export type PackBoxTypeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `boxType` field. */
  boxType?: Maybe<StringFilter>;
  /** Filter by the object’s `boxDescription` field. */
  boxDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackBoxTypeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackBoxTypeFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackBoxTypeFilter>;
};

/** A connection to a list of `PackDestination` values. */
export type PackDestinationsConnection = {
  __typename?: 'PackDestinationsConnection';
  /** A list of `PackDestination` objects. */
  nodes: Array<Maybe<PackDestination>>;
  /** A list of edges which contains the `PackDestination` and cursor to aid in pagination. */
  edges: Array<PackDestinationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackDestination` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackDestination` edge in the connection. */
export type PackDestinationsEdge = {
  __typename?: 'PackDestinationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackDestination` at the end of the edge. */
  node?: Maybe<PackDestination>;
};

/** Methods to use when ordering `PackDestination`. */
export enum PackDestinationsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  DestinationCodeAsc = 'DESTINATION_CODE_ASC',
  DestinationCodeDesc = 'DESTINATION_CODE_DESC',
  DestinationDescriptionAsc = 'DESTINATION_DESCRIPTION_ASC',
  DestinationDescriptionDesc = 'DESTINATION_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackDestination` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PackDestinationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `destinationCode` field. */
  destinationCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `destinationDescription` field. */
  destinationDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackDestination` object types. All fields are combined with a logical ‘and.’ */
export type PackDestinationFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `destinationCode` field. */
  destinationCode?: Maybe<StringFilter>;
  /** Filter by the object’s `destinationDescription` field. */
  destinationDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackDestinationFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackDestinationFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackDestinationFilter>;
};

/** A connection to a list of `PackGrade` values. */
export type PackGradesConnection = {
  __typename?: 'PackGradesConnection';
  /** A list of `PackGrade` objects. */
  nodes: Array<Maybe<PackGrade>>;
  /** A list of edges which contains the `PackGrade` and cursor to aid in pagination. */
  edges: Array<PackGradesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackGrade` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackGrade` edge in the connection. */
export type PackGradesEdge = {
  __typename?: 'PackGradesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackGrade` at the end of the edge. */
  node?: Maybe<PackGrade>;
};

/** Methods to use when ordering `PackGrade`. */
export enum PackGradesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  GradeCodeAsc = 'GRADE_CODE_ASC',
  GradeCodeDesc = 'GRADE_CODE_DESC',
  GradeDescriptionAsc = 'GRADE_DESCRIPTION_ASC',
  GradeDescriptionDesc = 'GRADE_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackGrade` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackGradeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `gradeCode` field. */
  gradeCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `gradeDescription` field. */
  gradeDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackGrade` object types. All fields are combined with a logical ‘and.’ */
export type PackGradeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `gradeCode` field. */
  gradeCode?: Maybe<StringFilter>;
  /** Filter by the object’s `gradeDescription` field. */
  gradeDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackGradeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackGradeFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackGradeFilter>;
};

/** A connection to a list of `PackHold` values. */
export type PackHoldsConnection = {
  __typename?: 'PackHoldsConnection';
  /** A list of `PackHold` objects. */
  nodes: Array<Maybe<PackHold>>;
  /** A list of edges which contains the `PackHold` and cursor to aid in pagination. */
  edges: Array<PackHoldsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackHold` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackHold` edge in the connection. */
export type PackHoldsEdge = {
  __typename?: 'PackHoldsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackHold` at the end of the edge. */
  node?: Maybe<PackHold>;
};

/** Methods to use when ordering `PackHold`. */
export enum PackHoldsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  HoldCodeAsc = 'HOLD_CODE_ASC',
  HoldCodeDesc = 'HOLD_CODE_DESC',
  HoldDescriptionAsc = 'HOLD_DESCRIPTION_ASC',
  HoldDescriptionDesc = 'HOLD_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackHold` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackHoldCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `holdCode` field. */
  holdCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `holdDescription` field. */
  holdDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackHold` object types. All fields are combined with a logical ‘and.’ */
export type PackHoldFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `holdCode` field. */
  holdCode?: Maybe<StringFilter>;
  /** Filter by the object’s `holdDescription` field. */
  holdDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackHoldFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackHoldFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackHoldFilter>;
};

/** A connection to a list of `PackLabel` values. */
export type PackLabelsConnection = {
  __typename?: 'PackLabelsConnection';
  /** A list of `PackLabel` objects. */
  nodes: Array<Maybe<PackLabel>>;
  /** A list of edges which contains the `PackLabel` and cursor to aid in pagination. */
  edges: Array<PackLabelsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackLabel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackLabel` edge in the connection. */
export type PackLabelsEdge = {
  __typename?: 'PackLabelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackLabel` at the end of the edge. */
  node?: Maybe<PackLabel>;
};

/** Methods to use when ordering `PackLabel`. */
export enum PackLabelsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  LabelNameAsc = 'LABEL_NAME_ASC',
  LabelNameDesc = 'LABEL_NAME_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  ShipperNameAsc = 'SHIPPER_NAME_ASC',
  ShipperNameDesc = 'SHIPPER_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackLabel` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackLabelCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelName` field. */
  labelName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperName` field. */
  shipperName?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackLabel` object types. All fields are combined with a logical ‘and.’ */
export type PackLabelFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `labelName` field. */
  labelName?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperName` field. */
  shipperName?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackLabelFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackLabelFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackLabelFilter>;
};

/** A connection to a list of `PackLiner` values. */
export type PackLinersConnection = {
  __typename?: 'PackLinersConnection';
  /** A list of `PackLiner` objects. */
  nodes: Array<Maybe<PackLiner>>;
  /** A list of edges which contains the `PackLiner` and cursor to aid in pagination. */
  edges: Array<PackLinersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackLiner` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackLiner` edge in the connection. */
export type PackLinersEdge = {
  __typename?: 'PackLinersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackLiner` at the end of the edge. */
  node?: Maybe<PackLiner>;
};

/** Methods to use when ordering `PackLiner`. */
export enum PackLinersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  LinerCodeAsc = 'LINER_CODE_ASC',
  LinerCodeDesc = 'LINER_CODE_DESC',
  LinerDescriptionAsc = 'LINER_DESCRIPTION_ASC',
  LinerDescriptionDesc = 'LINER_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackLiner` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackLinerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `linerCode` field. */
  linerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `linerDescription` field. */
  linerDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackLiner` object types. All fields are combined with a logical ‘and.’ */
export type PackLinerFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `linerCode` field. */
  linerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `linerDescription` field. */
  linerDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackLinerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackLinerFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackLinerFilter>;
};

/** A connection to a list of `PackMaster` values. */
export type PackMastersConnection = {
  __typename?: 'PackMastersConnection';
  /** A list of `PackMaster` objects. */
  nodes: Array<Maybe<PackMaster>>;
  /** A list of edges which contains the `PackMaster` and cursor to aid in pagination. */
  edges: Array<PackMastersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackMaster` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackMaster` edge in the connection. */
export type PackMastersEdge = {
  __typename?: 'PackMastersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackMaster` at the end of the edge. */
  node?: Maybe<PackMaster>;
};

/** Methods to use when ordering `PackMaster`. */
export enum PackMastersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  LabelCodeIdAsc = 'LABEL_CODE_ID_ASC',
  LabelCodeIdDesc = 'LABEL_CODE_ID_DESC',
  CustomerCodeIdAsc = 'CUSTOMER_CODE_ID_ASC',
  CustomerCodeIdDesc = 'CUSTOMER_CODE_ID_DESC',
  BoxTypeIdAsc = 'BOX_TYPE_ID_ASC',
  BoxTypeIdDesc = 'BOX_TYPE_ID_DESC',
  BoxStyleIdAsc = 'BOX_STYLE_ID_ASC',
  BoxStyleIdDesc = 'BOX_STYLE_ID_DESC',
  PackStyleIdAsc = 'PACK_STYLE_ID_ASC',
  PackStyleIdDesc = 'PACK_STYLE_ID_DESC',
  OutCodeIdAsc = 'OUT_CODE_ID_ASC',
  OutCodeIdDesc = 'OUT_CODE_ID_DESC',
  OutQuantityAsc = 'OUT_QUANTITY_ASC',
  OutQuantityDesc = 'OUT_QUANTITY_DESC',
  OutWeightAsc = 'OUT_WEIGHT_ASC',
  OutWeightDesc = 'OUT_WEIGHT_DESC',
  ProductionCodeIdAsc = 'PRODUCTION_CODE_ID_ASC',
  ProductionCodeIdDesc = 'PRODUCTION_CODE_ID_DESC',
  TreeRipeIdAsc = 'TREE_RIPE_ID_ASC',
  TreeRipeIdDesc = 'TREE_RIPE_ID_DESC',
  GradeCodeIdAsc = 'GRADE_CODE_ID_ASC',
  GradeCodeIdDesc = 'GRADE_CODE_ID_DESC',
  MaCodeIdAsc = 'MA_CODE_ID_ASC',
  MaCodeIdDesc = 'MA_CODE_ID_DESC',
  LinerCodeIdAsc = 'LINER_CODE_ID_ASC',
  LinerCodeIdDesc = 'LINER_CODE_ID_DESC',
  NetWeightContentsAsc = 'NET_WEIGHT_CONTENTS_ASC',
  NetWeightContentsDesc = 'NET_WEIGHT_CONTENTS_DESC',
  NetWeightBoxAsc = 'NET_WEIGHT_BOX_ASC',
  NetWeightBoxDesc = 'NET_WEIGHT_BOX_DESC',
  BoxLengthAsc = 'BOX_LENGTH_ASC',
  BoxLengthDesc = 'BOX_LENGTH_DESC',
  BoxWidthAsc = 'BOX_WIDTH_ASC',
  BoxWidthDesc = 'BOX_WIDTH_DESC',
  BoxHeightAsc = 'BOX_HEIGHT_ASC',
  BoxHeightDesc = 'BOX_HEIGHT_DESC',
  PalletTypeIdAsc = 'PALLET_TYPE_ID_ASC',
  PalletTypeIdDesc = 'PALLET_TYPE_ID_DESC',
  DefaultPalletQuantityAsc = 'DEFAULT_PALLET_QUANTITY_ASC',
  DefaultPalletQuantityDesc = 'DEFAULT_PALLET_QUANTITY_DESC',
  PluUpcCodeAsc = 'PLU_UPC_CODE_ASC',
  PluUpcCodeDesc = 'PLU_UPC_CODE_DESC',
  DestinationCodeIdAsc = 'DESTINATION_CODE_ID_ASC',
  DestinationCodeIdDesc = 'DESTINATION_CODE_ID_DESC',
  OldPackCodeAsc = 'OLD_PACK_CODE_ASC',
  OldPackCodeDesc = 'OLD_PACK_CODE_DESC',
  OldLabelCodeAsc = 'OLD_LABEL_CODE_ASC',
  OldLabelCodeDesc = 'OLD_LABEL_CODE_DESC',
  JvPackCodeAsc = 'JV_PACK_CODE_ASC',
  JvPackCodeDesc = 'JV_PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  VarietyIdAsc = 'VARIETY_ID_ASC',
  VarietyIdDesc = 'VARIETY_ID_DESC',
  SpeciesIdAsc = 'SPECIES_ID_ASC',
  SpeciesIdDesc = 'SPECIES_ID_DESC',
  HoldCodeIdAsc = 'HOLD_CODE_ID_ASC',
  HoldCodeIdDesc = 'HOLD_CODE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackMaster` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackMasterCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCodeId` field. */
  labelCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerCodeId` field. */
  customerCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxTypeId` field. */
  boxTypeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxStyleId` field. */
  boxStyleId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packStyleId` field. */
  packStyleId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `outCodeId` field. */
  outCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `outQuantity` field. */
  outQuantity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `outWeight` field. */
  outWeight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productionCodeId` field. */
  productionCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `treeRipeId` field. */
  treeRipeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `gradeCodeId` field. */
  gradeCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `maCodeId` field. */
  maCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `linerCodeId` field. */
  linerCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `netWeightContents` field. */
  netWeightContents?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `netWeightBox` field. */
  netWeightBox?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `boxLength` field. */
  boxLength?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `boxWidth` field. */
  boxWidth?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `boxHeight` field. */
  boxHeight?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletTypeId` field. */
  palletTypeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultPalletQuantity` field. */
  defaultPalletQuantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `pluUpcCode` field. */
  pluUpcCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `destinationCodeId` field. */
  destinationCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oldPackCode` field. */
  oldPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oldLabelCode` field. */
  oldLabelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `jvPackCode` field. */
  jvPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `varietyId` field. */
  varietyId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `speciesId` field. */
  speciesId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `holdCodeId` field. */
  holdCodeId?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackMaster` object types. All fields are combined with a logical ‘and.’ */
export type PackMasterFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCodeId` field. */
  labelCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `customerCodeId` field. */
  customerCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `boxTypeId` field. */
  boxTypeId?: Maybe<StringFilter>;
  /** Filter by the object’s `boxStyleId` field. */
  boxStyleId?: Maybe<StringFilter>;
  /** Filter by the object’s `packStyleId` field. */
  packStyleId?: Maybe<StringFilter>;
  /** Filter by the object’s `outCodeId` field. */
  outCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `outQuantity` field. */
  outQuantity?: Maybe<StringFilter>;
  /** Filter by the object’s `outWeight` field. */
  outWeight?: Maybe<StringFilter>;
  /** Filter by the object’s `productionCodeId` field. */
  productionCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `treeRipeId` field. */
  treeRipeId?: Maybe<StringFilter>;
  /** Filter by the object’s `gradeCodeId` field. */
  gradeCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `maCodeId` field. */
  maCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `linerCodeId` field. */
  linerCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `netWeightContents` field. */
  netWeightContents?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `netWeightBox` field. */
  netWeightBox?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `boxLength` field. */
  boxLength?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `boxWidth` field. */
  boxWidth?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `boxHeight` field. */
  boxHeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletTypeId` field. */
  palletTypeId?: Maybe<StringFilter>;
  /** Filter by the object’s `defaultPalletQuantity` field. */
  defaultPalletQuantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `pluUpcCode` field. */
  pluUpcCode?: Maybe<StringFilter>;
  /** Filter by the object’s `destinationCodeId` field. */
  destinationCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `oldPackCode` field. */
  oldPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `oldLabelCode` field. */
  oldLabelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `jvPackCode` field. */
  jvPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `varietyId` field. */
  varietyId?: Maybe<StringFilter>;
  /** Filter by the object’s `speciesId` field. */
  speciesId?: Maybe<StringFilter>;
  /** Filter by the object’s `holdCodeId` field. */
  holdCodeId?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackMasterFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackMasterFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackMasterFilter>;
};

/** A connection to a list of `PackOut` values. */
export type PackOutsConnection = {
  __typename?: 'PackOutsConnection';
  /** A list of `PackOut` objects. */
  nodes: Array<Maybe<PackOut>>;
  /** A list of edges which contains the `PackOut` and cursor to aid in pagination. */
  edges: Array<PackOutsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackOut` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackOut` edge in the connection. */
export type PackOutsEdge = {
  __typename?: 'PackOutsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackOut` at the end of the edge. */
  node?: Maybe<PackOut>;
};

/** Methods to use when ordering `PackOut`. */
export enum PackOutsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  OutCodeAsc = 'OUT_CODE_ASC',
  OutCodeDesc = 'OUT_CODE_DESC',
  OutDescriptionAsc = 'OUT_DESCRIPTION_ASC',
  OutDescriptionDesc = 'OUT_DESCRIPTION_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `PackOut` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PackOutCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `outCode` field. */
  outCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `outDescription` field. */
  outDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackOut` object types. All fields are combined with a logical ‘and.’ */
export type PackOutFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `outCode` field. */
  outCode?: Maybe<StringFilter>;
  /** Filter by the object’s `outDescription` field. */
  outDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackOutFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackOutFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackOutFilter>;
};

/** A connection to a list of `PackPalletType` values. */
export type PackPalletTypesConnection = {
  __typename?: 'PackPalletTypesConnection';
  /** A list of `PackPalletType` objects. */
  nodes: Array<Maybe<PackPalletType>>;
  /** A list of edges which contains the `PackPalletType` and cursor to aid in pagination. */
  edges: Array<PackPalletTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackPalletType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackPalletType` edge in the connection. */
export type PackPalletTypesEdge = {
  __typename?: 'PackPalletTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackPalletType` at the end of the edge. */
  node?: Maybe<PackPalletType>;
};

/** Methods to use when ordering `PackPalletType`. */
export enum PackPalletTypesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PalletTypeAsc = 'PALLET_TYPE_ASC',
  PalletTypeDesc = 'PALLET_TYPE_DESC',
  PalletTypeDescriptionAsc = 'PALLET_TYPE_DESCRIPTION_ASC',
  PalletTypeDescriptionDesc = 'PALLET_TYPE_DESCRIPTION_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackPalletType` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PackPalletTypeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletType` field. */
  palletType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletTypeDescription` field. */
  palletTypeDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackPalletType` object types. All fields are combined with a logical ‘and.’ */
export type PackPalletTypeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `palletType` field. */
  palletType?: Maybe<StringFilter>;
  /** Filter by the object’s `palletTypeDescription` field. */
  palletTypeDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackPalletTypeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackPalletTypeFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackPalletTypeFilter>;
};

/** A connection to a list of `PackProduction` values. */
export type PackProductionsConnection = {
  __typename?: 'PackProductionsConnection';
  /** A list of `PackProduction` objects. */
  nodes: Array<Maybe<PackProduction>>;
  /** A list of edges which contains the `PackProduction` and cursor to aid in pagination. */
  edges: Array<PackProductionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackProduction` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackProduction` edge in the connection. */
export type PackProductionsEdge = {
  __typename?: 'PackProductionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackProduction` at the end of the edge. */
  node?: Maybe<PackProduction>;
};

/** Methods to use when ordering `PackProduction`. */
export enum PackProductionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  ProductionCodeAsc = 'PRODUCTION_CODE_ASC',
  ProductionCodeDesc = 'PRODUCTION_CODE_DESC',
  ProductionDescriptionAsc = 'PRODUCTION_DESCRIPTION_ASC',
  ProductionDescriptionDesc = 'PRODUCTION_DESCRIPTION_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackProduction` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PackProductionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productionCode` field. */
  productionCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productionDescription` field. */
  productionDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackProduction` object types. All fields are combined with a logical ‘and.’ */
export type PackProductionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `productionCode` field. */
  productionCode?: Maybe<StringFilter>;
  /** Filter by the object’s `productionDescription` field. */
  productionDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackProductionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackProductionFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackProductionFilter>;
};

/** A connection to a list of `PackSpecial` values. */
export type PackSpecialsConnection = {
  __typename?: 'PackSpecialsConnection';
  /** A list of `PackSpecial` objects. */
  nodes: Array<Maybe<PackSpecial>>;
  /** A list of edges which contains the `PackSpecial` and cursor to aid in pagination. */
  edges: Array<PackSpecialsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackSpecial` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackSpecial` edge in the connection. */
export type PackSpecialsEdge = {
  __typename?: 'PackSpecialsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackSpecial` at the end of the edge. */
  node?: Maybe<PackSpecial>;
};

/** Methods to use when ordering `PackSpecial`. */
export enum PackSpecialsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  CustomerCodeAsc = 'CUSTOMER_CODE_ASC',
  CustomerCodeDesc = 'CUSTOMER_CODE_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  CustomerNameAsc = 'CUSTOMER_NAME_ASC',
  CustomerNameDesc = 'CUSTOMER_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackSpecial` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackSpecialCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerCode` field. */
  customerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerName` field. */
  customerName?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackSpecial` object types. All fields are combined with a logical ‘and.’ */
export type PackSpecialFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `customerCode` field. */
  customerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<StringFilter>;
  /** Filter by the object’s `customerName` field. */
  customerName?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackSpecialFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackSpecialFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackSpecialFilter>;
};

/** A connection to a list of `PackStyle` values. */
export type PackStylesConnection = {
  __typename?: 'PackStylesConnection';
  /** A list of `PackStyle` objects. */
  nodes: Array<Maybe<PackStyle>>;
  /** A list of edges which contains the `PackStyle` and cursor to aid in pagination. */
  edges: Array<PackStylesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackStyle` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackStyle` edge in the connection. */
export type PackStylesEdge = {
  __typename?: 'PackStylesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackStyle` at the end of the edge. */
  node?: Maybe<PackStyle>;
};

/** Methods to use when ordering `PackStyle`. */
export enum PackStylesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PackStyleAsc = 'PACK_STYLE_ASC',
  PackStyleDesc = 'PACK_STYLE_DESC',
  StyleDescriptionAsc = 'STYLE_DESCRIPTION_ASC',
  StyleDescriptionDesc = 'STYLE_DESCRIPTION_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackStyle` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackStyleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packStyle` field. */
  packStyle?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `styleDescription` field. */
  styleDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackStyle` object types. All fields are combined with a logical ‘and.’ */
export type PackStyleFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `packStyle` field. */
  packStyle?: Maybe<StringFilter>;
  /** Filter by the object’s `styleDescription` field. */
  styleDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackStyleFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackStyleFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackStyleFilter>;
};

/** A connection to a list of `PackTreeRipe` values. */
export type PackTreeRipesConnection = {
  __typename?: 'PackTreeRipesConnection';
  /** A list of `PackTreeRipe` objects. */
  nodes: Array<Maybe<PackTreeRipe>>;
  /** A list of edges which contains the `PackTreeRipe` and cursor to aid in pagination. */
  edges: Array<PackTreeRipesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackTreeRipe` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackTreeRipe` edge in the connection. */
export type PackTreeRipesEdge = {
  __typename?: 'PackTreeRipesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackTreeRipe` at the end of the edge. */
  node?: Maybe<PackTreeRipe>;
};

/** Methods to use when ordering `PackTreeRipe`. */
export enum PackTreeRipesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  TreeRipeAsc = 'TREE_RIPE_ASC',
  TreeRipeDesc = 'TREE_RIPE_DESC',
  TreeRipeDescriptionAsc = 'TREE_RIPE_DESCRIPTION_ASC',
  TreeRipeDescriptionDesc = 'TREE_RIPE_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PackTreeRipe` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PackTreeRipeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `treeRipe` field. */
  treeRipe?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `treeRipeDescription` field. */
  treeRipeDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackTreeRipe` object types. All fields are combined with a logical ‘and.’ */
export type PackTreeRipeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `treeRipe` field. */
  treeRipe?: Maybe<StringFilter>;
  /** Filter by the object’s `treeRipeDescription` field. */
  treeRipeDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackTreeRipeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackTreeRipeFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackTreeRipeFilter>;
};

/** Methods to use when ordering `Pallet`. */
export enum PalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  ProductIdAsc = 'PRODUCT_ID_ASC',
  ProductIdDesc = 'PRODUCT_ID_DESC',
  CurrentBoxQuantityAsc = 'CURRENT_BOX_QUANTITY_ASC',
  CurrentBoxQuantityDesc = 'CURRENT_BOX_QUANTITY_DESC',
  ReceivedBoxQuantityAsc = 'RECEIVED_BOX_QUANTITY_ASC',
  ReceivedBoxQuantityDesc = 'RECEIVED_BOX_QUANTITY_DESC',
  ReturnedBoxQuantityAsc = 'RETURNED_BOX_QUANTITY_ASC',
  ReturnedBoxQuantityDesc = 'RETURNED_BOX_QUANTITY_DESC',
  LocationIdAsc = 'LOCATION_ID_ASC',
  LocationIdDesc = 'LOCATION_ID_DESC',
  RoomAsc = 'ROOM_ASC',
  RoomDesc = 'ROOM_DESC',
  SectionAsc = 'SECTION_ASC',
  SectionDesc = 'SECTION_DESC',
  RowAsc = 'ROW_ASC',
  RowDesc = 'ROW_DESC',
  JvLotNumberAsc = 'JV_LOT_NUMBER_ASC',
  JvLotNumberDesc = 'JV_LOT_NUMBER_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  DateTransferredToStorageAsc = 'DATE_TRANSFERRED_TO_STORAGE_ASC',
  DateTransferredToStorageDesc = 'DATE_TRANSFERRED_TO_STORAGE_DESC',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  BackOrderIdAsc = 'BACK_ORDER_ID_ASC',
  BackOrderIdDesc = 'BACK_ORDER_ID_DESC',
  ShippedAsc = 'SHIPPED_ASC',
  ShippedDesc = 'SHIPPED_DESC',
  AgeAsc = 'AGE_ASC',
  AgeDesc = 'AGE_DESC',
  VolumeDiscountCodeAsc = 'VOLUME_DISCOUNT_CODE_ASC',
  VolumeDiscountCodeDesc = 'VOLUME_DISCOUNT_CODE_DESC',
  OriginalLocationIdAsc = 'ORIGINAL_LOCATION_ID_ASC',
  OriginalLocationIdDesc = 'ORIGINAL_LOCATION_ID_DESC',
  FillerAsc = 'FILLER_ASC',
  FillerDesc = 'FILLER_DESC',
  GrowerIdAsc = 'GROWER_ID_ASC',
  GrowerIdDesc = 'GROWER_ID_DESC',
  OldPackCodeAsc = 'OLD_PACK_CODE_ASC',
  OldPackCodeDesc = 'OLD_PACK_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  BillOfLadingAsc = 'BILL_OF_LADING_ASC',
  BillOfLadingDesc = 'BILL_OF_LADING_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  TemperatureRecordingAsc = 'TEMPERATURE_RECORDING_ASC',
  TemperatureRecordingDesc = 'TEMPERATURE_RECORDING_DESC'
}

/** A condition to be used against `Pallet` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productId` field. */
  productId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `currentBoxQuantity` field. */
  currentBoxQuantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `receivedBoxQuantity` field. */
  receivedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `returnedBoxQuantity` field. */
  returnedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `room` field. */
  room?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `section` field. */
  section?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `row` field. */
  row?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `jvLotNumber` field. */
  jvLotNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dateTransferredToStorage` field. */
  dateTransferredToStorage?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `backOrderId` field. */
  backOrderId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipped` field. */
  shipped?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `age` field. */
  age?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `volumeDiscountCode` field. */
  volumeDiscountCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `originalLocationId` field. */
  originalLocationId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `filler` field. */
  filler?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerId` field. */
  growerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oldPackCode` field. */
  oldPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `billOfLading` field. */
  billOfLading?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `temperatureRecording` field. */
  temperatureRecording?: Maybe<Scalars['String']>;
};

/** Methods to use when ordering `PalletSection`. */
export enum PalletSectionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerIdAsc = 'GROWER_ID_ASC',
  GrowerIdDesc = 'GROWER_ID_DESC',
  VarietyIdAsc = 'VARIETY_ID_ASC',
  VarietyIdDesc = 'VARIETY_ID_DESC',
  SizeIdAsc = 'SIZE_ID_ASC',
  SizeIdDesc = 'SIZE_ID_DESC',
  BoxQuantityAsc = 'BOX_QUANTITY_ASC',
  BoxQuantityDesc = 'BOX_QUANTITY_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PalletSection` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PalletSectionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerId` field. */
  growerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `varietyId` field. */
  varietyId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeId` field. */
  sizeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxQuantity` field. */
  boxQuantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PalletTempOne` values. */
export type PalletTempOnesConnection = {
  __typename?: 'PalletTempOnesConnection';
  /** A list of `PalletTempOne` objects. */
  nodes: Array<Maybe<PalletTempOne>>;
  /** A list of edges which contains the `PalletTempOne` and cursor to aid in pagination. */
  edges: Array<PalletTempOnesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PalletTempOne` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PalletTempOne = Node & {
  __typename?: 'PalletTempOne';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  vesselCode: Scalars['String'];
  palletId: Scalars['String'];
  productId?: Maybe<Scalars['String']>;
  currentBoxQuantity?: Maybe<Scalars['BigFloat']>;
  receivedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  returnedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  room?: Maybe<Scalars['String']>;
  section?: Maybe<Scalars['String']>;
  row?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  dateTransferredToStorage?: Maybe<Scalars['Date']>;
  orderId?: Maybe<Scalars['String']>;
  backOrderId?: Maybe<Scalars['String']>;
  shipped?: Maybe<Scalars['Boolean']>;
  age?: Maybe<Scalars['BigFloat']>;
  volumeDiscountCode?: Maybe<Scalars['String']>;
  originalLocationId?: Maybe<Scalars['String']>;
};

/** A `PalletTempOne` edge in the connection. */
export type PalletTempOnesEdge = {
  __typename?: 'PalletTempOnesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PalletTempOne` at the end of the edge. */
  node?: Maybe<PalletTempOne>;
};

/** Methods to use when ordering `PalletTempOne`. */
export enum PalletTempOnesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  ProductIdAsc = 'PRODUCT_ID_ASC',
  ProductIdDesc = 'PRODUCT_ID_DESC',
  CurrentBoxQuantityAsc = 'CURRENT_BOX_QUANTITY_ASC',
  CurrentBoxQuantityDesc = 'CURRENT_BOX_QUANTITY_DESC',
  ReceivedBoxQuantityAsc = 'RECEIVED_BOX_QUANTITY_ASC',
  ReceivedBoxQuantityDesc = 'RECEIVED_BOX_QUANTITY_DESC',
  ReturnedBoxQuantityAsc = 'RETURNED_BOX_QUANTITY_ASC',
  ReturnedBoxQuantityDesc = 'RETURNED_BOX_QUANTITY_DESC',
  LocationIdAsc = 'LOCATION_ID_ASC',
  LocationIdDesc = 'LOCATION_ID_DESC',
  RoomAsc = 'ROOM_ASC',
  RoomDesc = 'ROOM_DESC',
  SectionAsc = 'SECTION_ASC',
  SectionDesc = 'SECTION_DESC',
  RowAsc = 'ROW_ASC',
  RowDesc = 'ROW_DESC',
  JvLotNumberAsc = 'JV_LOT_NUMBER_ASC',
  JvLotNumberDesc = 'JV_LOT_NUMBER_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  DateTransferredToStorageAsc = 'DATE_TRANSFERRED_TO_STORAGE_ASC',
  DateTransferredToStorageDesc = 'DATE_TRANSFERRED_TO_STORAGE_DESC',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  BackOrderIdAsc = 'BACK_ORDER_ID_ASC',
  BackOrderIdDesc = 'BACK_ORDER_ID_DESC',
  ShippedAsc = 'SHIPPED_ASC',
  ShippedDesc = 'SHIPPED_DESC',
  AgeAsc = 'AGE_ASC',
  AgeDesc = 'AGE_DESC',
  VolumeDiscountCodeAsc = 'VOLUME_DISCOUNT_CODE_ASC',
  VolumeDiscountCodeDesc = 'VOLUME_DISCOUNT_CODE_DESC',
  OriginalLocationIdAsc = 'ORIGINAL_LOCATION_ID_ASC',
  OriginalLocationIdDesc = 'ORIGINAL_LOCATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PalletTempOne` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PalletTempOneCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productId` field. */
  productId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `currentBoxQuantity` field. */
  currentBoxQuantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `receivedBoxQuantity` field. */
  receivedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `returnedBoxQuantity` field. */
  returnedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `room` field. */
  room?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `section` field. */
  section?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `row` field. */
  row?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `jvLotNumber` field. */
  jvLotNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dateTransferredToStorage` field. */
  dateTransferredToStorage?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `backOrderId` field. */
  backOrderId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipped` field. */
  shipped?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `age` field. */
  age?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `volumeDiscountCode` field. */
  volumeDiscountCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `originalLocationId` field. */
  originalLocationId?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PalletTempOne` object types. All fields are combined with a logical ‘and.’ */
export type PalletTempOneFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `productId` field. */
  productId?: Maybe<StringFilter>;
  /** Filter by the object’s `currentBoxQuantity` field. */
  currentBoxQuantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `receivedBoxQuantity` field. */
  receivedBoxQuantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `returnedBoxQuantity` field. */
  returnedBoxQuantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `locationId` field. */
  locationId?: Maybe<StringFilter>;
  /** Filter by the object’s `room` field. */
  room?: Maybe<StringFilter>;
  /** Filter by the object’s `section` field. */
  section?: Maybe<StringFilter>;
  /** Filter by the object’s `row` field. */
  row?: Maybe<StringFilter>;
  /** Filter by the object’s `jvLotNumber` field. */
  jvLotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `dateTransferredToStorage` field. */
  dateTransferredToStorage?: Maybe<DateFilter>;
  /** Filter by the object’s `orderId` field. */
  orderId?: Maybe<StringFilter>;
  /** Filter by the object’s `backOrderId` field. */
  backOrderId?: Maybe<StringFilter>;
  /** Filter by the object’s `shipped` field. */
  shipped?: Maybe<BooleanFilter>;
  /** Filter by the object’s `age` field. */
  age?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `volumeDiscountCode` field. */
  volumeDiscountCode?: Maybe<StringFilter>;
  /** Filter by the object’s `originalLocationId` field. */
  originalLocationId?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PalletTempOneFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PalletTempOneFilter>>;
  /** Negates the expression. */
  not?: Maybe<PalletTempOneFilter>;
};

/** A connection to a list of `PalletTempTwo` values. */
export type PalletTempTwosConnection = {
  __typename?: 'PalletTempTwosConnection';
  /** A list of `PalletTempTwo` objects. */
  nodes: Array<Maybe<PalletTempTwo>>;
  /** A list of edges which contains the `PalletTempTwo` and cursor to aid in pagination. */
  edges: Array<PalletTempTwosEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PalletTempTwo` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type PalletTempTwo = Node & {
  __typename?: 'PalletTempTwo';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  filler?: Maybe<Scalars['String']>;
  palletId: Scalars['String'];
  growerId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  billOfLading?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  temperatureRecording?: Maybe<Scalars['String']>;
};

/** A `PalletTempTwo` edge in the connection. */
export type PalletTempTwosEdge = {
  __typename?: 'PalletTempTwosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PalletTempTwo` at the end of the edge. */
  node?: Maybe<PalletTempTwo>;
};

/** Methods to use when ordering `PalletTempTwo`. */
export enum PalletTempTwosOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  FillerAsc = 'FILLER_ASC',
  FillerDesc = 'FILLER_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerIdAsc = 'GROWER_ID_ASC',
  GrowerIdDesc = 'GROWER_ID_DESC',
  OldPackCodeAsc = 'OLD_PACK_CODE_ASC',
  OldPackCodeDesc = 'OLD_PACK_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  BillOfLadingAsc = 'BILL_OF_LADING_ASC',
  BillOfLadingDesc = 'BILL_OF_LADING_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  TemperatureRecordingAsc = 'TEMPERATURE_RECORDING_ASC',
  TemperatureRecordingDesc = 'TEMPERATURE_RECORDING_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `PalletTempTwo` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PalletTempTwoCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `filler` field. */
  filler?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerId` field. */
  growerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oldPackCode` field. */
  oldPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `billOfLading` field. */
  billOfLading?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `temperatureRecording` field. */
  temperatureRecording?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PalletTempTwo` object types. All fields are combined with a logical ‘and.’ */
export type PalletTempTwoFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `filler` field. */
  filler?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerId` field. */
  growerId?: Maybe<StringFilter>;
  /** Filter by the object’s `oldPackCode` field. */
  oldPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `billOfLading` field. */
  billOfLading?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `temperatureRecording` field. */
  temperatureRecording?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PalletTempTwoFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PalletTempTwoFilter>>;
  /** Negates the expression. */
  not?: Maybe<PalletTempTwoFilter>;
};

/** A connection to a list of `ProductMaster` values. */
export type ProductMastersConnection = {
  __typename?: 'ProductMastersConnection';
  /** A list of `ProductMaster` objects. */
  nodes: Array<Maybe<ProductMaster>>;
  /** A list of edges which contains the `ProductMaster` and cursor to aid in pagination. */
  edges: Array<ProductMastersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductMaster` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductMaster` edge in the connection. */
export type ProductMastersEdge = {
  __typename?: 'ProductMastersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductMaster` at the end of the edge. */
  node?: Maybe<ProductMaster>;
};

/** Methods to use when ordering `ProductMaster`. */
export enum ProductMastersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DefaultPalletQuantityAsc = 'DEFAULT_PALLET_QUANTITY_ASC',
  DefaultPalletQuantityDesc = 'DEFAULT_PALLET_QUANTITY_DESC',
  LotNumberAsc = 'LOT_NUMBER_ASC',
  LotNumberDesc = 'LOT_NUMBER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ProductMaster` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ProductMasterCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultPalletQuantity` field. */
  defaultPalletQuantity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotNumber` field. */
  lotNumber?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ProductMaster` object types. All fields are combined with a logical ‘and.’ */
export type ProductMasterFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `defaultPalletQuantity` field. */
  defaultPalletQuantity?: Maybe<StringFilter>;
  /** Filter by the object’s `lotNumber` field. */
  lotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProductMasterFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProductMasterFilter>>;
  /** Negates the expression. */
  not?: Maybe<ProductMasterFilter>;
};

/** Methods to use when ordering `ProductSize`. */
export enum ProductSizesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SpeciesIdAsc = 'SPECIES_ID_ASC',
  SpeciesIdDesc = 'SPECIES_ID_DESC',
  VarietyIdAsc = 'VARIETY_ID_ASC',
  VarietyIdDesc = 'VARIETY_ID_DESC',
  JvCodeAsc = 'JV_CODE_ASC',
  JvCodeDesc = 'JV_CODE_DESC',
  JvDescriptionAsc = 'JV_DESCRIPTION_ASC',
  JvDescriptionDesc = 'JV_DESCRIPTION_DESC',
  ShipperCodeAsc = 'SHIPPER_CODE_ASC',
  ShipperCodeDesc = 'SHIPPER_CODE_DESC',
  ShipperDescriptionAsc = 'SHIPPER_DESCRIPTION_ASC',
  ShipperDescriptionDesc = 'SHIPPER_DESCRIPTION_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  CombineDescriptionAsc = 'COMBINE_DESCRIPTION_ASC',
  CombineDescriptionDesc = 'COMBINE_DESCRIPTION_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ProductSize` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ProductSizeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `speciesId` field. */
  speciesId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `varietyId` field. */
  varietyId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `jvCode` field. */
  jvCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `jvDescription` field. */
  jvDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperCode` field. */
  shipperCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperDescription` field. */
  shipperDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineDescription` field. */
  combineDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
};

/** A connection to a list of `ProductSpecies` values. */
export type ProductSpeciesConnection = {
  __typename?: 'ProductSpeciesConnection';
  /** A list of `ProductSpecies` objects. */
  nodes: Array<Maybe<ProductSpecies>>;
  /** A list of edges which contains the `ProductSpecies` and cursor to aid in pagination. */
  edges: Array<ProductSpeciesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductSpecies` edge in the connection. */
export type ProductSpeciesEdge = {
  __typename?: 'ProductSpeciesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductSpecies` at the end of the edge. */
  node?: Maybe<ProductSpecies>;
};

/** Methods to use when ordering `ProductSpecies`. */
export enum ProductSpeciesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SpeciesDescriptionAsc = 'SPECIES_DESCRIPTION_ASC',
  SpeciesDescriptionDesc = 'SPECIES_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  FdaProductCodeAsc = 'FDA_PRODUCT_CODE_ASC',
  FdaProductCodeDesc = 'FDA_PRODUCT_CODE_DESC',
  FdaIndustryCodeAsc = 'FDA_INDUSTRY_CODE_ASC',
  FdaIndustryCodeDesc = 'FDA_INDUSTRY_CODE_DESC',
  DefaultTemperatureAsc = 'DEFAULT_TEMPERATURE_ASC',
  DefaultTemperatureDesc = 'DEFAULT_TEMPERATURE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ProductSpecies` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ProductSpeciesCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `speciesDescription` field. */
  speciesDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fdaProductCode` field. */
  fdaProductCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fdaIndustryCode` field. */
  fdaIndustryCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultTemperature` field. */
  defaultTemperature?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ProductSpecies` object types. All fields are combined with a logical ‘and.’ */
export type ProductSpeciesFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `speciesDescription` field. */
  speciesDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `fdaProductCode` field. */
  fdaProductCode?: Maybe<StringFilter>;
  /** Filter by the object’s `fdaIndustryCode` field. */
  fdaIndustryCode?: Maybe<StringFilter>;
  /** Filter by the object’s `defaultTemperature` field. */
  defaultTemperature?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProductSpeciesFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProductSpeciesFilter>>;
  /** Negates the expression. */
  not?: Maybe<ProductSpeciesFilter>;
};

/** A connection to a list of `ProductVariety` values. */
export type ProductVarietiesConnection = {
  __typename?: 'ProductVarietiesConnection';
  /** A list of `ProductVariety` objects. */
  nodes: Array<Maybe<ProductVariety>>;
  /** A list of edges which contains the `ProductVariety` and cursor to aid in pagination. */
  edges: Array<ProductVarietiesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductVariety` edge in the connection. */
export type ProductVarietiesEdge = {
  __typename?: 'ProductVarietiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductVariety` at the end of the edge. */
  node?: Maybe<ProductVariety>;
};

/** Methods to use when ordering `ProductVariety`. */
export enum ProductVarietiesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VarietyDescriptionAsc = 'VARIETY_DESCRIPTION_ASC',
  VarietyDescriptionDesc = 'VARIETY_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  CustomerLetterSequenceAsc = 'CUSTOMER_LETTER_SEQUENCE_ASC',
  CustomerLetterSequenceDesc = 'CUSTOMER_LETTER_SEQUENCE_DESC',
  SummaryCodeAsc = 'SUMMARY_CODE_ASC',
  SummaryCodeDesc = 'SUMMARY_CODE_DESC',
  VarietyGroupAsc = 'VARIETY_GROUP_ASC',
  VarietyGroupDesc = 'VARIETY_GROUP_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `ProductVariety` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ProductVarietyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `varietyDescription` field. */
  varietyDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerLetterSequence` field. */
  customerLetterSequence?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `summaryCode` field. */
  summaryCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `varietyGroup` field. */
  varietyGroup?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ProductVariety` object types. All fields are combined with a logical ‘and.’ */
export type ProductVarietyFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `varietyDescription` field. */
  varietyDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `customerLetterSequence` field. */
  customerLetterSequence?: Maybe<StringFilter>;
  /** Filter by the object’s `summaryCode` field. */
  summaryCode?: Maybe<StringFilter>;
  /** Filter by the object’s `varietyGroup` field. */
  varietyGroup?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProductVarietyFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProductVarietyFilter>>;
  /** Negates the expression. */
  not?: Maybe<ProductVarietyFilter>;
};

/** A connection to a list of `Vessel` values. */
export type VesselsConnection = {
  __typename?: 'VesselsConnection';
  /** A list of `Vessel` objects. */
  nodes: Array<Maybe<Vessel>>;
  /** A list of edges which contains the `Vessel` and cursor to aid in pagination. */
  edges: Array<VesselsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Vessel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Vessel` edge in the connection. */
export type VesselsEdge = {
  __typename?: 'VesselsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Vessel` at the end of the edge. */
  node?: Maybe<Vessel>;
};

/** Methods to use when ordering `Vessel`. */
export enum VesselsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  VesselNameAsc = 'VESSEL_NAME_ASC',
  VesselNameDesc = 'VESSEL_NAME_DESC',
  ArrivalPortAsc = 'ARRIVAL_PORT_ASC',
  ArrivalPortDesc = 'ARRIVAL_PORT_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  DepartureDateAsc = 'DEPARTURE_DATE_ASC',
  DepartureDateDesc = 'DEPARTURE_DATE_DESC',
  ArrivalDateAsc = 'ARRIVAL_DATE_ASC',
  ArrivalDateDesc = 'ARRIVAL_DATE_DESC',
  DischargeDateAsc = 'DISCHARGE_DATE_ASC',
  DischargeDateDesc = 'DISCHARGE_DATE_DESC',
  CoastAsc = 'COAST_ASC',
  CoastDesc = 'COAST_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `Vessel` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type VesselCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselName` field. */
  vesselName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrivalPort` field. */
  arrivalPort?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `departureDate` field. */
  departureDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `arrivalDate` field. */
  arrivalDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `dischargeDate` field. */
  dischargeDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `coast` field. */
  coast?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Vessel` object types. All fields are combined with a logical ‘and.’ */
export type VesselFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselName` field. */
  vesselName?: Maybe<StringFilter>;
  /** Filter by the object’s `arrivalPort` field. */
  arrivalPort?: Maybe<StringFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<StringFilter>;
  /** Filter by the object’s `departureDate` field. */
  departureDate?: Maybe<DateFilter>;
  /** Filter by the object’s `arrivalDate` field. */
  arrivalDate?: Maybe<DateFilter>;
  /** Filter by the object’s `dischargeDate` field. */
  dischargeDate?: Maybe<DateFilter>;
  /** Filter by the object’s `coast` field. */
  coast?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VesselFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VesselFilter>>;
  /** Negates the expression. */
  not?: Maybe<VesselFilter>;
};

/** A connection to a list of `String` values. */
export type DistinctValuesConnection = {
  __typename?: 'DistinctValuesConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<DistinctValueEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `String` edge in the connection. */
export type DistinctValueEdge = {
  __typename?: 'DistinctValueEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `String` values. */
export type CustomerDistinctValuesConnection = {
  __typename?: 'CustomerDistinctValuesConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<CustomerDistinctValueEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `String` edge in the connection. */
export type CustomerDistinctValueEdge = {
  __typename?: 'CustomerDistinctValueEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `String` values. */
export type ShipperDistinctValuesConnection = {
  __typename?: 'ShipperDistinctValuesConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ShipperDistinctValueEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `String` edge in the connection. */
export type ShipperDistinctValueEdge = {
  __typename?: 'ShipperDistinctValueEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `ChileDepartureInspection` values. */
export type ChileDepartureInspectionsConnection = {
  __typename?: 'ChileDepartureInspectionsConnection';
  /** A list of `ChileDepartureInspection` objects. */
  nodes: Array<Maybe<ChileDepartureInspection>>;
  /** A list of edges which contains the `ChileDepartureInspection` and cursor to aid in pagination. */
  edges: Array<ChileDepartureInspectionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ChileDepartureInspection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ChileDepartureInspection = {
  __typename?: 'ChileDepartureInspection';
  lotNumber?: Maybe<Scalars['String']>;
  inspectionDate?: Maybe<Scalars['Date']>;
  packingDate?: Maybe<Scalars['String']>;
  shipper?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  avgNetWeight?: Maybe<Scalars['BigFloat']>;
  avgBunchesCount?: Maybe<Scalars['BigFloat']>;
  brixAvg?: Maybe<Scalars['BigFloat']>;
  brixMin?: Maybe<Scalars['BigFloat']>;
  brixMax?: Maybe<Scalars['BigFloat']>;
  searchText?: Maybe<Scalars['String']>;
  imageUrls?: Maybe<Array<Scalars['String']>>;
};

/** A `ChileDepartureInspection` edge in the connection. */
export type ChileDepartureInspectionsEdge = {
  __typename?: 'ChileDepartureInspectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ChileDepartureInspection` at the end of the edge. */
  node?: Maybe<ChileDepartureInspection>;
};

/** A filter to be used against `ChileDepartureInspection` object types. All fields are combined with a logical ‘and.’ */
export type ChileDepartureInspectionFilter = {
  /** Filter by the object’s `lotNumber` field. */
  lotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionDate` field. */
  inspectionDate?: Maybe<DateFilter>;
  /** Filter by the object’s `packingDate` field. */
  packingDate?: Maybe<StringFilter>;
  /** Filter by the object’s `shipper` field. */
  shipper?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `qualityScore` field. */
  qualityScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `conditionScore` field. */
  conditionScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `avgNetWeight` field. */
  avgNetWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `avgBunchesCount` field. */
  avgBunchesCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brixAvg` field. */
  brixAvg?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brixMin` field. */
  brixMin?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brixMax` field. */
  brixMax?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ChileDepartureInspectionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ChileDepartureInspectionFilter>>;
  /** Negates the expression. */
  not?: Maybe<ChileDepartureInspectionFilter>;
};

/** A connection to a list of `String` values. */
export type PsaInspectionVesselDistinctValuesConnection = {
  __typename?: 'PsaInspectionVesselDistinctValuesConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<PsaInspectionVesselDistinctValueEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `String` edge in the connection. */
export type PsaInspectionVesselDistinctValueEdge = {
  __typename?: 'PsaInspectionVesselDistinctValueEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `String` values. */
export type VesselArrivalPortDistinctValuesConnection = {
  __typename?: 'VesselArrivalPortDistinctValuesConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<VesselArrivalPortDistinctValueEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `String` edge in the connection. */
export type VesselArrivalPortDistinctValueEdge = {
  __typename?: 'VesselArrivalPortDistinctValueEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>;
  /** Creates a single `UserMessage`. */
  createUserMessage?: Maybe<CreateUserMessagePayload>;
  /** Creates a single `ContactGroup`. */
  createContactGroup?: Maybe<CreateContactGroupPayload>;
  /** Creates a single `ContactGroupPersonContact`. */
  createContactGroupPersonContact?: Maybe<CreateContactGroupPersonContactPayload>;
  /** Creates a single `Country`. */
  createCountry?: Maybe<CreateCountryPayload>;
  /** Creates a single `Customer`. */
  createCustomer?: Maybe<CreateCustomerPayload>;
  /** Creates a single `CustomerPersonContact`. */
  createCustomerPersonContact?: Maybe<CreateCustomerPersonContactPayload>;
  /** Creates a single `PersonContact`. */
  createPersonContact?: Maybe<CreatePersonContactPayload>;
  /** Creates a single `Shipper`. */
  createShipper?: Maybe<CreateShipperPayload>;
  /** Creates a single `ShipperPersonContact`. */
  createShipperPersonContact?: Maybe<CreateShipperPersonContactPayload>;
  /** Creates a single `Warehouse`. */
  createWarehouse?: Maybe<CreateWarehousePayload>;
  /** Creates a single `WarehousePersonContact`. */
  createWarehousePersonContact?: Maybe<CreateWarehousePersonContactPayload>;
  /** Creates a single `ChileDepartureInspectionPallet`. */
  createChileDepartureInspectionPallet?: Maybe<CreateChileDepartureInspectionPalletPayload>;
  /** Creates a single `PeruDepartureInspection`. */
  createPeruDepartureInspection?: Maybe<CreatePeruDepartureInspectionPayload>;
  /** Creates a single `PeruDepartureInspectionPallet`. */
  createPeruDepartureInspectionPallet?: Maybe<CreatePeruDepartureInspectionPalletPayload>;
  /** Creates a single `PsaApplePallet`. */
  createPsaApplePallet?: Maybe<CreatePsaApplePalletPayload>;
  /** Creates a single `PsaArrivalPicture`. */
  createPsaArrivalPicture?: Maybe<CreatePsaArrivalPicturePayload>;
  /** Creates a single `PsaArrivalReport`. */
  createPsaArrivalReport?: Maybe<CreatePsaArrivalReportPayload>;
  /** Creates a single `PsaCherryPallet`. */
  createPsaCherryPallet?: Maybe<CreatePsaCherryPalletPayload>;
  /** Creates a single `PsaCitrusPallet`. */
  createPsaCitrusPallet?: Maybe<CreatePsaCitrusPalletPayload>;
  /** Creates a single `PsaGrapePallet`. */
  createPsaGrapePallet?: Maybe<CreatePsaGrapePalletPayload>;
  /** Creates a single `PsaLemonPallet`. */
  createPsaLemonPallet?: Maybe<CreatePsaLemonPalletPayload>;
  /** Creates a single `PsaPearPallet`. */
  createPsaPearPallet?: Maybe<CreatePsaPearPalletPayload>;
  /** Creates a single `PsaPersimmonPallet`. */
  createPsaPersimmonPallet?: Maybe<CreatePsaPersimmonPalletPayload>;
  /** Creates a single `PsaPomegranatePallet`. */
  createPsaPomegranatePallet?: Maybe<CreatePsaPomegranatePalletPayload>;
  /** Creates a single `PsaStoneFruitPallet`. */
  createPsaStoneFruitPallet?: Maybe<CreatePsaStoneFruitPalletPayload>;
  /** Creates a single `AgendaItem`. */
  createAgendaItem?: Maybe<CreateAgendaItemPayload>;
  /** Creates a single `CalendarEvent`. */
  createCalendarEvent?: Maybe<CreateCalendarEventPayload>;
  /** Creates a single `PriceCategory`. */
  createPriceCategory?: Maybe<CreatePriceCategoryPayload>;
  /** Creates a single `PriceEntry`. */
  createPriceEntry?: Maybe<CreatePriceEntryPayload>;
  /** Creates a single `PriceProduct`. */
  createPriceProduct?: Maybe<CreatePriceProductPayload>;
  /** Creates a single `PriceSize`. */
  createPriceSize?: Maybe<CreatePriceSizePayload>;
  /** Creates a single `InventoryItem`. */
  createInventoryItem?: Maybe<CreateInventoryItemPayload>;
  /** Creates a single `PackAtmosphere`. */
  createPackAtmosphere?: Maybe<CreatePackAtmospherePayload>;
  /** Creates a single `PackBoxStyle`. */
  createPackBoxStyle?: Maybe<CreatePackBoxStylePayload>;
  /** Creates a single `PackBoxType`. */
  createPackBoxType?: Maybe<CreatePackBoxTypePayload>;
  /** Creates a single `PackDestination`. */
  createPackDestination?: Maybe<CreatePackDestinationPayload>;
  /** Creates a single `PackGrade`. */
  createPackGrade?: Maybe<CreatePackGradePayload>;
  /** Creates a single `PackHold`. */
  createPackHold?: Maybe<CreatePackHoldPayload>;
  /** Creates a single `PackLabel`. */
  createPackLabel?: Maybe<CreatePackLabelPayload>;
  /** Creates a single `PackLiner`. */
  createPackLiner?: Maybe<CreatePackLinerPayload>;
  /** Creates a single `PackMaster`. */
  createPackMaster?: Maybe<CreatePackMasterPayload>;
  /** Creates a single `PackOut`. */
  createPackOut?: Maybe<CreatePackOutPayload>;
  /** Creates a single `PackPalletType`. */
  createPackPalletType?: Maybe<CreatePackPalletTypePayload>;
  /** Creates a single `PackProduction`. */
  createPackProduction?: Maybe<CreatePackProductionPayload>;
  /** Creates a single `PackSpecial`. */
  createPackSpecial?: Maybe<CreatePackSpecialPayload>;
  /** Creates a single `PackStyle`. */
  createPackStyle?: Maybe<CreatePackStylePayload>;
  /** Creates a single `PackTreeRipe`. */
  createPackTreeRipe?: Maybe<CreatePackTreeRipePayload>;
  /** Creates a single `Pallet`. */
  createPallet?: Maybe<CreatePalletPayload>;
  /** Creates a single `PalletSection`. */
  createPalletSection?: Maybe<CreatePalletSectionPayload>;
  /** Creates a single `PalletTempOne`. */
  createPalletTempOne?: Maybe<CreatePalletTempOnePayload>;
  /** Creates a single `PalletTempTwo`. */
  createPalletTempTwo?: Maybe<CreatePalletTempTwoPayload>;
  /** Creates a single `ProductMaster`. */
  createProductMaster?: Maybe<CreateProductMasterPayload>;
  /** Creates a single `ProductSize`. */
  createProductSize?: Maybe<CreateProductSizePayload>;
  /** Creates a single `ProductSpecies`. */
  createProductSpecies?: Maybe<CreateProductSpeciesPayload>;
  /** Creates a single `ProductVariety`. */
  createProductVariety?: Maybe<CreateProductVarietyPayload>;
  /** Creates a single `ShipperProjection`. */
  createShipperProjection?: Maybe<CreateShipperProjectionPayload>;
  /** Creates a single `ShipperProjectionEntry`. */
  createShipperProjectionEntry?: Maybe<CreateShipperProjectionEntryPayload>;
  /** Creates a single `ShipperProjectionProduct`. */
  createShipperProjectionProduct?: Maybe<CreateShipperProjectionProductPayload>;
  /** Creates a single `ShipperProjectionVessel`. */
  createShipperProjectionVessel?: Maybe<CreateShipperProjectionVesselPayload>;
  /** Creates a single `Vessel`. */
  createVessel?: Maybe<CreateVesselPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByPin?: Maybe<UpdateUserPayload>;
  /** Updates a single `UserMessage` using its globally unique id and a patch. */
  updateUserMessageByNodeId?: Maybe<UpdateUserMessagePayload>;
  /** Updates a single `UserMessage` using a unique key and a patch. */
  updateUserMessage?: Maybe<UpdateUserMessagePayload>;
  /** Updates a single `ContactGroup` using its globally unique id and a patch. */
  updateContactGroupByNodeId?: Maybe<UpdateContactGroupPayload>;
  /** Updates a single `ContactGroup` using a unique key and a patch. */
  updateContactGroup?: Maybe<UpdateContactGroupPayload>;
  /** Updates a single `ContactGroupPersonContact` using its globally unique id and a patch. */
  updateContactGroupPersonContactByNodeId?: Maybe<UpdateContactGroupPersonContactPayload>;
  /** Updates a single `ContactGroupPersonContact` using a unique key and a patch. */
  updateContactGroupPersonContact?: Maybe<UpdateContactGroupPersonContactPayload>;
  /** Updates a single `Country` using its globally unique id and a patch. */
  updateCountryByNodeId?: Maybe<UpdateCountryPayload>;
  /** Updates a single `Country` using a unique key and a patch. */
  updateCountry?: Maybe<UpdateCountryPayload>;
  /** Updates a single `Customer` using its globally unique id and a patch. */
  updateCustomerByNodeId?: Maybe<UpdateCustomerPayload>;
  /** Updates a single `Customer` using a unique key and a patch. */
  updateCustomer?: Maybe<UpdateCustomerPayload>;
  /** Updates a single `CustomerPersonContact` using its globally unique id and a patch. */
  updateCustomerPersonContactByNodeId?: Maybe<UpdateCustomerPersonContactPayload>;
  /** Updates a single `CustomerPersonContact` using a unique key and a patch. */
  updateCustomerPersonContact?: Maybe<UpdateCustomerPersonContactPayload>;
  /** Updates a single `PersonContact` using its globally unique id and a patch. */
  updatePersonContactByNodeId?: Maybe<UpdatePersonContactPayload>;
  /** Updates a single `PersonContact` using a unique key and a patch. */
  updatePersonContact?: Maybe<UpdatePersonContactPayload>;
  /** Updates a single `Shipper` using its globally unique id and a patch. */
  updateShipperByNodeId?: Maybe<UpdateShipperPayload>;
  /** Updates a single `Shipper` using a unique key and a patch. */
  updateShipper?: Maybe<UpdateShipperPayload>;
  /** Updates a single `ShipperPersonContact` using its globally unique id and a patch. */
  updateShipperPersonContactByNodeId?: Maybe<UpdateShipperPersonContactPayload>;
  /** Updates a single `ShipperPersonContact` using a unique key and a patch. */
  updateShipperPersonContact?: Maybe<UpdateShipperPersonContactPayload>;
  /** Updates a single `Warehouse` using its globally unique id and a patch. */
  updateWarehouseByNodeId?: Maybe<UpdateWarehousePayload>;
  /** Updates a single `Warehouse` using a unique key and a patch. */
  updateWarehouse?: Maybe<UpdateWarehousePayload>;
  /** Updates a single `WarehousePersonContact` using its globally unique id and a patch. */
  updateWarehousePersonContactByNodeId?: Maybe<UpdateWarehousePersonContactPayload>;
  /** Updates a single `WarehousePersonContact` using a unique key and a patch. */
  updateWarehousePersonContact?: Maybe<UpdateWarehousePersonContactPayload>;
  /** Updates a single `ChileDepartureInspectionPallet` using its globally unique id and a patch. */
  updateChileDepartureInspectionPalletByNodeId?: Maybe<UpdateChileDepartureInspectionPalletPayload>;
  /** Updates a single `ChileDepartureInspectionPallet` using a unique key and a patch. */
  updateChileDepartureInspectionPallet?: Maybe<UpdateChileDepartureInspectionPalletPayload>;
  /** Updates a single `PeruDepartureInspection` using its globally unique id and a patch. */
  updatePeruDepartureInspectionByNodeId?: Maybe<UpdatePeruDepartureInspectionPayload>;
  /** Updates a single `PeruDepartureInspection` using a unique key and a patch. */
  updatePeruDepartureInspection?: Maybe<UpdatePeruDepartureInspectionPayload>;
  /** Updates a single `PeruDepartureInspectionPallet` using its globally unique id and a patch. */
  updatePeruDepartureInspectionPalletByNodeId?: Maybe<UpdatePeruDepartureInspectionPalletPayload>;
  /** Updates a single `PeruDepartureInspectionPallet` using a unique key and a patch. */
  updatePeruDepartureInspectionPallet?: Maybe<UpdatePeruDepartureInspectionPalletPayload>;
  /** Updates a single `PsaApplePallet` using its globally unique id and a patch. */
  updatePsaApplePalletByNodeId?: Maybe<UpdatePsaApplePalletPayload>;
  /** Updates a single `PsaApplePallet` using a unique key and a patch. */
  updatePsaApplePallet?: Maybe<UpdatePsaApplePalletPayload>;
  /** Updates a single `PsaArrivalPicture` using its globally unique id and a patch. */
  updatePsaArrivalPictureByNodeId?: Maybe<UpdatePsaArrivalPicturePayload>;
  /** Updates a single `PsaArrivalPicture` using a unique key and a patch. */
  updatePsaArrivalPicture?: Maybe<UpdatePsaArrivalPicturePayload>;
  /** Updates a single `PsaArrivalReport` using its globally unique id and a patch. */
  updatePsaArrivalReportByNodeId?: Maybe<UpdatePsaArrivalReportPayload>;
  /** Updates a single `PsaArrivalReport` using a unique key and a patch. */
  updatePsaArrivalReport?: Maybe<UpdatePsaArrivalReportPayload>;
  /** Updates a single `PsaCherryPallet` using its globally unique id and a patch. */
  updatePsaCherryPalletByNodeId?: Maybe<UpdatePsaCherryPalletPayload>;
  /** Updates a single `PsaCherryPallet` using a unique key and a patch. */
  updatePsaCherryPallet?: Maybe<UpdatePsaCherryPalletPayload>;
  /** Updates a single `PsaCitrusPallet` using its globally unique id and a patch. */
  updatePsaCitrusPalletByNodeId?: Maybe<UpdatePsaCitrusPalletPayload>;
  /** Updates a single `PsaCitrusPallet` using a unique key and a patch. */
  updatePsaCitrusPallet?: Maybe<UpdatePsaCitrusPalletPayload>;
  /** Updates a single `PsaGrapePallet` using its globally unique id and a patch. */
  updatePsaGrapePalletByNodeId?: Maybe<UpdatePsaGrapePalletPayload>;
  /** Updates a single `PsaGrapePallet` using a unique key and a patch. */
  updatePsaGrapePallet?: Maybe<UpdatePsaGrapePalletPayload>;
  /** Updates a single `PsaLemonPallet` using its globally unique id and a patch. */
  updatePsaLemonPalletByNodeId?: Maybe<UpdatePsaLemonPalletPayload>;
  /** Updates a single `PsaLemonPallet` using a unique key and a patch. */
  updatePsaLemonPallet?: Maybe<UpdatePsaLemonPalletPayload>;
  /** Updates a single `PsaPearPallet` using its globally unique id and a patch. */
  updatePsaPearPalletByNodeId?: Maybe<UpdatePsaPearPalletPayload>;
  /** Updates a single `PsaPearPallet` using a unique key and a patch. */
  updatePsaPearPallet?: Maybe<UpdatePsaPearPalletPayload>;
  /** Updates a single `PsaPersimmonPallet` using its globally unique id and a patch. */
  updatePsaPersimmonPalletByNodeId?: Maybe<UpdatePsaPersimmonPalletPayload>;
  /** Updates a single `PsaPersimmonPallet` using a unique key and a patch. */
  updatePsaPersimmonPallet?: Maybe<UpdatePsaPersimmonPalletPayload>;
  /** Updates a single `PsaPomegranatePallet` using its globally unique id and a patch. */
  updatePsaPomegranatePalletByNodeId?: Maybe<UpdatePsaPomegranatePalletPayload>;
  /** Updates a single `PsaPomegranatePallet` using a unique key and a patch. */
  updatePsaPomegranatePallet?: Maybe<UpdatePsaPomegranatePalletPayload>;
  /** Updates a single `PsaStoneFruitPallet` using its globally unique id and a patch. */
  updatePsaStoneFruitPalletByNodeId?: Maybe<UpdatePsaStoneFruitPalletPayload>;
  /** Updates a single `PsaStoneFruitPallet` using a unique key and a patch. */
  updatePsaStoneFruitPallet?: Maybe<UpdatePsaStoneFruitPalletPayload>;
  /** Updates a single `AgendaItem` using its globally unique id and a patch. */
  updateAgendaItemByNodeId?: Maybe<UpdateAgendaItemPayload>;
  /** Updates a single `AgendaItem` using a unique key and a patch. */
  updateAgendaItem?: Maybe<UpdateAgendaItemPayload>;
  /** Updates a single `CalendarEvent` using its globally unique id and a patch. */
  updateCalendarEventByNodeId?: Maybe<UpdateCalendarEventPayload>;
  /** Updates a single `CalendarEvent` using a unique key and a patch. */
  updateCalendarEvent?: Maybe<UpdateCalendarEventPayload>;
  /** Updates a single `PriceCategory` using its globally unique id and a patch. */
  updatePriceCategoryByNodeId?: Maybe<UpdatePriceCategoryPayload>;
  /** Updates a single `PriceCategory` using a unique key and a patch. */
  updatePriceCategory?: Maybe<UpdatePriceCategoryPayload>;
  /** Updates a single `PriceEntry` using its globally unique id and a patch. */
  updatePriceEntryByNodeId?: Maybe<UpdatePriceEntryPayload>;
  /** Updates a single `PriceEntry` using a unique key and a patch. */
  updatePriceEntry?: Maybe<UpdatePriceEntryPayload>;
  /** Updates a single `PriceProduct` using its globally unique id and a patch. */
  updatePriceProductByNodeId?: Maybe<UpdatePriceProductPayload>;
  /** Updates a single `PriceProduct` using a unique key and a patch. */
  updatePriceProduct?: Maybe<UpdatePriceProductPayload>;
  /** Updates a single `PriceSize` using its globally unique id and a patch. */
  updatePriceSizeByNodeId?: Maybe<UpdatePriceSizePayload>;
  /** Updates a single `PriceSize` using a unique key and a patch. */
  updatePriceSize?: Maybe<UpdatePriceSizePayload>;
  /** Updates a single `InventoryItem` using its globally unique id and a patch. */
  updateInventoryItemByNodeId?: Maybe<UpdateInventoryItemPayload>;
  /** Updates a single `InventoryItem` using a unique key and a patch. */
  updateInventoryItem?: Maybe<UpdateInventoryItemPayload>;
  /** Updates a single `PackAtmosphere` using its globally unique id and a patch. */
  updatePackAtmosphereByNodeId?: Maybe<UpdatePackAtmospherePayload>;
  /** Updates a single `PackAtmosphere` using a unique key and a patch. */
  updatePackAtmosphere?: Maybe<UpdatePackAtmospherePayload>;
  /** Updates a single `PackAtmosphere` using a unique key and a patch. */
  updatePackAtmosphereByShipperIdAndMaCode?: Maybe<UpdatePackAtmospherePayload>;
  /** Updates a single `PackBoxStyle` using its globally unique id and a patch. */
  updatePackBoxStyleByNodeId?: Maybe<UpdatePackBoxStylePayload>;
  /** Updates a single `PackBoxStyle` using a unique key and a patch. */
  updatePackBoxStyle?: Maybe<UpdatePackBoxStylePayload>;
  /** Updates a single `PackBoxStyle` using a unique key and a patch. */
  updatePackBoxStyleByShipperIdAndBoxStyle?: Maybe<UpdatePackBoxStylePayload>;
  /** Updates a single `PackBoxType` using its globally unique id and a patch. */
  updatePackBoxTypeByNodeId?: Maybe<UpdatePackBoxTypePayload>;
  /** Updates a single `PackBoxType` using a unique key and a patch. */
  updatePackBoxType?: Maybe<UpdatePackBoxTypePayload>;
  /** Updates a single `PackBoxType` using a unique key and a patch. */
  updatePackBoxTypeByShipperIdAndBoxType?: Maybe<UpdatePackBoxTypePayload>;
  /** Updates a single `PackDestination` using its globally unique id and a patch. */
  updatePackDestinationByNodeId?: Maybe<UpdatePackDestinationPayload>;
  /** Updates a single `PackDestination` using a unique key and a patch. */
  updatePackDestination?: Maybe<UpdatePackDestinationPayload>;
  /** Updates a single `PackDestination` using a unique key and a patch. */
  updatePackDestinationByShipperIdAndDestinationCode?: Maybe<UpdatePackDestinationPayload>;
  /** Updates a single `PackGrade` using its globally unique id and a patch. */
  updatePackGradeByNodeId?: Maybe<UpdatePackGradePayload>;
  /** Updates a single `PackGrade` using a unique key and a patch. */
  updatePackGrade?: Maybe<UpdatePackGradePayload>;
  /** Updates a single `PackGrade` using a unique key and a patch. */
  updatePackGradeByShipperIdAndGradeCode?: Maybe<UpdatePackGradePayload>;
  /** Updates a single `PackHold` using its globally unique id and a patch. */
  updatePackHoldByNodeId?: Maybe<UpdatePackHoldPayload>;
  /** Updates a single `PackHold` using a unique key and a patch. */
  updatePackHold?: Maybe<UpdatePackHoldPayload>;
  /** Updates a single `PackHold` using a unique key and a patch. */
  updatePackHoldByShipperIdAndHoldCode?: Maybe<UpdatePackHoldPayload>;
  /** Updates a single `PackLabel` using its globally unique id and a patch. */
  updatePackLabelByNodeId?: Maybe<UpdatePackLabelPayload>;
  /** Updates a single `PackLabel` using a unique key and a patch. */
  updatePackLabel?: Maybe<UpdatePackLabelPayload>;
  /** Updates a single `PackLabel` using a unique key and a patch. */
  updatePackLabelByShipperIdAndLabelCode?: Maybe<UpdatePackLabelPayload>;
  /** Updates a single `PackLiner` using its globally unique id and a patch. */
  updatePackLinerByNodeId?: Maybe<UpdatePackLinerPayload>;
  /** Updates a single `PackLiner` using a unique key and a patch. */
  updatePackLiner?: Maybe<UpdatePackLinerPayload>;
  /** Updates a single `PackLiner` using a unique key and a patch. */
  updatePackLinerByShipperIdAndLinerCode?: Maybe<UpdatePackLinerPayload>;
  /** Updates a single `PackMaster` using its globally unique id and a patch. */
  updatePackMasterByNodeId?: Maybe<UpdatePackMasterPayload>;
  /** Updates a single `PackMaster` using a unique key and a patch. */
  updatePackMaster?: Maybe<UpdatePackMasterPayload>;
  /** Updates a single `PackOut` using its globally unique id and a patch. */
  updatePackOutByNodeId?: Maybe<UpdatePackOutPayload>;
  /** Updates a single `PackOut` using a unique key and a patch. */
  updatePackOut?: Maybe<UpdatePackOutPayload>;
  /** Updates a single `PackOut` using a unique key and a patch. */
  updatePackOutByShipperIdAndOutCode?: Maybe<UpdatePackOutPayload>;
  /** Updates a single `PackPalletType` using its globally unique id and a patch. */
  updatePackPalletTypeByNodeId?: Maybe<UpdatePackPalletTypePayload>;
  /** Updates a single `PackPalletType` using a unique key and a patch. */
  updatePackPalletType?: Maybe<UpdatePackPalletTypePayload>;
  /** Updates a single `PackPalletType` using a unique key and a patch. */
  updatePackPalletTypeByShipperIdAndPalletType?: Maybe<UpdatePackPalletTypePayload>;
  /** Updates a single `PackProduction` using its globally unique id and a patch. */
  updatePackProductionByNodeId?: Maybe<UpdatePackProductionPayload>;
  /** Updates a single `PackProduction` using a unique key and a patch. */
  updatePackProduction?: Maybe<UpdatePackProductionPayload>;
  /** Updates a single `PackProduction` using a unique key and a patch. */
  updatePackProductionByShipperIdAndProductionCode?: Maybe<UpdatePackProductionPayload>;
  /** Updates a single `PackSpecial` using its globally unique id and a patch. */
  updatePackSpecialByNodeId?: Maybe<UpdatePackSpecialPayload>;
  /** Updates a single `PackSpecial` using a unique key and a patch. */
  updatePackSpecial?: Maybe<UpdatePackSpecialPayload>;
  /** Updates a single `PackSpecial` using a unique key and a patch. */
  updatePackSpecialByShipperIdAndCustomerCode?: Maybe<UpdatePackSpecialPayload>;
  /** Updates a single `PackStyle` using its globally unique id and a patch. */
  updatePackStyleByNodeId?: Maybe<UpdatePackStylePayload>;
  /** Updates a single `PackStyle` using a unique key and a patch. */
  updatePackStyle?: Maybe<UpdatePackStylePayload>;
  /** Updates a single `PackStyle` using a unique key and a patch. */
  updatePackStyleByShipperIdAndPackStyle?: Maybe<UpdatePackStylePayload>;
  /** Updates a single `PackTreeRipe` using its globally unique id and a patch. */
  updatePackTreeRipeByNodeId?: Maybe<UpdatePackTreeRipePayload>;
  /** Updates a single `PackTreeRipe` using a unique key and a patch. */
  updatePackTreeRipe?: Maybe<UpdatePackTreeRipePayload>;
  /** Updates a single `PackTreeRipe` using a unique key and a patch. */
  updatePackTreeRipeByShipperIdAndTreeRipe?: Maybe<UpdatePackTreeRipePayload>;
  /** Updates a single `PalletSection` using its globally unique id and a patch. */
  updatePalletSectionByNodeId?: Maybe<UpdatePalletSectionPayload>;
  /** Updates a single `PalletSection` using a unique key and a patch. */
  updatePalletSection?: Maybe<UpdatePalletSectionPayload>;
  /** Updates a single `PalletTempOne` using its globally unique id and a patch. */
  updatePalletTempOneByNodeId?: Maybe<UpdatePalletTempOnePayload>;
  /** Updates a single `PalletTempOne` using a unique key and a patch. */
  updatePalletTempOne?: Maybe<UpdatePalletTempOnePayload>;
  /** Updates a single `PalletTempTwo` using its globally unique id and a patch. */
  updatePalletTempTwoByNodeId?: Maybe<UpdatePalletTempTwoPayload>;
  /** Updates a single `PalletTempTwo` using a unique key and a patch. */
  updatePalletTempTwo?: Maybe<UpdatePalletTempTwoPayload>;
  /** Updates a single `ProductMaster` using its globally unique id and a patch. */
  updateProductMasterByNodeId?: Maybe<UpdateProductMasterPayload>;
  /** Updates a single `ProductMaster` using a unique key and a patch. */
  updateProductMaster?: Maybe<UpdateProductMasterPayload>;
  /** Updates a single `ProductSize` using its globally unique id and a patch. */
  updateProductSizeByNodeId?: Maybe<UpdateProductSizePayload>;
  /** Updates a single `ProductSize` using a unique key and a patch. */
  updateProductSize?: Maybe<UpdateProductSizePayload>;
  /** Updates a single `ProductSpecies` using its globally unique id and a patch. */
  updateProductSpeciesByNodeId?: Maybe<UpdateProductSpeciesPayload>;
  /** Updates a single `ProductSpecies` using a unique key and a patch. */
  updateProductSpecies?: Maybe<UpdateProductSpeciesPayload>;
  /** Updates a single `ProductVariety` using its globally unique id and a patch. */
  updateProductVarietyByNodeId?: Maybe<UpdateProductVarietyPayload>;
  /** Updates a single `ProductVariety` using a unique key and a patch. */
  updateProductVariety?: Maybe<UpdateProductVarietyPayload>;
  /** Updates a single `ShipperProjection` using its globally unique id and a patch. */
  updateShipperProjectionByNodeId?: Maybe<UpdateShipperProjectionPayload>;
  /** Updates a single `ShipperProjection` using a unique key and a patch. */
  updateShipperProjection?: Maybe<UpdateShipperProjectionPayload>;
  /** Updates a single `ShipperProjectionEntry` using its globally unique id and a patch. */
  updateShipperProjectionEntryByNodeId?: Maybe<UpdateShipperProjectionEntryPayload>;
  /** Updates a single `ShipperProjectionEntry` using a unique key and a patch. */
  updateShipperProjectionEntry?: Maybe<UpdateShipperProjectionEntryPayload>;
  /** Updates a single `ShipperProjectionProduct` using its globally unique id and a patch. */
  updateShipperProjectionProductByNodeId?: Maybe<UpdateShipperProjectionProductPayload>;
  /** Updates a single `ShipperProjectionProduct` using a unique key and a patch. */
  updateShipperProjectionProduct?: Maybe<UpdateShipperProjectionProductPayload>;
  /** Updates a single `ShipperProjectionVessel` using its globally unique id and a patch. */
  updateShipperProjectionVesselByNodeId?: Maybe<UpdateShipperProjectionVesselPayload>;
  /** Updates a single `ShipperProjectionVessel` using a unique key and a patch. */
  updateShipperProjectionVessel?: Maybe<UpdateShipperProjectionVesselPayload>;
  /** Updates a single `Vessel` using its globally unique id and a patch. */
  updateVesselByNodeId?: Maybe<UpdateVesselPayload>;
  /** Updates a single `Vessel` using a unique key and a patch. */
  updateVessel?: Maybe<UpdateVesselPayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserByPin?: Maybe<DeleteUserPayload>;
  /** Deletes a single `UserMessage` using its globally unique id. */
  deleteUserMessageByNodeId?: Maybe<DeleteUserMessagePayload>;
  /** Deletes a single `UserMessage` using a unique key. */
  deleteUserMessage?: Maybe<DeleteUserMessagePayload>;
  /** Deletes a single `ContactGroup` using its globally unique id. */
  deleteContactGroupByNodeId?: Maybe<DeleteContactGroupPayload>;
  /** Deletes a single `ContactGroup` using a unique key. */
  deleteContactGroup?: Maybe<DeleteContactGroupPayload>;
  /** Deletes a single `ContactGroupPersonContact` using its globally unique id. */
  deleteContactGroupPersonContactByNodeId?: Maybe<DeleteContactGroupPersonContactPayload>;
  /** Deletes a single `ContactGroupPersonContact` using a unique key. */
  deleteContactGroupPersonContact?: Maybe<DeleteContactGroupPersonContactPayload>;
  /** Deletes a single `Country` using its globally unique id. */
  deleteCountryByNodeId?: Maybe<DeleteCountryPayload>;
  /** Deletes a single `Country` using a unique key. */
  deleteCountry?: Maybe<DeleteCountryPayload>;
  /** Deletes a single `Customer` using its globally unique id. */
  deleteCustomerByNodeId?: Maybe<DeleteCustomerPayload>;
  /** Deletes a single `Customer` using a unique key. */
  deleteCustomer?: Maybe<DeleteCustomerPayload>;
  /** Deletes a single `CustomerPersonContact` using its globally unique id. */
  deleteCustomerPersonContactByNodeId?: Maybe<DeleteCustomerPersonContactPayload>;
  /** Deletes a single `CustomerPersonContact` using a unique key. */
  deleteCustomerPersonContact?: Maybe<DeleteCustomerPersonContactPayload>;
  /** Deletes a single `PersonContact` using its globally unique id. */
  deletePersonContactByNodeId?: Maybe<DeletePersonContactPayload>;
  /** Deletes a single `PersonContact` using a unique key. */
  deletePersonContact?: Maybe<DeletePersonContactPayload>;
  /** Deletes a single `Shipper` using its globally unique id. */
  deleteShipperByNodeId?: Maybe<DeleteShipperPayload>;
  /** Deletes a single `Shipper` using a unique key. */
  deleteShipper?: Maybe<DeleteShipperPayload>;
  /** Deletes a single `ShipperPersonContact` using its globally unique id. */
  deleteShipperPersonContactByNodeId?: Maybe<DeleteShipperPersonContactPayload>;
  /** Deletes a single `ShipperPersonContact` using a unique key. */
  deleteShipperPersonContact?: Maybe<DeleteShipperPersonContactPayload>;
  /** Deletes a single `Warehouse` using its globally unique id. */
  deleteWarehouseByNodeId?: Maybe<DeleteWarehousePayload>;
  /** Deletes a single `Warehouse` using a unique key. */
  deleteWarehouse?: Maybe<DeleteWarehousePayload>;
  /** Deletes a single `WarehousePersonContact` using its globally unique id. */
  deleteWarehousePersonContactByNodeId?: Maybe<DeleteWarehousePersonContactPayload>;
  /** Deletes a single `WarehousePersonContact` using a unique key. */
  deleteWarehousePersonContact?: Maybe<DeleteWarehousePersonContactPayload>;
  /** Deletes a single `ChileDepartureInspectionPallet` using its globally unique id. */
  deleteChileDepartureInspectionPalletByNodeId?: Maybe<DeleteChileDepartureInspectionPalletPayload>;
  /** Deletes a single `ChileDepartureInspectionPallet` using a unique key. */
  deleteChileDepartureInspectionPallet?: Maybe<DeleteChileDepartureInspectionPalletPayload>;
  /** Deletes a single `PeruDepartureInspection` using its globally unique id. */
  deletePeruDepartureInspectionByNodeId?: Maybe<DeletePeruDepartureInspectionPayload>;
  /** Deletes a single `PeruDepartureInspection` using a unique key. */
  deletePeruDepartureInspection?: Maybe<DeletePeruDepartureInspectionPayload>;
  /** Deletes a single `PeruDepartureInspectionPallet` using its globally unique id. */
  deletePeruDepartureInspectionPalletByNodeId?: Maybe<DeletePeruDepartureInspectionPalletPayload>;
  /** Deletes a single `PeruDepartureInspectionPallet` using a unique key. */
  deletePeruDepartureInspectionPallet?: Maybe<DeletePeruDepartureInspectionPalletPayload>;
  /** Deletes a single `PsaApplePallet` using its globally unique id. */
  deletePsaApplePalletByNodeId?: Maybe<DeletePsaApplePalletPayload>;
  /** Deletes a single `PsaApplePallet` using a unique key. */
  deletePsaApplePallet?: Maybe<DeletePsaApplePalletPayload>;
  /** Deletes a single `PsaArrivalPicture` using its globally unique id. */
  deletePsaArrivalPictureByNodeId?: Maybe<DeletePsaArrivalPicturePayload>;
  /** Deletes a single `PsaArrivalPicture` using a unique key. */
  deletePsaArrivalPicture?: Maybe<DeletePsaArrivalPicturePayload>;
  /** Deletes a single `PsaArrivalReport` using its globally unique id. */
  deletePsaArrivalReportByNodeId?: Maybe<DeletePsaArrivalReportPayload>;
  /** Deletes a single `PsaArrivalReport` using a unique key. */
  deletePsaArrivalReport?: Maybe<DeletePsaArrivalReportPayload>;
  /** Deletes a single `PsaCherryPallet` using its globally unique id. */
  deletePsaCherryPalletByNodeId?: Maybe<DeletePsaCherryPalletPayload>;
  /** Deletes a single `PsaCherryPallet` using a unique key. */
  deletePsaCherryPallet?: Maybe<DeletePsaCherryPalletPayload>;
  /** Deletes a single `PsaCitrusPallet` using its globally unique id. */
  deletePsaCitrusPalletByNodeId?: Maybe<DeletePsaCitrusPalletPayload>;
  /** Deletes a single `PsaCitrusPallet` using a unique key. */
  deletePsaCitrusPallet?: Maybe<DeletePsaCitrusPalletPayload>;
  /** Deletes a single `PsaGrapePallet` using its globally unique id. */
  deletePsaGrapePalletByNodeId?: Maybe<DeletePsaGrapePalletPayload>;
  /** Deletes a single `PsaGrapePallet` using a unique key. */
  deletePsaGrapePallet?: Maybe<DeletePsaGrapePalletPayload>;
  /** Deletes a single `PsaLemonPallet` using its globally unique id. */
  deletePsaLemonPalletByNodeId?: Maybe<DeletePsaLemonPalletPayload>;
  /** Deletes a single `PsaLemonPallet` using a unique key. */
  deletePsaLemonPallet?: Maybe<DeletePsaLemonPalletPayload>;
  /** Deletes a single `PsaPearPallet` using its globally unique id. */
  deletePsaPearPalletByNodeId?: Maybe<DeletePsaPearPalletPayload>;
  /** Deletes a single `PsaPearPallet` using a unique key. */
  deletePsaPearPallet?: Maybe<DeletePsaPearPalletPayload>;
  /** Deletes a single `PsaPersimmonPallet` using its globally unique id. */
  deletePsaPersimmonPalletByNodeId?: Maybe<DeletePsaPersimmonPalletPayload>;
  /** Deletes a single `PsaPersimmonPallet` using a unique key. */
  deletePsaPersimmonPallet?: Maybe<DeletePsaPersimmonPalletPayload>;
  /** Deletes a single `PsaPomegranatePallet` using its globally unique id. */
  deletePsaPomegranatePalletByNodeId?: Maybe<DeletePsaPomegranatePalletPayload>;
  /** Deletes a single `PsaPomegranatePallet` using a unique key. */
  deletePsaPomegranatePallet?: Maybe<DeletePsaPomegranatePalletPayload>;
  /** Deletes a single `PsaStoneFruitPallet` using its globally unique id. */
  deletePsaStoneFruitPalletByNodeId?: Maybe<DeletePsaStoneFruitPalletPayload>;
  /** Deletes a single `PsaStoneFruitPallet` using a unique key. */
  deletePsaStoneFruitPallet?: Maybe<DeletePsaStoneFruitPalletPayload>;
  /** Deletes a single `AgendaItem` using its globally unique id. */
  deleteAgendaItemByNodeId?: Maybe<DeleteAgendaItemPayload>;
  /** Deletes a single `AgendaItem` using a unique key. */
  deleteAgendaItem?: Maybe<DeleteAgendaItemPayload>;
  /** Deletes a single `CalendarEvent` using its globally unique id. */
  deleteCalendarEventByNodeId?: Maybe<DeleteCalendarEventPayload>;
  /** Deletes a single `CalendarEvent` using a unique key. */
  deleteCalendarEvent?: Maybe<DeleteCalendarEventPayload>;
  /** Deletes a single `PriceCategory` using its globally unique id. */
  deletePriceCategoryByNodeId?: Maybe<DeletePriceCategoryPayload>;
  /** Deletes a single `PriceCategory` using a unique key. */
  deletePriceCategory?: Maybe<DeletePriceCategoryPayload>;
  /** Deletes a single `PriceEntry` using its globally unique id. */
  deletePriceEntryByNodeId?: Maybe<DeletePriceEntryPayload>;
  /** Deletes a single `PriceEntry` using a unique key. */
  deletePriceEntry?: Maybe<DeletePriceEntryPayload>;
  /** Deletes a single `PriceProduct` using its globally unique id. */
  deletePriceProductByNodeId?: Maybe<DeletePriceProductPayload>;
  /** Deletes a single `PriceProduct` using a unique key. */
  deletePriceProduct?: Maybe<DeletePriceProductPayload>;
  /** Deletes a single `PriceSize` using its globally unique id. */
  deletePriceSizeByNodeId?: Maybe<DeletePriceSizePayload>;
  /** Deletes a single `PriceSize` using a unique key. */
  deletePriceSize?: Maybe<DeletePriceSizePayload>;
  /** Deletes a single `InventoryItem` using its globally unique id. */
  deleteInventoryItemByNodeId?: Maybe<DeleteInventoryItemPayload>;
  /** Deletes a single `InventoryItem` using a unique key. */
  deleteInventoryItem?: Maybe<DeleteInventoryItemPayload>;
  /** Deletes a single `PackAtmosphere` using its globally unique id. */
  deletePackAtmosphereByNodeId?: Maybe<DeletePackAtmospherePayload>;
  /** Deletes a single `PackAtmosphere` using a unique key. */
  deletePackAtmosphere?: Maybe<DeletePackAtmospherePayload>;
  /** Deletes a single `PackAtmosphere` using a unique key. */
  deletePackAtmosphereByShipperIdAndMaCode?: Maybe<DeletePackAtmospherePayload>;
  /** Deletes a single `PackBoxStyle` using its globally unique id. */
  deletePackBoxStyleByNodeId?: Maybe<DeletePackBoxStylePayload>;
  /** Deletes a single `PackBoxStyle` using a unique key. */
  deletePackBoxStyle?: Maybe<DeletePackBoxStylePayload>;
  /** Deletes a single `PackBoxStyle` using a unique key. */
  deletePackBoxStyleByShipperIdAndBoxStyle?: Maybe<DeletePackBoxStylePayload>;
  /** Deletes a single `PackBoxType` using its globally unique id. */
  deletePackBoxTypeByNodeId?: Maybe<DeletePackBoxTypePayload>;
  /** Deletes a single `PackBoxType` using a unique key. */
  deletePackBoxType?: Maybe<DeletePackBoxTypePayload>;
  /** Deletes a single `PackBoxType` using a unique key. */
  deletePackBoxTypeByShipperIdAndBoxType?: Maybe<DeletePackBoxTypePayload>;
  /** Deletes a single `PackDestination` using its globally unique id. */
  deletePackDestinationByNodeId?: Maybe<DeletePackDestinationPayload>;
  /** Deletes a single `PackDestination` using a unique key. */
  deletePackDestination?: Maybe<DeletePackDestinationPayload>;
  /** Deletes a single `PackDestination` using a unique key. */
  deletePackDestinationByShipperIdAndDestinationCode?: Maybe<DeletePackDestinationPayload>;
  /** Deletes a single `PackGrade` using its globally unique id. */
  deletePackGradeByNodeId?: Maybe<DeletePackGradePayload>;
  /** Deletes a single `PackGrade` using a unique key. */
  deletePackGrade?: Maybe<DeletePackGradePayload>;
  /** Deletes a single `PackGrade` using a unique key. */
  deletePackGradeByShipperIdAndGradeCode?: Maybe<DeletePackGradePayload>;
  /** Deletes a single `PackHold` using its globally unique id. */
  deletePackHoldByNodeId?: Maybe<DeletePackHoldPayload>;
  /** Deletes a single `PackHold` using a unique key. */
  deletePackHold?: Maybe<DeletePackHoldPayload>;
  /** Deletes a single `PackHold` using a unique key. */
  deletePackHoldByShipperIdAndHoldCode?: Maybe<DeletePackHoldPayload>;
  /** Deletes a single `PackLabel` using its globally unique id. */
  deletePackLabelByNodeId?: Maybe<DeletePackLabelPayload>;
  /** Deletes a single `PackLabel` using a unique key. */
  deletePackLabel?: Maybe<DeletePackLabelPayload>;
  /** Deletes a single `PackLabel` using a unique key. */
  deletePackLabelByShipperIdAndLabelCode?: Maybe<DeletePackLabelPayload>;
  /** Deletes a single `PackLiner` using its globally unique id. */
  deletePackLinerByNodeId?: Maybe<DeletePackLinerPayload>;
  /** Deletes a single `PackLiner` using a unique key. */
  deletePackLiner?: Maybe<DeletePackLinerPayload>;
  /** Deletes a single `PackLiner` using a unique key. */
  deletePackLinerByShipperIdAndLinerCode?: Maybe<DeletePackLinerPayload>;
  /** Deletes a single `PackMaster` using its globally unique id. */
  deletePackMasterByNodeId?: Maybe<DeletePackMasterPayload>;
  /** Deletes a single `PackMaster` using a unique key. */
  deletePackMaster?: Maybe<DeletePackMasterPayload>;
  /** Deletes a single `PackOut` using its globally unique id. */
  deletePackOutByNodeId?: Maybe<DeletePackOutPayload>;
  /** Deletes a single `PackOut` using a unique key. */
  deletePackOut?: Maybe<DeletePackOutPayload>;
  /** Deletes a single `PackOut` using a unique key. */
  deletePackOutByShipperIdAndOutCode?: Maybe<DeletePackOutPayload>;
  /** Deletes a single `PackPalletType` using its globally unique id. */
  deletePackPalletTypeByNodeId?: Maybe<DeletePackPalletTypePayload>;
  /** Deletes a single `PackPalletType` using a unique key. */
  deletePackPalletType?: Maybe<DeletePackPalletTypePayload>;
  /** Deletes a single `PackPalletType` using a unique key. */
  deletePackPalletTypeByShipperIdAndPalletType?: Maybe<DeletePackPalletTypePayload>;
  /** Deletes a single `PackProduction` using its globally unique id. */
  deletePackProductionByNodeId?: Maybe<DeletePackProductionPayload>;
  /** Deletes a single `PackProduction` using a unique key. */
  deletePackProduction?: Maybe<DeletePackProductionPayload>;
  /** Deletes a single `PackProduction` using a unique key. */
  deletePackProductionByShipperIdAndProductionCode?: Maybe<DeletePackProductionPayload>;
  /** Deletes a single `PackSpecial` using its globally unique id. */
  deletePackSpecialByNodeId?: Maybe<DeletePackSpecialPayload>;
  /** Deletes a single `PackSpecial` using a unique key. */
  deletePackSpecial?: Maybe<DeletePackSpecialPayload>;
  /** Deletes a single `PackSpecial` using a unique key. */
  deletePackSpecialByShipperIdAndCustomerCode?: Maybe<DeletePackSpecialPayload>;
  /** Deletes a single `PackStyle` using its globally unique id. */
  deletePackStyleByNodeId?: Maybe<DeletePackStylePayload>;
  /** Deletes a single `PackStyle` using a unique key. */
  deletePackStyle?: Maybe<DeletePackStylePayload>;
  /** Deletes a single `PackStyle` using a unique key. */
  deletePackStyleByShipperIdAndPackStyle?: Maybe<DeletePackStylePayload>;
  /** Deletes a single `PackTreeRipe` using its globally unique id. */
  deletePackTreeRipeByNodeId?: Maybe<DeletePackTreeRipePayload>;
  /** Deletes a single `PackTreeRipe` using a unique key. */
  deletePackTreeRipe?: Maybe<DeletePackTreeRipePayload>;
  /** Deletes a single `PackTreeRipe` using a unique key. */
  deletePackTreeRipeByShipperIdAndTreeRipe?: Maybe<DeletePackTreeRipePayload>;
  /** Deletes a single `PalletSection` using its globally unique id. */
  deletePalletSectionByNodeId?: Maybe<DeletePalletSectionPayload>;
  /** Deletes a single `PalletSection` using a unique key. */
  deletePalletSection?: Maybe<DeletePalletSectionPayload>;
  /** Deletes a single `PalletTempOne` using its globally unique id. */
  deletePalletTempOneByNodeId?: Maybe<DeletePalletTempOnePayload>;
  /** Deletes a single `PalletTempOne` using a unique key. */
  deletePalletTempOne?: Maybe<DeletePalletTempOnePayload>;
  /** Deletes a single `PalletTempTwo` using its globally unique id. */
  deletePalletTempTwoByNodeId?: Maybe<DeletePalletTempTwoPayload>;
  /** Deletes a single `PalletTempTwo` using a unique key. */
  deletePalletTempTwo?: Maybe<DeletePalletTempTwoPayload>;
  /** Deletes a single `ProductMaster` using its globally unique id. */
  deleteProductMasterByNodeId?: Maybe<DeleteProductMasterPayload>;
  /** Deletes a single `ProductMaster` using a unique key. */
  deleteProductMaster?: Maybe<DeleteProductMasterPayload>;
  /** Deletes a single `ProductSize` using its globally unique id. */
  deleteProductSizeByNodeId?: Maybe<DeleteProductSizePayload>;
  /** Deletes a single `ProductSize` using a unique key. */
  deleteProductSize?: Maybe<DeleteProductSizePayload>;
  /** Deletes a single `ProductSpecies` using its globally unique id. */
  deleteProductSpeciesByNodeId?: Maybe<DeleteProductSpeciesPayload>;
  /** Deletes a single `ProductSpecies` using a unique key. */
  deleteProductSpecies?: Maybe<DeleteProductSpeciesPayload>;
  /** Deletes a single `ProductVariety` using its globally unique id. */
  deleteProductVarietyByNodeId?: Maybe<DeleteProductVarietyPayload>;
  /** Deletes a single `ProductVariety` using a unique key. */
  deleteProductVariety?: Maybe<DeleteProductVarietyPayload>;
  /** Deletes a single `ShipperProjection` using its globally unique id. */
  deleteShipperProjectionByNodeId?: Maybe<DeleteShipperProjectionPayload>;
  /** Deletes a single `ShipperProjection` using a unique key. */
  deleteShipperProjection?: Maybe<DeleteShipperProjectionPayload>;
  /** Deletes a single `ShipperProjectionEntry` using its globally unique id. */
  deleteShipperProjectionEntryByNodeId?: Maybe<DeleteShipperProjectionEntryPayload>;
  /** Deletes a single `ShipperProjectionEntry` using a unique key. */
  deleteShipperProjectionEntry?: Maybe<DeleteShipperProjectionEntryPayload>;
  /** Deletes a single `ShipperProjectionProduct` using its globally unique id. */
  deleteShipperProjectionProductByNodeId?: Maybe<DeleteShipperProjectionProductPayload>;
  /** Deletes a single `ShipperProjectionProduct` using a unique key. */
  deleteShipperProjectionProduct?: Maybe<DeleteShipperProjectionProductPayload>;
  /** Deletes a single `ShipperProjectionVessel` using its globally unique id. */
  deleteShipperProjectionVesselByNodeId?: Maybe<DeleteShipperProjectionVesselPayload>;
  /** Deletes a single `ShipperProjectionVessel` using a unique key. */
  deleteShipperProjectionVessel?: Maybe<DeleteShipperProjectionVesselPayload>;
  /** Deletes a single `Vessel` using its globally unique id. */
  deleteVesselByNodeId?: Maybe<DeleteVesselPayload>;
  /** Deletes a single `Vessel` using a unique key. */
  deleteVessel?: Maybe<DeleteVesselPayload>;
  bulkCreateUserMessage?: Maybe<BulkCreateUserMessagePayload>;
  bulkAddContactsToGroup?: Maybe<BulkAddContactsToGroupPayload>;
  bulkRemoveContactGroupPersonContact?: Maybe<BulkRemoveContactGroupPersonContactPayload>;
  batchCreateChileDepartureInspectionPallet?: Maybe<BatchCreateChileDepartureInspectionPalletPayload>;
  batchCreatePsaApplePallet?: Maybe<BatchCreatePsaApplePalletPayload>;
  batchCreatePsaCherryPallet?: Maybe<BatchCreatePsaCherryPalletPayload>;
  batchCreatePsaCitrusPallet?: Maybe<BatchCreatePsaCitrusPalletPayload>;
  batchCreatePsaGrapePallet?: Maybe<BatchCreatePsaGrapePalletPayload>;
  batchCreatePsaLemonPallet?: Maybe<BatchCreatePsaLemonPalletPayload>;
  batchCreatePsaPearPallet?: Maybe<BatchCreatePsaPearPalletPayload>;
  batchCreatePsaPersimmonPallet?: Maybe<BatchCreatePsaPersimmonPalletPayload>;
  batchCreatePsaPomegranatePallet?: Maybe<BatchCreatePsaPomegranatePalletPayload>;
  batchCreatePsaStoneFruitPallet?: Maybe<BatchCreatePsaStoneFruitPalletPayload>;
  bulkUpsertAgendaItem?: Maybe<BulkUpsertAgendaItemPayload>;
  bulkUpsertPriceCategory?: Maybe<BulkUpsertPriceCategoryPayload>;
  bulkUpsertPriceEntry?: Maybe<BulkUpsertPriceEntryPayload>;
  bulkUpsertPriceProduct?: Maybe<BulkUpsertPriceProductPayload>;
  bulkUpsertPriceSize?: Maybe<BulkUpsertPriceSizePayload>;
  deletePriceCategoryEntries?: Maybe<DeletePriceCategoryEntriesPayload>;
  deletePriceProductEntries?: Maybe<DeletePriceProductEntriesPayload>;
  deletePriceSizeEntries?: Maybe<DeletePriceSizeEntriesPayload>;
  bulkDeleteShipperProjectionEntry?: Maybe<BulkDeleteShipperProjectionEntryPayload>;
  bulkDeleteShipperProjectionProduct?: Maybe<BulkDeleteShipperProjectionProductPayload>;
  bulkUpsertShipperProjectionEntry?: Maybe<BulkUpsertShipperProjectionEntryPayload>;
  bulkUpsertShipperProjectionProduct?: Maybe<BulkUpsertShipperProjectionProductPayload>;
  bulkUpsertShipperProjectionVessel?: Maybe<BulkUpsertShipperProjectionVesselPayload>;
  upsertShipperProjection?: Maybe<UpsertShipperProjectionPayload>;
  sendPriceSheetUpdateEmail: Scalars['String'];
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserMessageArgs = {
  input: CreateUserMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateContactGroupArgs = {
  input: CreateContactGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateContactGroupPersonContactArgs = {
  input: CreateContactGroupPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCountryArgs = {
  input: CreateCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCustomerArgs = {
  input: CreateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCustomerPersonContactArgs = {
  input: CreateCustomerPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePersonContactArgs = {
  input: CreatePersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperArgs = {
  input: CreateShipperInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperPersonContactArgs = {
  input: CreateShipperPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWarehouseArgs = {
  input: CreateWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWarehousePersonContactArgs = {
  input: CreateWarehousePersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateChileDepartureInspectionPalletArgs = {
  input: CreateChileDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePeruDepartureInspectionArgs = {
  input: CreatePeruDepartureInspectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePeruDepartureInspectionPalletArgs = {
  input: CreatePeruDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaApplePalletArgs = {
  input: CreatePsaApplePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaArrivalPictureArgs = {
  input: CreatePsaArrivalPictureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaArrivalReportArgs = {
  input: CreatePsaArrivalReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaCherryPalletArgs = {
  input: CreatePsaCherryPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaCitrusPalletArgs = {
  input: CreatePsaCitrusPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaGrapePalletArgs = {
  input: CreatePsaGrapePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaLemonPalletArgs = {
  input: CreatePsaLemonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaPearPalletArgs = {
  input: CreatePsaPearPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaPersimmonPalletArgs = {
  input: CreatePsaPersimmonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaPomegranatePalletArgs = {
  input: CreatePsaPomegranatePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaStoneFruitPalletArgs = {
  input: CreatePsaStoneFruitPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAgendaItemArgs = {
  input: CreateAgendaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCalendarEventArgs = {
  input: CreateCalendarEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePriceCategoryArgs = {
  input: CreatePriceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePriceEntryArgs = {
  input: CreatePriceEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePriceProductArgs = {
  input: CreatePriceProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePriceSizeArgs = {
  input: CreatePriceSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateInventoryItemArgs = {
  input: CreateInventoryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackAtmosphereArgs = {
  input: CreatePackAtmosphereInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackBoxStyleArgs = {
  input: CreatePackBoxStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackBoxTypeArgs = {
  input: CreatePackBoxTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackDestinationArgs = {
  input: CreatePackDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackGradeArgs = {
  input: CreatePackGradeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackHoldArgs = {
  input: CreatePackHoldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackLabelArgs = {
  input: CreatePackLabelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackLinerArgs = {
  input: CreatePackLinerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackMasterArgs = {
  input: CreatePackMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackOutArgs = {
  input: CreatePackOutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackPalletTypeArgs = {
  input: CreatePackPalletTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackProductionArgs = {
  input: CreatePackProductionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackSpecialArgs = {
  input: CreatePackSpecialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackStyleArgs = {
  input: CreatePackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackTreeRipeArgs = {
  input: CreatePackTreeRipeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePalletArgs = {
  input: CreatePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePalletSectionArgs = {
  input: CreatePalletSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePalletTempOneArgs = {
  input: CreatePalletTempOneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePalletTempTwoArgs = {
  input: CreatePalletTempTwoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateProductMasterArgs = {
  input: CreateProductMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateProductSizeArgs = {
  input: CreateProductSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateProductSpeciesArgs = {
  input: CreateProductSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateProductVarietyArgs = {
  input: CreateProductVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperProjectionArgs = {
  input: CreateShipperProjectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperProjectionEntryArgs = {
  input: CreateShipperProjectionEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperProjectionProductArgs = {
  input: CreateShipperProjectionProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperProjectionVesselArgs = {
  input: CreateShipperProjectionVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVesselArgs = {
  input: CreateVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByPinArgs = {
  input: UpdateUserByPinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserMessageByNodeIdArgs = {
  input: UpdateUserMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserMessageArgs = {
  input: UpdateUserMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateContactGroupByNodeIdArgs = {
  input: UpdateContactGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateContactGroupArgs = {
  input: UpdateContactGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateContactGroupPersonContactByNodeIdArgs = {
  input: UpdateContactGroupPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateContactGroupPersonContactArgs = {
  input: UpdateContactGroupPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCountryByNodeIdArgs = {
  input: UpdateCountryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCountryArgs = {
  input: UpdateCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerByNodeIdArgs = {
  input: UpdateCustomerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerArgs = {
  input: UpdateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerPersonContactByNodeIdArgs = {
  input: UpdateCustomerPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerPersonContactArgs = {
  input: UpdateCustomerPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersonContactByNodeIdArgs = {
  input: UpdatePersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersonContactArgs = {
  input: UpdatePersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperByNodeIdArgs = {
  input: UpdateShipperByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperArgs = {
  input: UpdateShipperInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperPersonContactByNodeIdArgs = {
  input: UpdateShipperPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperPersonContactArgs = {
  input: UpdateShipperPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWarehouseByNodeIdArgs = {
  input: UpdateWarehouseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWarehouseArgs = {
  input: UpdateWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWarehousePersonContactByNodeIdArgs = {
  input: UpdateWarehousePersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWarehousePersonContactArgs = {
  input: UpdateWarehousePersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChileDepartureInspectionPalletByNodeIdArgs = {
  input: UpdateChileDepartureInspectionPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChileDepartureInspectionPalletArgs = {
  input: UpdateChileDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePeruDepartureInspectionByNodeIdArgs = {
  input: UpdatePeruDepartureInspectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePeruDepartureInspectionArgs = {
  input: UpdatePeruDepartureInspectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePeruDepartureInspectionPalletByNodeIdArgs = {
  input: UpdatePeruDepartureInspectionPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePeruDepartureInspectionPalletArgs = {
  input: UpdatePeruDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaApplePalletByNodeIdArgs = {
  input: UpdatePsaApplePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaApplePalletArgs = {
  input: UpdatePsaApplePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaArrivalPictureByNodeIdArgs = {
  input: UpdatePsaArrivalPictureByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaArrivalPictureArgs = {
  input: UpdatePsaArrivalPictureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaArrivalReportByNodeIdArgs = {
  input: UpdatePsaArrivalReportByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaArrivalReportArgs = {
  input: UpdatePsaArrivalReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaCherryPalletByNodeIdArgs = {
  input: UpdatePsaCherryPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaCherryPalletArgs = {
  input: UpdatePsaCherryPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaCitrusPalletByNodeIdArgs = {
  input: UpdatePsaCitrusPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaCitrusPalletArgs = {
  input: UpdatePsaCitrusPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaGrapePalletByNodeIdArgs = {
  input: UpdatePsaGrapePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaGrapePalletArgs = {
  input: UpdatePsaGrapePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaLemonPalletByNodeIdArgs = {
  input: UpdatePsaLemonPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaLemonPalletArgs = {
  input: UpdatePsaLemonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaPearPalletByNodeIdArgs = {
  input: UpdatePsaPearPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaPearPalletArgs = {
  input: UpdatePsaPearPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaPersimmonPalletByNodeIdArgs = {
  input: UpdatePsaPersimmonPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaPersimmonPalletArgs = {
  input: UpdatePsaPersimmonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaPomegranatePalletByNodeIdArgs = {
  input: UpdatePsaPomegranatePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaPomegranatePalletArgs = {
  input: UpdatePsaPomegranatePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaStoneFruitPalletByNodeIdArgs = {
  input: UpdatePsaStoneFruitPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaStoneFruitPalletArgs = {
  input: UpdatePsaStoneFruitPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAgendaItemByNodeIdArgs = {
  input: UpdateAgendaItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAgendaItemArgs = {
  input: UpdateAgendaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCalendarEventByNodeIdArgs = {
  input: UpdateCalendarEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCalendarEventArgs = {
  input: UpdateCalendarEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceCategoryByNodeIdArgs = {
  input: UpdatePriceCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceCategoryArgs = {
  input: UpdatePriceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceEntryByNodeIdArgs = {
  input: UpdatePriceEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceEntryArgs = {
  input: UpdatePriceEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceProductByNodeIdArgs = {
  input: UpdatePriceProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceProductArgs = {
  input: UpdatePriceProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceSizeByNodeIdArgs = {
  input: UpdatePriceSizeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceSizeArgs = {
  input: UpdatePriceSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInventoryItemByNodeIdArgs = {
  input: UpdateInventoryItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInventoryItemArgs = {
  input: UpdateInventoryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackAtmosphereByNodeIdArgs = {
  input: UpdatePackAtmosphereByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackAtmosphereArgs = {
  input: UpdatePackAtmosphereInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackAtmosphereByShipperIdAndMaCodeArgs = {
  input: UpdatePackAtmosphereByShipperIdAndMaCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackBoxStyleByNodeIdArgs = {
  input: UpdatePackBoxStyleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackBoxStyleArgs = {
  input: UpdatePackBoxStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackBoxStyleByShipperIdAndBoxStyleArgs = {
  input: UpdatePackBoxStyleByShipperIdAndBoxStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackBoxTypeByNodeIdArgs = {
  input: UpdatePackBoxTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackBoxTypeArgs = {
  input: UpdatePackBoxTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackBoxTypeByShipperIdAndBoxTypeArgs = {
  input: UpdatePackBoxTypeByShipperIdAndBoxTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackDestinationByNodeIdArgs = {
  input: UpdatePackDestinationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackDestinationArgs = {
  input: UpdatePackDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackDestinationByShipperIdAndDestinationCodeArgs = {
  input: UpdatePackDestinationByShipperIdAndDestinationCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackGradeByNodeIdArgs = {
  input: UpdatePackGradeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackGradeArgs = {
  input: UpdatePackGradeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackGradeByShipperIdAndGradeCodeArgs = {
  input: UpdatePackGradeByShipperIdAndGradeCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackHoldByNodeIdArgs = {
  input: UpdatePackHoldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackHoldArgs = {
  input: UpdatePackHoldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackHoldByShipperIdAndHoldCodeArgs = {
  input: UpdatePackHoldByShipperIdAndHoldCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackLabelByNodeIdArgs = {
  input: UpdatePackLabelByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackLabelArgs = {
  input: UpdatePackLabelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackLabelByShipperIdAndLabelCodeArgs = {
  input: UpdatePackLabelByShipperIdAndLabelCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackLinerByNodeIdArgs = {
  input: UpdatePackLinerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackLinerArgs = {
  input: UpdatePackLinerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackLinerByShipperIdAndLinerCodeArgs = {
  input: UpdatePackLinerByShipperIdAndLinerCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackMasterByNodeIdArgs = {
  input: UpdatePackMasterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackMasterArgs = {
  input: UpdatePackMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackOutByNodeIdArgs = {
  input: UpdatePackOutByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackOutArgs = {
  input: UpdatePackOutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackOutByShipperIdAndOutCodeArgs = {
  input: UpdatePackOutByShipperIdAndOutCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackPalletTypeByNodeIdArgs = {
  input: UpdatePackPalletTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackPalletTypeArgs = {
  input: UpdatePackPalletTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackPalletTypeByShipperIdAndPalletTypeArgs = {
  input: UpdatePackPalletTypeByShipperIdAndPalletTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackProductionByNodeIdArgs = {
  input: UpdatePackProductionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackProductionArgs = {
  input: UpdatePackProductionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackProductionByShipperIdAndProductionCodeArgs = {
  input: UpdatePackProductionByShipperIdAndProductionCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackSpecialByNodeIdArgs = {
  input: UpdatePackSpecialByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackSpecialArgs = {
  input: UpdatePackSpecialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackSpecialByShipperIdAndCustomerCodeArgs = {
  input: UpdatePackSpecialByShipperIdAndCustomerCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackStyleByNodeIdArgs = {
  input: UpdatePackStyleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackStyleArgs = {
  input: UpdatePackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackStyleByShipperIdAndPackStyleArgs = {
  input: UpdatePackStyleByShipperIdAndPackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackTreeRipeByNodeIdArgs = {
  input: UpdatePackTreeRipeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackTreeRipeArgs = {
  input: UpdatePackTreeRipeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackTreeRipeByShipperIdAndTreeRipeArgs = {
  input: UpdatePackTreeRipeByShipperIdAndTreeRipeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePalletSectionByNodeIdArgs = {
  input: UpdatePalletSectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePalletSectionArgs = {
  input: UpdatePalletSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePalletTempOneByNodeIdArgs = {
  input: UpdatePalletTempOneByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePalletTempOneArgs = {
  input: UpdatePalletTempOneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePalletTempTwoByNodeIdArgs = {
  input: UpdatePalletTempTwoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePalletTempTwoArgs = {
  input: UpdatePalletTempTwoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductMasterByNodeIdArgs = {
  input: UpdateProductMasterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductMasterArgs = {
  input: UpdateProductMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductSizeByNodeIdArgs = {
  input: UpdateProductSizeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductSizeArgs = {
  input: UpdateProductSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductSpeciesByNodeIdArgs = {
  input: UpdateProductSpeciesByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductSpeciesArgs = {
  input: UpdateProductSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductVarietyByNodeIdArgs = {
  input: UpdateProductVarietyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductVarietyArgs = {
  input: UpdateProductVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionByNodeIdArgs = {
  input: UpdateShipperProjectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionArgs = {
  input: UpdateShipperProjectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionEntryByNodeIdArgs = {
  input: UpdateShipperProjectionEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionEntryArgs = {
  input: UpdateShipperProjectionEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionProductByNodeIdArgs = {
  input: UpdateShipperProjectionProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionProductArgs = {
  input: UpdateShipperProjectionProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionVesselByNodeIdArgs = {
  input: UpdateShipperProjectionVesselByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionVesselArgs = {
  input: UpdateShipperProjectionVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVesselByNodeIdArgs = {
  input: UpdateVesselByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVesselArgs = {
  input: UpdateVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByNodeIdArgs = {
  input: DeleteUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByPinArgs = {
  input: DeleteUserByPinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserMessageByNodeIdArgs = {
  input: DeleteUserMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserMessageArgs = {
  input: DeleteUserMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteContactGroupByNodeIdArgs = {
  input: DeleteContactGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteContactGroupArgs = {
  input: DeleteContactGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteContactGroupPersonContactByNodeIdArgs = {
  input: DeleteContactGroupPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteContactGroupPersonContactArgs = {
  input: DeleteContactGroupPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCountryByNodeIdArgs = {
  input: DeleteCountryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCountryArgs = {
  input: DeleteCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerByNodeIdArgs = {
  input: DeleteCustomerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerArgs = {
  input: DeleteCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerPersonContactByNodeIdArgs = {
  input: DeleteCustomerPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerPersonContactArgs = {
  input: DeleteCustomerPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersonContactByNodeIdArgs = {
  input: DeletePersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersonContactArgs = {
  input: DeletePersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperByNodeIdArgs = {
  input: DeleteShipperByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperArgs = {
  input: DeleteShipperInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperPersonContactByNodeIdArgs = {
  input: DeleteShipperPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperPersonContactArgs = {
  input: DeleteShipperPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWarehouseByNodeIdArgs = {
  input: DeleteWarehouseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWarehouseArgs = {
  input: DeleteWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWarehousePersonContactByNodeIdArgs = {
  input: DeleteWarehousePersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWarehousePersonContactArgs = {
  input: DeleteWarehousePersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChileDepartureInspectionPalletByNodeIdArgs = {
  input: DeleteChileDepartureInspectionPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChileDepartureInspectionPalletArgs = {
  input: DeleteChileDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePeruDepartureInspectionByNodeIdArgs = {
  input: DeletePeruDepartureInspectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePeruDepartureInspectionArgs = {
  input: DeletePeruDepartureInspectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePeruDepartureInspectionPalletByNodeIdArgs = {
  input: DeletePeruDepartureInspectionPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePeruDepartureInspectionPalletArgs = {
  input: DeletePeruDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaApplePalletByNodeIdArgs = {
  input: DeletePsaApplePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaApplePalletArgs = {
  input: DeletePsaApplePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaArrivalPictureByNodeIdArgs = {
  input: DeletePsaArrivalPictureByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaArrivalPictureArgs = {
  input: DeletePsaArrivalPictureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaArrivalReportByNodeIdArgs = {
  input: DeletePsaArrivalReportByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaArrivalReportArgs = {
  input: DeletePsaArrivalReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaCherryPalletByNodeIdArgs = {
  input: DeletePsaCherryPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaCherryPalletArgs = {
  input: DeletePsaCherryPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaCitrusPalletByNodeIdArgs = {
  input: DeletePsaCitrusPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaCitrusPalletArgs = {
  input: DeletePsaCitrusPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaGrapePalletByNodeIdArgs = {
  input: DeletePsaGrapePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaGrapePalletArgs = {
  input: DeletePsaGrapePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaLemonPalletByNodeIdArgs = {
  input: DeletePsaLemonPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaLemonPalletArgs = {
  input: DeletePsaLemonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaPearPalletByNodeIdArgs = {
  input: DeletePsaPearPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaPearPalletArgs = {
  input: DeletePsaPearPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaPersimmonPalletByNodeIdArgs = {
  input: DeletePsaPersimmonPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaPersimmonPalletArgs = {
  input: DeletePsaPersimmonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaPomegranatePalletByNodeIdArgs = {
  input: DeletePsaPomegranatePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaPomegranatePalletArgs = {
  input: DeletePsaPomegranatePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaStoneFruitPalletByNodeIdArgs = {
  input: DeletePsaStoneFruitPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaStoneFruitPalletArgs = {
  input: DeletePsaStoneFruitPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAgendaItemByNodeIdArgs = {
  input: DeleteAgendaItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAgendaItemArgs = {
  input: DeleteAgendaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCalendarEventByNodeIdArgs = {
  input: DeleteCalendarEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCalendarEventArgs = {
  input: DeleteCalendarEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceCategoryByNodeIdArgs = {
  input: DeletePriceCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceCategoryArgs = {
  input: DeletePriceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceEntryByNodeIdArgs = {
  input: DeletePriceEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceEntryArgs = {
  input: DeletePriceEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceProductByNodeIdArgs = {
  input: DeletePriceProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceProductArgs = {
  input: DeletePriceProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceSizeByNodeIdArgs = {
  input: DeletePriceSizeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceSizeArgs = {
  input: DeletePriceSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInventoryItemByNodeIdArgs = {
  input: DeleteInventoryItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInventoryItemArgs = {
  input: DeleteInventoryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackAtmosphereByNodeIdArgs = {
  input: DeletePackAtmosphereByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackAtmosphereArgs = {
  input: DeletePackAtmosphereInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackAtmosphereByShipperIdAndMaCodeArgs = {
  input: DeletePackAtmosphereByShipperIdAndMaCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackBoxStyleByNodeIdArgs = {
  input: DeletePackBoxStyleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackBoxStyleArgs = {
  input: DeletePackBoxStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackBoxStyleByShipperIdAndBoxStyleArgs = {
  input: DeletePackBoxStyleByShipperIdAndBoxStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackBoxTypeByNodeIdArgs = {
  input: DeletePackBoxTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackBoxTypeArgs = {
  input: DeletePackBoxTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackBoxTypeByShipperIdAndBoxTypeArgs = {
  input: DeletePackBoxTypeByShipperIdAndBoxTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackDestinationByNodeIdArgs = {
  input: DeletePackDestinationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackDestinationArgs = {
  input: DeletePackDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackDestinationByShipperIdAndDestinationCodeArgs = {
  input: DeletePackDestinationByShipperIdAndDestinationCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackGradeByNodeIdArgs = {
  input: DeletePackGradeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackGradeArgs = {
  input: DeletePackGradeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackGradeByShipperIdAndGradeCodeArgs = {
  input: DeletePackGradeByShipperIdAndGradeCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackHoldByNodeIdArgs = {
  input: DeletePackHoldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackHoldArgs = {
  input: DeletePackHoldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackHoldByShipperIdAndHoldCodeArgs = {
  input: DeletePackHoldByShipperIdAndHoldCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackLabelByNodeIdArgs = {
  input: DeletePackLabelByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackLabelArgs = {
  input: DeletePackLabelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackLabelByShipperIdAndLabelCodeArgs = {
  input: DeletePackLabelByShipperIdAndLabelCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackLinerByNodeIdArgs = {
  input: DeletePackLinerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackLinerArgs = {
  input: DeletePackLinerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackLinerByShipperIdAndLinerCodeArgs = {
  input: DeletePackLinerByShipperIdAndLinerCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackMasterByNodeIdArgs = {
  input: DeletePackMasterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackMasterArgs = {
  input: DeletePackMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackOutByNodeIdArgs = {
  input: DeletePackOutByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackOutArgs = {
  input: DeletePackOutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackOutByShipperIdAndOutCodeArgs = {
  input: DeletePackOutByShipperIdAndOutCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackPalletTypeByNodeIdArgs = {
  input: DeletePackPalletTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackPalletTypeArgs = {
  input: DeletePackPalletTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackPalletTypeByShipperIdAndPalletTypeArgs = {
  input: DeletePackPalletTypeByShipperIdAndPalletTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackProductionByNodeIdArgs = {
  input: DeletePackProductionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackProductionArgs = {
  input: DeletePackProductionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackProductionByShipperIdAndProductionCodeArgs = {
  input: DeletePackProductionByShipperIdAndProductionCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackSpecialByNodeIdArgs = {
  input: DeletePackSpecialByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackSpecialArgs = {
  input: DeletePackSpecialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackSpecialByShipperIdAndCustomerCodeArgs = {
  input: DeletePackSpecialByShipperIdAndCustomerCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackStyleByNodeIdArgs = {
  input: DeletePackStyleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackStyleArgs = {
  input: DeletePackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackStyleByShipperIdAndPackStyleArgs = {
  input: DeletePackStyleByShipperIdAndPackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackTreeRipeByNodeIdArgs = {
  input: DeletePackTreeRipeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackTreeRipeArgs = {
  input: DeletePackTreeRipeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackTreeRipeByShipperIdAndTreeRipeArgs = {
  input: DeletePackTreeRipeByShipperIdAndTreeRipeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePalletSectionByNodeIdArgs = {
  input: DeletePalletSectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePalletSectionArgs = {
  input: DeletePalletSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePalletTempOneByNodeIdArgs = {
  input: DeletePalletTempOneByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePalletTempOneArgs = {
  input: DeletePalletTempOneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePalletTempTwoByNodeIdArgs = {
  input: DeletePalletTempTwoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePalletTempTwoArgs = {
  input: DeletePalletTempTwoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductMasterByNodeIdArgs = {
  input: DeleteProductMasterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductMasterArgs = {
  input: DeleteProductMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductSizeByNodeIdArgs = {
  input: DeleteProductSizeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductSizeArgs = {
  input: DeleteProductSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductSpeciesByNodeIdArgs = {
  input: DeleteProductSpeciesByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductSpeciesArgs = {
  input: DeleteProductSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductVarietyByNodeIdArgs = {
  input: DeleteProductVarietyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductVarietyArgs = {
  input: DeleteProductVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionByNodeIdArgs = {
  input: DeleteShipperProjectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionArgs = {
  input: DeleteShipperProjectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionEntryByNodeIdArgs = {
  input: DeleteShipperProjectionEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionEntryArgs = {
  input: DeleteShipperProjectionEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionProductByNodeIdArgs = {
  input: DeleteShipperProjectionProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionProductArgs = {
  input: DeleteShipperProjectionProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionVesselByNodeIdArgs = {
  input: DeleteShipperProjectionVesselByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionVesselArgs = {
  input: DeleteShipperProjectionVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVesselByNodeIdArgs = {
  input: DeleteVesselByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVesselArgs = {
  input: DeleteVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkCreateUserMessageArgs = {
  input: BulkCreateUserMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkAddContactsToGroupArgs = {
  input: BulkAddContactsToGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkRemoveContactGroupPersonContactArgs = {
  input: BulkRemoveContactGroupPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreateChileDepartureInspectionPalletArgs = {
  input: BatchCreateChileDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaApplePalletArgs = {
  input: BatchCreatePsaApplePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaCherryPalletArgs = {
  input: BatchCreatePsaCherryPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaCitrusPalletArgs = {
  input: BatchCreatePsaCitrusPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaGrapePalletArgs = {
  input: BatchCreatePsaGrapePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaLemonPalletArgs = {
  input: BatchCreatePsaLemonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaPearPalletArgs = {
  input: BatchCreatePsaPearPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaPersimmonPalletArgs = {
  input: BatchCreatePsaPersimmonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaPomegranatePalletArgs = {
  input: BatchCreatePsaPomegranatePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaStoneFruitPalletArgs = {
  input: BatchCreatePsaStoneFruitPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertAgendaItemArgs = {
  input: BulkUpsertAgendaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPriceCategoryArgs = {
  input: BulkUpsertPriceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPriceEntryArgs = {
  input: BulkUpsertPriceEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPriceProductArgs = {
  input: BulkUpsertPriceProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPriceSizeArgs = {
  input: BulkUpsertPriceSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceCategoryEntriesArgs = {
  input: DeletePriceCategoryEntriesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceProductEntriesArgs = {
  input: DeletePriceProductEntriesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceSizeEntriesArgs = {
  input: DeletePriceSizeEntriesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteShipperProjectionEntryArgs = {
  input: BulkDeleteShipperProjectionEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteShipperProjectionProductArgs = {
  input: BulkDeleteShipperProjectionProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertShipperProjectionEntryArgs = {
  input: BulkUpsertShipperProjectionEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertShipperProjectionProductArgs = {
  input: BulkUpsertShipperProjectionProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertShipperProjectionVesselArgs = {
  input: BulkUpsertShipperProjectionVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertShipperProjectionArgs = {
  input: UpsertShipperProjectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationSendPriceSheetUpdateEmailArgs = {
  input?: Maybe<PriceSheetUpdateInput>;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PersonContact` that is related to this `User`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
};

/** Input for the nested mutation of `personContact` in the `UserInput` mutation. */
export type UserPersonContactIdFkeyInput = {
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectById?: Maybe<PersonContactPersonContactPkeyConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<PersonContactNodeIdConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteById?: Maybe<PersonContactPersonContactPkeyDelete>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PersonContactNodeIdDelete>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateById?: Maybe<PersonContactOnUserForUserPersonContactIdFkeyUsingPersonContactPkeyUpdate>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<UserOnUserForUserPersonContactIdFkeyNodeIdUpdate>;
  /** A `PersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<UserPersonContactIdFkeyPersonContactCreateInput>;
};

/** The fields on `personContact` to look up the row to connect. */
export type PersonContactPersonContactPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type PersonContactNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `personContact` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `personContact` to look up the row to delete. */
export type PersonContactPersonContactPkeyDelete = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PersonContactNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `personContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `personContact` to look up the row to update. */
export type PersonContactOnUserForUserPersonContactIdFkeyUsingPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: UpdatePersonContactOnUserForUserPersonContactIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `personContact` being updated. */
export type UpdatePersonContactOnUserForUserPersonContactIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  isPrimary?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal?: Maybe<Scalars['Boolean']>;
  roles?: Maybe<Scalars['String']>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
};

/** Input for the nested mutation of `customerPersonContact` in the `PersonContactInput` mutation. */
export type CustomerPersonContactPersonContactIdFkeyInverseInput = {
  /** Flag indicating whether all other `customerPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  connectByCustomerIdAndPersonContactId?: Maybe<Array<CustomerPersonContactCustomerPersonContactPkeyConnect>>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CustomerPersonContactNodeIdConnect>>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  deleteByCustomerIdAndPersonContactId?: Maybe<Array<CustomerPersonContactCustomerPersonContactPkeyDelete>>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CustomerPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `customerPersonContact` for the far side of the relationship. */
  updateByCustomerIdAndPersonContactId?: Maybe<Array<CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyUsingCustomerPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `customerPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyNodeIdUpdate>>;
  /** A `CustomerPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CustomerPersonContactPersonContactIdFkeyCustomerPersonContactCreateInput>>;
};

/** The fields on `customerPersonContact` to look up the row to connect. */
export type CustomerPersonContactCustomerPersonContactPkeyConnect = {
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type CustomerPersonContactNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `customerPersonContact` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `customerPersonContact` to look up the row to delete. */
export type CustomerPersonContactCustomerPersonContactPkeyDelete = {
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CustomerPersonContactNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `customerPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `customerPersonContact` to look up the row to update. */
export type CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyUsingCustomerPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `customerPersonContact` being updated. */
  patch: UpdateCustomerPersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyPatch;
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `customerPersonContact` being updated. */
export type UpdateCustomerPersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyPatch = {
  customerId?: Maybe<Scalars['String']>;
  customerToCustomerId?: Maybe<CustomerPersonContactCustomerIdFkeyInput>;
  personContactToPersonContactId?: Maybe<CustomerPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `customer` in the `CustomerPersonContactInput` mutation. */
export type CustomerPersonContactCustomerIdFkeyInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: Maybe<CustomerCustomerPkeyConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectByNodeId?: Maybe<CustomerNodeIdConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: Maybe<CustomerCustomerPkeyDelete>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CustomerNodeIdDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: Maybe<CustomerOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyUsingCustomerPkeyUpdate>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateByNodeId?: Maybe<CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyNodeIdUpdate>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: Maybe<CustomerPersonContactCustomerIdFkeyCustomerCreateInput>;
};

/** The fields on `customer` to look up the row to connect. */
export type CustomerCustomerPkeyConnect = {
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to connect. */
export type CustomerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `customer` to look up the row to delete. */
export type CustomerCustomerPkeyDelete = {
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CustomerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `customer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyUsingCustomerPkeyUpdate = {
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyPatch;
  id: Scalars['String'];
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  countryToCountryId?: Maybe<CustomerCountryIdFkeyInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
};

/** Input for the nested mutation of `country` in the `CustomerInput` mutation. */
export type CustomerCountryIdFkeyInput = {
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectById?: Maybe<CountryCountryPkeyConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectByNodeId?: Maybe<CountryNodeIdConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteById?: Maybe<CountryCountryPkeyDelete>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CountryNodeIdDelete>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateById?: Maybe<CountryOnCustomerForCustomerCountryIdFkeyUsingCountryPkeyUpdate>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateByNodeId?: Maybe<CustomerOnCustomerForCustomerCountryIdFkeyNodeIdUpdate>;
  /** A `CountryInput` object that will be created and connected to this object. */
  create?: Maybe<CustomerCountryIdFkeyCountryCreateInput>;
};

/** The fields on `country` to look up the row to connect. */
export type CountryCountryPkeyConnect = {
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to connect. */
export type CountryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `country` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `country` to look up the row to delete. */
export type CountryCountryPkeyDelete = {
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CountryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `country` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `country` to look up the row to update. */
export type CountryOnCustomerForCustomerCountryIdFkeyUsingCountryPkeyUpdate = {
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: UpdateCountryOnCustomerForCustomerCountryIdFkeyPatch;
  id: Scalars['String'];
};

/** An object where the defined keys will be set on the `country` being updated. */
export type UpdateCountryOnCustomerForCustomerCountryIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  countryName?: Maybe<Scalars['String']>;
  customersUsingId?: Maybe<CustomerCountryIdFkeyInverseInput>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** Input for the nested mutation of `customer` in the `CountryInput` mutation. */
export type CustomerCountryIdFkeyInverseInput = {
  /** Flag indicating whether all other `customer` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: Maybe<Array<CustomerCustomerPkeyConnect>>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CustomerNodeIdConnect>>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: Maybe<Array<CustomerCustomerPkeyDelete>>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CustomerNodeIdDelete>>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: Maybe<Array<CustomerOnCustomerForCustomerCountryIdFkeyUsingCustomerPkeyUpdate>>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CountryOnCustomerForCustomerCountryIdFkeyNodeIdUpdate>>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CustomerCountryIdFkeyCustomerCreateInput>>;
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnCustomerForCustomerCountryIdFkeyUsingCustomerPkeyUpdate = {
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnCustomerForCustomerCountryIdFkeyPatch;
  id: Scalars['String'];
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnCustomerForCustomerCountryIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  countryToCountryId?: Maybe<CustomerCountryIdFkeyInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
};

/** Input for the nested mutation of `customerPersonContact` in the `CustomerInput` mutation. */
export type CustomerPersonContactCustomerIdFkeyInverseInput = {
  /** Flag indicating whether all other `customerPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  connectByCustomerIdAndPersonContactId?: Maybe<Array<CustomerPersonContactCustomerPersonContactPkeyConnect>>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CustomerPersonContactNodeIdConnect>>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  deleteByCustomerIdAndPersonContactId?: Maybe<Array<CustomerPersonContactCustomerPersonContactPkeyDelete>>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CustomerPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `customerPersonContact` for the far side of the relationship. */
  updateByCustomerIdAndPersonContactId?: Maybe<Array<CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyUsingCustomerPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `customerPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CustomerOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyNodeIdUpdate>>;
  /** A `CustomerPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CustomerPersonContactCustomerIdFkeyCustomerPersonContactCreateInput>>;
};

/** The fields on `customerPersonContact` to look up the row to update. */
export type CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyUsingCustomerPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `customerPersonContact` being updated. */
  patch: UpdateCustomerPersonContactOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyPatch;
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `customerPersonContact` being updated. */
export type UpdateCustomerPersonContactOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyPatch = {
  personContactId?: Maybe<Scalars['BigInt']>;
  customerToCustomerId?: Maybe<CustomerPersonContactCustomerIdFkeyInput>;
  personContactToPersonContactId?: Maybe<CustomerPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `personContact` in the `CustomerPersonContactInput` mutation. */
export type CustomerPersonContactPersonContactIdFkeyInput = {
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectById?: Maybe<PersonContactPersonContactPkeyConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<PersonContactNodeIdConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteById?: Maybe<PersonContactPersonContactPkeyDelete>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PersonContactNodeIdDelete>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateById?: Maybe<PersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyNodeIdUpdate>;
  /** A `PersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<CustomerPersonContactPersonContactIdFkeyPersonContactCreateInput>;
};

/** The fields on `personContact` to look up the row to update. */
export type PersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: UpdatePersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `personContact` being updated. */
export type UpdatePersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  isPrimary?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal?: Maybe<Scalars['Boolean']>;
  roles?: Maybe<Scalars['String']>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipperPersonContact` in the `PersonContactInput` mutation. */
export type ShipperPersonContactPersonContactIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  connectByShipperIdAndPersonContactId?: Maybe<Array<ShipperPersonContactShipperPersonContactPkeyConnect>>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperPersonContactNodeIdConnect>>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  deleteByShipperIdAndPersonContactId?: Maybe<Array<ShipperPersonContactShipperPersonContactPkeyDelete>>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperPersonContact` for the far side of the relationship. */
  updateByShipperIdAndPersonContactId?: Maybe<Array<ShipperPersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyUsingShipperPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyNodeIdUpdate>>;
  /** A `ShipperPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperPersonContactPersonContactIdFkeyShipperPersonContactCreateInput>>;
};

/** The fields on `shipperPersonContact` to look up the row to connect. */
export type ShipperPersonContactShipperPersonContactPkeyConnect = {
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperPersonContactNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperPersonContact` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `shipperPersonContact` to look up the row to delete. */
export type ShipperPersonContactShipperPersonContactPkeyDelete = {
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperPersonContactNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `shipperPersonContact` to look up the row to update. */
export type ShipperPersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyUsingShipperPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperPersonContact` being updated. */
  patch: UpdateShipperPersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyPatch;
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `shipperPersonContact` being updated. */
export type UpdateShipperPersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyPatch = {
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperPersonContactShipperIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ShipperPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `shipper` in the `ShipperPersonContactInput` mutation. */
export type ShipperPersonContactShipperIdFkeyInput = {
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectById?: Maybe<ShipperShipperPkeyConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperNodeIdConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteById?: Maybe<ShipperShipperPkeyDelete>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperNodeIdDelete>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateById?: Maybe<ShipperOnShipperPersonContactForShipperPersonContactShipperIdFkeyUsingShipperPkeyUpdate>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperPersonContactOnShipperPersonContactForShipperPersonContactShipperIdFkeyNodeIdUpdate>;
  /** A `ShipperInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperPersonContactShipperIdFkeyShipperCreateInput>;
};

/** The fields on `shipper` to look up the row to connect. */
export type ShipperShipperPkeyConnect = {
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `shipper` to look up the row to delete. */
export type ShipperShipperPkeyDelete = {
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipper` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `shipper` to look up the row to update. */
export type ShipperOnShipperPersonContactForShipperPersonContactShipperIdFkeyUsingShipperPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: UpdateShipperOnShipperPersonContactForShipperPersonContactShipperIdFkeyPatch;
  id: Scalars['String'];
};

/** An object where the defined keys will be set on the `shipper` being updated. */
export type UpdateShipperOnShipperPersonContactForShipperPersonContactShipperIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
};

/** Input for the nested mutation of `country` in the `ShipperInput` mutation. */
export type ShipperCountryIdFkeyInput = {
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectById?: Maybe<CountryCountryPkeyConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectByNodeId?: Maybe<CountryNodeIdConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteById?: Maybe<CountryCountryPkeyDelete>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CountryNodeIdDelete>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateById?: Maybe<CountryOnShipperForShipperCountryIdFkeyUsingCountryPkeyUpdate>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperOnShipperForShipperCountryIdFkeyNodeIdUpdate>;
  /** A `CountryInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperCountryIdFkeyCountryCreateInput>;
};

/** The fields on `country` to look up the row to update. */
export type CountryOnShipperForShipperCountryIdFkeyUsingCountryPkeyUpdate = {
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: UpdateCountryOnShipperForShipperCountryIdFkeyPatch;
  id: Scalars['String'];
};

/** An object where the defined keys will be set on the `country` being updated. */
export type UpdateCountryOnShipperForShipperCountryIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  countryName?: Maybe<Scalars['String']>;
  customersUsingId?: Maybe<CustomerCountryIdFkeyInverseInput>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipper` in the `CountryInput` mutation. */
export type ShipperCountryIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipper` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperShipperPkeyConnect>>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperNodeIdConnect>>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperShipperPkeyDelete>>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperOnShipperForShipperCountryIdFkeyUsingShipperPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CountryOnShipperForShipperCountryIdFkeyNodeIdUpdate>>;
  /** A `ShipperInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperCountryIdFkeyShipperCreateInput>>;
};

/** The fields on `shipper` to look up the row to update. */
export type ShipperOnShipperForShipperCountryIdFkeyUsingShipperPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: UpdateShipperOnShipperForShipperCountryIdFkeyPatch;
  id: Scalars['String'];
};

/** An object where the defined keys will be set on the `shipper` being updated. */
export type UpdateShipperOnShipperForShipperCountryIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipperPersonContact` in the `ShipperInput` mutation. */
export type ShipperPersonContactShipperIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  connectByShipperIdAndPersonContactId?: Maybe<Array<ShipperPersonContactShipperPersonContactPkeyConnect>>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperPersonContactNodeIdConnect>>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  deleteByShipperIdAndPersonContactId?: Maybe<Array<ShipperPersonContactShipperPersonContactPkeyDelete>>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperPersonContact` for the far side of the relationship. */
  updateByShipperIdAndPersonContactId?: Maybe<Array<ShipperPersonContactOnShipperPersonContactForShipperPersonContactShipperIdFkeyUsingShipperPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperOnShipperPersonContactForShipperPersonContactShipperIdFkeyNodeIdUpdate>>;
  /** A `ShipperPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperPersonContactShipperIdFkeyShipperPersonContactCreateInput>>;
};

/** The fields on `shipperPersonContact` to look up the row to update. */
export type ShipperPersonContactOnShipperPersonContactForShipperPersonContactShipperIdFkeyUsingShipperPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperPersonContact` being updated. */
  patch: UpdateShipperPersonContactOnShipperPersonContactForShipperPersonContactShipperIdFkeyPatch;
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `shipperPersonContact` being updated. */
export type UpdateShipperPersonContactOnShipperPersonContactForShipperPersonContactShipperIdFkeyPatch = {
  personContactId?: Maybe<Scalars['BigInt']>;
  shipperToShipperId?: Maybe<ShipperPersonContactShipperIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ShipperPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `personContact` in the `ShipperPersonContactInput` mutation. */
export type ShipperPersonContactPersonContactIdFkeyInput = {
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectById?: Maybe<PersonContactPersonContactPkeyConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<PersonContactNodeIdConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteById?: Maybe<PersonContactPersonContactPkeyDelete>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PersonContactNodeIdDelete>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateById?: Maybe<PersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperPersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyNodeIdUpdate>;
  /** A `PersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperPersonContactPersonContactIdFkeyPersonContactCreateInput>;
};

/** The fields on `personContact` to look up the row to update. */
export type PersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: UpdatePersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `personContact` being updated. */
export type UpdatePersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  isPrimary?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal?: Maybe<Scalars['Boolean']>;
  roles?: Maybe<Scalars['String']>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
};

/** Input for the nested mutation of `warehousePersonContact` in the `PersonContactInput` mutation. */
export type WarehousePersonContactPersonContactIdFkeyInverseInput = {
  /** Flag indicating whether all other `warehousePersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  connectByWarehouseIdAndPersonContactId?: Maybe<Array<WarehousePersonContactWarehousePersonContactPkeyConnect>>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<WarehousePersonContactNodeIdConnect>>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  deleteByWarehouseIdAndPersonContactId?: Maybe<Array<WarehousePersonContactWarehousePersonContactPkeyDelete>>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<WarehousePersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `warehousePersonContact` for the far side of the relationship. */
  updateByWarehouseIdAndPersonContactId?: Maybe<Array<WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyUsingWarehousePersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `warehousePersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyNodeIdUpdate>>;
  /** A `WarehousePersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<WarehousePersonContactPersonContactIdFkeyWarehousePersonContactCreateInput>>;
};

/** The fields on `warehousePersonContact` to look up the row to connect. */
export type WarehousePersonContactWarehousePersonContactPkeyConnect = {
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type WarehousePersonContactNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `warehousePersonContact` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `warehousePersonContact` to look up the row to delete. */
export type WarehousePersonContactWarehousePersonContactPkeyDelete = {
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type WarehousePersonContactNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `warehousePersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `warehousePersonContact` to look up the row to update. */
export type WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyUsingWarehousePersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `warehousePersonContact` being updated. */
  patch: UpdateWarehousePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyPatch;
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `warehousePersonContact` being updated. */
export type UpdateWarehousePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyPatch = {
  warehouseId?: Maybe<Scalars['String']>;
  warehouseToWarehouseId?: Maybe<WarehousePersonContactWarehouseIdFkeyInput>;
  personContactToPersonContactId?: Maybe<WarehousePersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `warehouse` in the `WarehousePersonContactInput` mutation. */
export type WarehousePersonContactWarehouseIdFkeyInput = {
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  connectById?: Maybe<WarehouseWarehousePkeyConnect>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  connectByNodeId?: Maybe<WarehouseNodeIdConnect>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  deleteById?: Maybe<WarehouseWarehousePkeyDelete>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<WarehouseNodeIdDelete>;
  /** The primary key(s) and patch data for `warehouse` for the far side of the relationship. */
  updateById?: Maybe<WarehouseOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyUsingWarehousePkeyUpdate>;
  /** The primary key(s) and patch data for `warehouse` for the far side of the relationship. */
  updateByNodeId?: Maybe<WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyNodeIdUpdate>;
  /** A `WarehouseInput` object that will be created and connected to this object. */
  create?: Maybe<WarehousePersonContactWarehouseIdFkeyWarehouseCreateInput>;
};

/** The fields on `warehouse` to look up the row to connect. */
export type WarehouseWarehousePkeyConnect = {
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to connect. */
export type WarehouseNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `warehouse` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `warehouse` to look up the row to delete. */
export type WarehouseWarehousePkeyDelete = {
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to delete. */
export type WarehouseNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `warehouse` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `warehouse` to look up the row to update. */
export type WarehouseOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyUsingWarehousePkeyUpdate = {
  /** An object where the defined keys will be set on the `warehouse` being updated. */
  patch: UpdateWarehouseOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyPatch;
  id: Scalars['String'];
};

/** An object where the defined keys will be set on the `warehouse` being updated. */
export type UpdateWarehouseOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  warehouseName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<WarehouseCountryIdFkeyInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactWarehouseIdFkeyInverseInput>;
};

/** Input for the nested mutation of `country` in the `WarehouseInput` mutation. */
export type WarehouseCountryIdFkeyInput = {
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectById?: Maybe<CountryCountryPkeyConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectByNodeId?: Maybe<CountryNodeIdConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteById?: Maybe<CountryCountryPkeyDelete>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CountryNodeIdDelete>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateById?: Maybe<CountryOnWarehouseForWarehouseCountryIdFkeyUsingCountryPkeyUpdate>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateByNodeId?: Maybe<WarehouseOnWarehouseForWarehouseCountryIdFkeyNodeIdUpdate>;
  /** A `CountryInput` object that will be created and connected to this object. */
  create?: Maybe<WarehouseCountryIdFkeyCountryCreateInput>;
};

/** The fields on `country` to look up the row to update. */
export type CountryOnWarehouseForWarehouseCountryIdFkeyUsingCountryPkeyUpdate = {
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: UpdateCountryOnWarehouseForWarehouseCountryIdFkeyPatch;
  id: Scalars['String'];
};

/** An object where the defined keys will be set on the `country` being updated. */
export type UpdateCountryOnWarehouseForWarehouseCountryIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  countryName?: Maybe<Scalars['String']>;
  customersUsingId?: Maybe<CustomerCountryIdFkeyInverseInput>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** Input for the nested mutation of `warehouse` in the `CountryInput` mutation. */
export type WarehouseCountryIdFkeyInverseInput = {
  /** Flag indicating whether all other `warehouse` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  connectById?: Maybe<Array<WarehouseWarehousePkeyConnect>>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<WarehouseNodeIdConnect>>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  deleteById?: Maybe<Array<WarehouseWarehousePkeyDelete>>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<WarehouseNodeIdDelete>>;
  /** The primary key(s) and patch data for `warehouse` for the far side of the relationship. */
  updateById?: Maybe<Array<WarehouseOnWarehouseForWarehouseCountryIdFkeyUsingWarehousePkeyUpdate>>;
  /** The primary key(s) and patch data for `warehouse` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CountryOnWarehouseForWarehouseCountryIdFkeyNodeIdUpdate>>;
  /** A `WarehouseInput` object that will be created and connected to this object. */
  create?: Maybe<Array<WarehouseCountryIdFkeyWarehouseCreateInput>>;
};

/** The fields on `warehouse` to look up the row to update. */
export type WarehouseOnWarehouseForWarehouseCountryIdFkeyUsingWarehousePkeyUpdate = {
  /** An object where the defined keys will be set on the `warehouse` being updated. */
  patch: UpdateWarehouseOnWarehouseForWarehouseCountryIdFkeyPatch;
  id: Scalars['String'];
};

/** An object where the defined keys will be set on the `warehouse` being updated. */
export type UpdateWarehouseOnWarehouseForWarehouseCountryIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  warehouseName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<WarehouseCountryIdFkeyInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactWarehouseIdFkeyInverseInput>;
};

/** Input for the nested mutation of `warehousePersonContact` in the `WarehouseInput` mutation. */
export type WarehousePersonContactWarehouseIdFkeyInverseInput = {
  /** Flag indicating whether all other `warehousePersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  connectByWarehouseIdAndPersonContactId?: Maybe<Array<WarehousePersonContactWarehousePersonContactPkeyConnect>>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<WarehousePersonContactNodeIdConnect>>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  deleteByWarehouseIdAndPersonContactId?: Maybe<Array<WarehousePersonContactWarehousePersonContactPkeyDelete>>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<WarehousePersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `warehousePersonContact` for the far side of the relationship. */
  updateByWarehouseIdAndPersonContactId?: Maybe<Array<WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyUsingWarehousePersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `warehousePersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<WarehouseOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyNodeIdUpdate>>;
  /** A `WarehousePersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<WarehousePersonContactWarehouseIdFkeyWarehousePersonContactCreateInput>>;
};

/** The fields on `warehousePersonContact` to look up the row to update. */
export type WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyUsingWarehousePersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `warehousePersonContact` being updated. */
  patch: UpdateWarehousePersonContactOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyPatch;
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `warehousePersonContact` being updated. */
export type UpdateWarehousePersonContactOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyPatch = {
  personContactId?: Maybe<Scalars['BigInt']>;
  warehouseToWarehouseId?: Maybe<WarehousePersonContactWarehouseIdFkeyInput>;
  personContactToPersonContactId?: Maybe<WarehousePersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `personContact` in the `WarehousePersonContactInput` mutation. */
export type WarehousePersonContactPersonContactIdFkeyInput = {
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectById?: Maybe<PersonContactPersonContactPkeyConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<PersonContactNodeIdConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteById?: Maybe<PersonContactPersonContactPkeyDelete>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PersonContactNodeIdDelete>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateById?: Maybe<PersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyNodeIdUpdate>;
  /** A `PersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<WarehousePersonContactPersonContactIdFkeyPersonContactCreateInput>;
};

/** The fields on `personContact` to look up the row to update. */
export type PersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: UpdatePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `personContact` being updated. */
export type UpdatePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  isPrimary?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal?: Maybe<Scalars['Boolean']>;
  roles?: Maybe<Scalars['String']>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
};

/** Input for the nested mutation of `user` in the `PersonContactInput` mutation. */
export type UserPersonContactIdFkeyInverseInput = {
  /** Flag indicating whether all other `user` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<Array<UserUserPkeyConnect>>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByPin?: Maybe<Array<UserUserPinKeyConnect>>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<UserNodeIdConnect>>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<Array<UserUserPkeyDelete>>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByPin?: Maybe<Array<UserUserPinKeyDelete>>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<UserNodeIdDelete>>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<Array<UserOnUserForUserPersonContactIdFkeyUsingUserPkeyUpdate>>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByPin?: Maybe<Array<UserOnUserForUserPersonContactIdFkeyUsingUserPinKeyUpdate>>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PersonContactOnUserForUserPersonContactIdFkeyNodeIdUpdate>>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<Array<UserPersonContactIdFkeyUserCreateInput>>;
};

/** The fields on `user` to look up the row to connect. */
export type UserUserPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `user` to look up the row to connect. */
export type UserUserPinKeyConnect = {
  pin: Scalars['String'];
};

/** The globally unique `ID` look up for the row to connect. */
export type UserNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `user` to look up the row to delete. */
export type UserUserPkeyDelete = {
  id: Scalars['BigInt'];
};

/** The fields on `user` to look up the row to delete. */
export type UserUserPinKeyDelete = {
  pin: Scalars['String'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `user` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserForUserPersonContactIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserForUserPersonContactIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnUserForUserPersonContactIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
};

/** Input for the nested mutation of `userMessage` in the `UserInput` mutation. */
export type UserMessageUserIdFkeyInverseInput = {
  /** Flag indicating whether all other `userMessage` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `userMessage` for the far side of the relationship. */
  connectById?: Maybe<Array<UserMessageUserMessagePkeyConnect>>;
  /** The primary key(s) for `userMessage` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<UserMessageNodeIdConnect>>;
  /** The primary key(s) for `userMessage` for the far side of the relationship. */
  deleteById?: Maybe<Array<UserMessageUserMessagePkeyDelete>>;
  /** The primary key(s) for `userMessage` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<UserMessageNodeIdDelete>>;
  /** The primary key(s) and patch data for `userMessage` for the far side of the relationship. */
  updateById?: Maybe<Array<UserMessageOnUserMessageForUserMessageUserIdFkeyUsingUserMessagePkeyUpdate>>;
  /** The primary key(s) and patch data for `userMessage` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnUserMessageForUserMessageUserIdFkeyNodeIdUpdate>>;
  /** A `UserMessageInput` object that will be created and connected to this object. */
  create?: Maybe<Array<UserMessageUserIdFkeyUserMessageCreateInput>>;
};

/** The fields on `userMessage` to look up the row to connect. */
export type UserMessageUserMessagePkeyConnect = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type UserMessageNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `userMessage` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `userMessage` to look up the row to delete. */
export type UserMessageUserMessagePkeyDelete = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserMessageNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `userMessage` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `userMessage` to look up the row to update. */
export type UserMessageOnUserMessageForUserMessageUserIdFkeyUsingUserMessagePkeyUpdate = {
  /** An object where the defined keys will be set on the `userMessage` being updated. */
  patch: UpdateUserMessageOnUserMessageForUserMessageUserIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `userMessage` being updated. */
export type UpdateUserMessageOnUserMessageForUserMessageUserIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  actionLink?: Maybe<Scalars['String']>;
  actionText?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  header?: Maybe<Scalars['String']>;
  isRead?: Maybe<Scalars['Boolean']>;
  messageDate?: Maybe<Scalars['Datetime']>;
  priority?: Maybe<Scalars['BigFloat']>;
  userToUserId?: Maybe<UserMessageUserIdFkeyInput>;
};

/** Input for the nested mutation of `user` in the `UserMessageInput` mutation. */
export type UserMessageUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByPin?: Maybe<UserUserPinKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByPin?: Maybe<UserUserPinKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnUserMessageForUserMessageUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByPin?: Maybe<UserOnUserMessageForUserMessageUserIdFkeyUsingUserPinKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<UserMessageOnUserMessageForUserMessageUserIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<UserMessageUserIdFkeyUserCreateInput>;
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserMessageForUserMessageUserIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserMessageForUserMessageUserIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnUserMessageForUserMessageUserIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
};

/** Input for the nested mutation of `contactGroup` in the `UserInput` mutation. */
export type ContactGroupUserIdFkeyInverseInput = {
  /** Flag indicating whether all other `contactGroup` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  connectById?: Maybe<Array<ContactGroupContactGroupPkeyConnect>>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ContactGroupNodeIdConnect>>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  deleteById?: Maybe<Array<ContactGroupContactGroupPkeyDelete>>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ContactGroupNodeIdDelete>>;
  /** The primary key(s) and patch data for `contactGroup` for the far side of the relationship. */
  updateById?: Maybe<Array<ContactGroupOnContactGroupForContactGroupUserIdFkeyUsingContactGroupPkeyUpdate>>;
  /** The primary key(s) and patch data for `contactGroup` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnContactGroupForContactGroupUserIdFkeyNodeIdUpdate>>;
  /** A `ContactGroupInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ContactGroupUserIdFkeyContactGroupCreateInput>>;
};

/** The fields on `contactGroup` to look up the row to connect. */
export type ContactGroupContactGroupPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ContactGroupNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `contactGroup` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `contactGroup` to look up the row to delete. */
export type ContactGroupContactGroupPkeyDelete = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ContactGroupNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `contactGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `contactGroup` to look up the row to update. */
export type ContactGroupOnContactGroupForContactGroupUserIdFkeyUsingContactGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `contactGroup` being updated. */
  patch: UpdateContactGroupOnContactGroupForContactGroupUserIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `contactGroup` being updated. */
export type UpdateContactGroupOnContactGroupForContactGroupUserIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  groupDescription?: Maybe<Scalars['String']>;
  groupName?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<ContactGroupUserIdFkeyInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactGroupIdFkeyInverseInput>;
};

/** Input for the nested mutation of `user` in the `ContactGroupInput` mutation. */
export type ContactGroupUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByPin?: Maybe<UserUserPinKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByPin?: Maybe<UserUserPinKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnContactGroupForContactGroupUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByPin?: Maybe<UserOnContactGroupForContactGroupUserIdFkeyUsingUserPinKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<ContactGroupOnContactGroupForContactGroupUserIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<ContactGroupUserIdFkeyUserCreateInput>;
};

/** The fields on `user` to look up the row to update. */
export type UserOnContactGroupForContactGroupUserIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnContactGroupForContactGroupUserIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnContactGroupForContactGroupUserIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
};

/** The fields on `user` to look up the row to update. */
export type UserOnContactGroupForContactGroupUserIdFkeyUsingUserPinKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnContactGroupForContactGroupUserIdFkeyPatch;
  pin: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ContactGroupOnContactGroupForContactGroupUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
};

/** The `user` to be created by this mutation. */
export type ContactGroupUserIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
};

/** Input for the nested mutation of `contactGroupPersonContact` in the `ContactGroupInput` mutation. */
export type ContactGroupPersonContactGroupIdFkeyInverseInput = {
  /** Flag indicating whether all other `contactGroupPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  connectByGroupIdAndPersonContactId?: Maybe<Array<ContactGroupPersonContactContactGroupPersonContactPkeyConnect>>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ContactGroupPersonContactNodeIdConnect>>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  deleteByGroupIdAndPersonContactId?: Maybe<Array<ContactGroupPersonContactContactGroupPersonContactPkeyDelete>>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ContactGroupPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `contactGroupPersonContact` for the far side of the relationship. */
  updateByGroupIdAndPersonContactId?: Maybe<Array<ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyUsingContactGroupPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `contactGroupPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ContactGroupOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyNodeIdUpdate>>;
  /** A `ContactGroupPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ContactGroupPersonContactGroupIdFkeyContactGroupPersonContactCreateInput>>;
};

/** The fields on `contactGroupPersonContact` to look up the row to connect. */
export type ContactGroupPersonContactContactGroupPersonContactPkeyConnect = {
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ContactGroupPersonContactNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `contactGroupPersonContact` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `contactGroupPersonContact` to look up the row to delete. */
export type ContactGroupPersonContactContactGroupPersonContactPkeyDelete = {
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ContactGroupPersonContactNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `contactGroupPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `contactGroupPersonContact` to look up the row to update. */
export type ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyUsingContactGroupPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `contactGroupPersonContact` being updated. */
  patch: UpdateContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyPatch;
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `contactGroupPersonContact` being updated. */
export type UpdateContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyPatch = {
  personContactId?: Maybe<Scalars['BigInt']>;
  contactGroupToGroupId?: Maybe<ContactGroupPersonContactGroupIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `contactGroup` in the `ContactGroupPersonContactInput` mutation. */
export type ContactGroupPersonContactGroupIdFkeyInput = {
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  connectById?: Maybe<ContactGroupContactGroupPkeyConnect>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  connectByNodeId?: Maybe<ContactGroupNodeIdConnect>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  deleteById?: Maybe<ContactGroupContactGroupPkeyDelete>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ContactGroupNodeIdDelete>;
  /** The primary key(s) and patch data for `contactGroup` for the far side of the relationship. */
  updateById?: Maybe<ContactGroupOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyUsingContactGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `contactGroup` for the far side of the relationship. */
  updateByNodeId?: Maybe<ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyNodeIdUpdate>;
  /** A `ContactGroupInput` object that will be created and connected to this object. */
  create?: Maybe<ContactGroupPersonContactGroupIdFkeyContactGroupCreateInput>;
};

/** The fields on `contactGroup` to look up the row to update. */
export type ContactGroupOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyUsingContactGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `contactGroup` being updated. */
  patch: UpdateContactGroupOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `contactGroup` being updated. */
export type UpdateContactGroupOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  groupDescription?: Maybe<Scalars['String']>;
  groupName?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<ContactGroupUserIdFkeyInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactGroupIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `contactGroup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `contactGroup` being updated. */
  patch: ContactGroupPatch;
};

/** Represents an update to a `ContactGroup`. Fields that are set will be updated. */
export type ContactGroupPatch = {
  id?: Maybe<Scalars['BigInt']>;
  groupDescription?: Maybe<Scalars['String']>;
  groupName?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<ContactGroupUserIdFkeyInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactGroupIdFkeyInverseInput>;
};

/** The `contactGroup` to be created by this mutation. */
export type ContactGroupPersonContactGroupIdFkeyContactGroupCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  groupDescription: Scalars['String'];
  groupName: Scalars['String'];
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<ContactGroupUserIdFkeyInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactGroupIdFkeyInverseInput>;
};

/** Input for the nested mutation of `personContact` in the `ContactGroupPersonContactInput` mutation. */
export type ContactGroupPersonContactPersonContactIdFkeyInput = {
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectById?: Maybe<PersonContactPersonContactPkeyConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<PersonContactNodeIdConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteById?: Maybe<PersonContactPersonContactPkeyDelete>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PersonContactNodeIdDelete>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateById?: Maybe<PersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyNodeIdUpdate>;
  /** A `PersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<ContactGroupPersonContactPersonContactIdFkeyPersonContactCreateInput>;
};

/** The fields on `personContact` to look up the row to update. */
export type PersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: UpdatePersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `personContact` being updated. */
export type UpdatePersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  isPrimary?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal?: Maybe<Scalars['Boolean']>;
  roles?: Maybe<Scalars['String']>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
};

/** Input for the nested mutation of `contactGroupPersonContact` in the `PersonContactInput` mutation. */
export type ContactGroupPersonContactPersonContactIdFkeyInverseInput = {
  /** Flag indicating whether all other `contactGroupPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  connectByGroupIdAndPersonContactId?: Maybe<Array<ContactGroupPersonContactContactGroupPersonContactPkeyConnect>>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ContactGroupPersonContactNodeIdConnect>>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  deleteByGroupIdAndPersonContactId?: Maybe<Array<ContactGroupPersonContactContactGroupPersonContactPkeyDelete>>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ContactGroupPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `contactGroupPersonContact` for the far side of the relationship. */
  updateByGroupIdAndPersonContactId?: Maybe<Array<ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyUsingContactGroupPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `contactGroupPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyNodeIdUpdate>>;
  /** A `ContactGroupPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ContactGroupPersonContactPersonContactIdFkeyContactGroupPersonContactCreateInput>>;
};

/** The fields on `contactGroupPersonContact` to look up the row to update. */
export type ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyUsingContactGroupPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `contactGroupPersonContact` being updated. */
  patch: UpdateContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyPatch;
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `contactGroupPersonContact` being updated. */
export type UpdateContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyPatch = {
  groupId?: Maybe<Scalars['BigInt']>;
  contactGroupToGroupId?: Maybe<ContactGroupPersonContactGroupIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `contactGroupPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `contactGroupPersonContact` being updated. */
  patch: ContactGroupPersonContactPatch;
};

/** Represents an update to a `ContactGroupPersonContact`. Fields that are set will be updated. */
export type ContactGroupPersonContactPatch = {
  groupId?: Maybe<Scalars['BigInt']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  contactGroupToGroupId?: Maybe<ContactGroupPersonContactGroupIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInput>;
};

/** The `contactGroupPersonContact` to be created by this mutation. */
export type ContactGroupPersonContactPersonContactIdFkeyContactGroupPersonContactCreateInput = {
  groupId?: Maybe<Scalars['BigInt']>;
  contactGroupToGroupId?: Maybe<ContactGroupPersonContactGroupIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `personContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: PersonContactPatch;
};

/** Represents an update to a `PersonContact`. Fields that are set will be updated. */
export type PersonContactPatch = {
  id?: Maybe<Scalars['BigInt']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  isPrimary?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal?: Maybe<Scalars['Boolean']>;
  roles?: Maybe<Scalars['String']>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
};

/** The `personContact` to be created by this mutation. */
export type ContactGroupPersonContactPersonContactIdFkeyPersonContactCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ContactGroupOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `contactGroupPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `contactGroupPersonContact` being updated. */
  patch: ContactGroupPersonContactPatch;
};

/** The `contactGroupPersonContact` to be created by this mutation. */
export type ContactGroupPersonContactGroupIdFkeyContactGroupPersonContactCreateInput = {
  personContactId?: Maybe<Scalars['BigInt']>;
  contactGroupToGroupId?: Maybe<ContactGroupPersonContactGroupIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnContactGroupForContactGroupUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `contactGroup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `contactGroup` being updated. */
  patch: ContactGroupPatch;
};

/** The `contactGroup` to be created by this mutation. */
export type ContactGroupUserIdFkeyContactGroupCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  groupDescription: Scalars['String'];
  groupName: Scalars['String'];
  userToUserId?: Maybe<ContactGroupUserIdFkeyInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactGroupIdFkeyInverseInput>;
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserMessageForUserMessageUserIdFkeyUsingUserPinKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserMessageForUserMessageUserIdFkeyPatch;
  pin: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserMessageOnUserMessageForUserMessageUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The `user` to be created by this mutation. */
export type UserMessageUserIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnUserMessageForUserMessageUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userMessage` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `userMessage` being updated. */
  patch: UserMessagePatch;
};

/** Represents an update to a `UserMessage`. Fields that are set will be updated. */
export type UserMessagePatch = {
  id?: Maybe<Scalars['BigInt']>;
  actionLink?: Maybe<Scalars['String']>;
  actionText?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  header?: Maybe<Scalars['String']>;
  isRead?: Maybe<Scalars['Boolean']>;
  messageDate?: Maybe<Scalars['Datetime']>;
  priority?: Maybe<Scalars['BigFloat']>;
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<UserMessageUserIdFkeyInput>;
};

/** The `userMessage` to be created by this mutation. */
export type UserMessageUserIdFkeyUserMessageCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  actionLink?: Maybe<Scalars['String']>;
  actionText?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  header?: Maybe<Scalars['String']>;
  isRead: Scalars['Boolean'];
  messageDate?: Maybe<Scalars['Datetime']>;
  priority?: Maybe<Scalars['BigFloat']>;
  userToUserId?: Maybe<UserMessageUserIdFkeyInput>;
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserForUserPersonContactIdFkeyUsingUserPinKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserForUserPersonContactIdFkeyPatch;
  pin: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type PersonContactOnUserForUserPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The `user` to be created by this mutation. */
export type UserPersonContactIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `personContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: PersonContactPatch;
};

/** The `personContact` to be created by this mutation. */
export type WarehousePersonContactPersonContactIdFkeyPersonContactCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type WarehouseOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `warehousePersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `warehousePersonContact` being updated. */
  patch: WarehousePersonContactPatch;
};

/** Represents an update to a `WarehousePersonContact`. Fields that are set will be updated. */
export type WarehousePersonContactPatch = {
  warehouseId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  warehouseToWarehouseId?: Maybe<WarehousePersonContactWarehouseIdFkeyInput>;
  personContactToPersonContactId?: Maybe<WarehousePersonContactPersonContactIdFkeyInput>;
};

/** The `warehousePersonContact` to be created by this mutation. */
export type WarehousePersonContactWarehouseIdFkeyWarehousePersonContactCreateInput = {
  personContactId?: Maybe<Scalars['BigInt']>;
  warehouseToWarehouseId?: Maybe<WarehousePersonContactWarehouseIdFkeyInput>;
  personContactToPersonContactId?: Maybe<WarehousePersonContactPersonContactIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CountryOnWarehouseForWarehouseCountryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `warehouse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `warehouse` being updated. */
  patch: WarehousePatch;
};

/** Represents an update to a `Warehouse`. Fields that are set will be updated. */
export type WarehousePatch = {
  id?: Maybe<Scalars['String']>;
  warehouseName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<WarehouseCountryIdFkeyInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactWarehouseIdFkeyInverseInput>;
};

/** The `warehouse` to be created by this mutation. */
export type WarehouseCountryIdFkeyWarehouseCreateInput = {
  id: Scalars['String'];
  warehouseName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<WarehouseCountryIdFkeyInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactWarehouseIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type WarehouseOnWarehouseForWarehouseCountryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `country` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: CountryPatch;
};

/** Represents an update to a `Country`. Fields that are set will be updated. */
export type CountryPatch = {
  id?: Maybe<Scalars['String']>;
  countryName?: Maybe<Scalars['String']>;
  customersUsingId?: Maybe<CustomerCountryIdFkeyInverseInput>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** The `country` to be created by this mutation. */
export type WarehouseCountryIdFkeyCountryCreateInput = {
  id: Scalars['String'];
  countryName: Scalars['String'];
  customersUsingId?: Maybe<CustomerCountryIdFkeyInverseInput>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `warehouse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `warehouse` being updated. */
  patch: WarehousePatch;
};

/** The `warehouse` to be created by this mutation. */
export type WarehousePersonContactWarehouseIdFkeyWarehouseCreateInput = {
  id: Scalars['String'];
  warehouseName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<WarehouseCountryIdFkeyInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactWarehouseIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `warehousePersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `warehousePersonContact` being updated. */
  patch: WarehousePersonContactPatch;
};

/** The `warehousePersonContact` to be created by this mutation. */
export type WarehousePersonContactPersonContactIdFkeyWarehousePersonContactCreateInput = {
  warehouseId?: Maybe<Scalars['String']>;
  warehouseToWarehouseId?: Maybe<WarehousePersonContactWarehouseIdFkeyInput>;
  personContactToPersonContactId?: Maybe<WarehousePersonContactPersonContactIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperPersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `personContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: PersonContactPatch;
};

/** The `personContact` to be created by this mutation. */
export type ShipperPersonContactPersonContactIdFkeyPersonContactCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperOnShipperPersonContactForShipperPersonContactShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperPersonContact` being updated. */
  patch: ShipperPersonContactPatch;
};

/** Represents an update to a `ShipperPersonContact`. Fields that are set will be updated. */
export type ShipperPersonContactPatch = {
  shipperId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  shipperToShipperId?: Maybe<ShipperPersonContactShipperIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ShipperPersonContactPersonContactIdFkeyInput>;
};

/** The `shipperPersonContact` to be created by this mutation. */
export type ShipperPersonContactShipperIdFkeyShipperPersonContactCreateInput = {
  personContactId?: Maybe<Scalars['BigInt']>;
  shipperToShipperId?: Maybe<ShipperPersonContactShipperIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ShipperPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `shipperProjectionVessel` in the `ShipperInput` mutation. */
export type ShipperProjectionVesselShipperIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionVessel` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionVesselShipperProjectionVesselPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionVesselNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionVesselShipperProjectionVesselPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionVesselNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionVessel` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyUsingShipperProjectionVesselPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionVessel` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionVesselInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionVesselShipperIdFkeyShipperProjectionVesselCreateInput>>;
};

/** The fields on `shipperProjectionVessel` to look up the row to connect. */
export type ShipperProjectionVesselShipperProjectionVesselPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperProjectionVesselNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVessel` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `shipperProjectionVessel` to look up the row to delete. */
export type ShipperProjectionVesselShipperProjectionVesselPkeyDelete = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperProjectionVesselNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVessel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `shipperProjectionVessel` to look up the row to update. */
export type ShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyUsingShipperProjectionVesselPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
  patch: UpdateShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
export type UpdateShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  previousName?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipper` in the `ShipperProjectionVesselInput` mutation. */
export type ShipperProjectionVesselShipperIdFkeyInput = {
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectById?: Maybe<ShipperShipperPkeyConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperNodeIdConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteById?: Maybe<ShipperShipperPkeyDelete>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperNodeIdDelete>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateById?: Maybe<ShipperOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyUsingShipperPkeyUpdate>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyNodeIdUpdate>;
  /** A `ShipperInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionVesselShipperIdFkeyShipperCreateInput>;
};

/** The fields on `shipper` to look up the row to update. */
export type ShipperOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyUsingShipperPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: UpdateShipperOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyPatch;
  id: Scalars['String'];
};

/** An object where the defined keys will be set on the `shipper` being updated. */
export type UpdateShipperOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipperProjectionProduct` in the `ShipperInput` mutation. */
export type ShipperProjectionProductShipperIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionProduct` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyUsingShipperProjectionProductPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionProductInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionProductShipperIdFkeyShipperProjectionProductCreateInput>>;
};

/** The fields on `shipperProjectionProduct` to look up the row to connect. */
export type ShipperProjectionProductShipperProjectionProductPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperProjectionProductNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperProjectionProduct` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `shipperProjectionProduct` to look up the row to delete. */
export type ShipperProjectionProductShipperProjectionProductPkeyDelete = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperProjectionProductNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperProjectionProduct` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `shipperProjectionProduct` to look up the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyUsingShipperProjectionProductPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
export type UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipper` in the `ShipperProjectionProductInput` mutation. */
export type ShipperProjectionProductShipperIdFkeyInput = {
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectById?: Maybe<ShipperShipperPkeyConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperNodeIdConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteById?: Maybe<ShipperShipperPkeyDelete>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperNodeIdDelete>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateById?: Maybe<ShipperOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyUsingShipperPkeyUpdate>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyNodeIdUpdate>;
  /** A `ShipperInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionProductShipperIdFkeyShipperCreateInput>;
};

/** The fields on `shipper` to look up the row to update. */
export type ShipperOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyUsingShipperPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: UpdateShipperOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyPatch;
  id: Scalars['String'];
};

/** An object where the defined keys will be set on the `shipper` being updated. */
export type UpdateShipperOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipperProjection` in the `ShipperInput` mutation. */
export type ShipperProjectionShipperIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjection` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionShipperProjectionPkeyConnect>>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionNodeIdConnect>>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionShipperProjectionPkeyDelete>>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjection` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionOnShipperProjectionForShipperProjectionShipperIdFkeyUsingShipperProjectionPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjection` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperOnShipperProjectionForShipperProjectionShipperIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionShipperIdFkeyShipperProjectionCreateInput>>;
};

/** The fields on `shipperProjection` to look up the row to connect. */
export type ShipperProjectionShipperProjectionPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperProjectionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperProjection` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `shipperProjection` to look up the row to delete. */
export type ShipperProjectionShipperProjectionPkeyDelete = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperProjectionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperProjection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `shipperProjection` to look up the row to update. */
export type ShipperProjectionOnShipperProjectionForShipperProjectionShipperIdFkeyUsingShipperProjectionPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjection` being updated. */
  patch: UpdateShipperProjectionOnShipperProjectionForShipperProjectionShipperIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `shipperProjection` being updated. */
export type UpdateShipperProjectionOnShipperProjectionForShipperProjectionShipperIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  completedAt?: Maybe<Scalars['Datetime']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  shipperToShipperId?: Maybe<ShipperProjectionShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<FkShipperProjectionIdInverseInput>;
};

/** Input for the nested mutation of `shipper` in the `ShipperProjectionInput` mutation. */
export type ShipperProjectionShipperIdFkeyInput = {
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectById?: Maybe<ShipperShipperPkeyConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperNodeIdConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteById?: Maybe<ShipperShipperPkeyDelete>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperNodeIdDelete>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateById?: Maybe<ShipperOnShipperProjectionForShipperProjectionShipperIdFkeyUsingShipperPkeyUpdate>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionOnShipperProjectionForShipperProjectionShipperIdFkeyNodeIdUpdate>;
  /** A `ShipperInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionShipperIdFkeyShipperCreateInput>;
};

/** The fields on `shipper` to look up the row to update. */
export type ShipperOnShipperProjectionForShipperProjectionShipperIdFkeyUsingShipperPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: UpdateShipperOnShipperProjectionForShipperProjectionShipperIdFkeyPatch;
  id: Scalars['String'];
};

/** An object where the defined keys will be set on the `shipper` being updated. */
export type UpdateShipperOnShipperProjectionForShipperProjectionShipperIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionOnShipperProjectionForShipperProjectionShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: ShipperPatch;
};

/** Represents an update to a `Shipper`. Fields that are set will be updated. */
export type ShipperPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
};

/** The `shipper` to be created by this mutation. */
export type ShipperProjectionShipperIdFkeyShipperCreateInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipperProjectionEntry` in the `ShipperProjectionInput` mutation. */
export type FkShipperProjectionIdInverseInput = {
  /** Flag indicating whether all other `shipperProjectionEntry` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionEntryShipperProjectionEntryPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionEntryNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionEntryShipperProjectionEntryPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionEntryNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionEntry` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionEntryOnShipperProjectionEntryForFkShipperProjectionIdUsingShipperProjectionEntryPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperProjectionOnShipperProjectionEntryForFkShipperProjectionIdNodeIdUpdate>>;
  /** A `ShipperProjectionEntryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkShipperProjectionIdShipperProjectionEntryCreateInput>>;
};

/** The fields on `shipperProjectionEntry` to look up the row to connect. */
export type ShipperProjectionEntryShipperProjectionEntryPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperProjectionEntryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperProjectionEntry` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `shipperProjectionEntry` to look up the row to delete. */
export type ShipperProjectionEntryShipperProjectionEntryPkeyDelete = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperProjectionEntryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperProjectionEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `shipperProjectionEntry` to look up the row to update. */
export type ShipperProjectionEntryOnShipperProjectionEntryForFkShipperProjectionIdUsingShipperProjectionEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
  patch: UpdateShipperProjectionEntryOnShipperProjectionEntryForFkShipperProjectionIdPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
export type UpdateShipperProjectionEntryOnShipperProjectionEntryForFkShipperProjectionIdPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionEntryVesselIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
  shipperProjectionToShipperProjectionId?: Maybe<FkShipperProjectionIdInput>;
};

/** Input for the nested mutation of `shipperProjectionVessel` in the `ShipperProjectionEntryInput` mutation. */
export type ShipperProjectionEntryVesselIdFkeyInput = {
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  connectById?: Maybe<ShipperProjectionVesselShipperProjectionVesselPkeyConnect>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperProjectionVesselNodeIdConnect>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  deleteById?: Maybe<ShipperProjectionVesselShipperProjectionVesselPkeyDelete>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperProjectionVesselNodeIdDelete>;
  /** The primary key(s) and patch data for `shipperProjectionVessel` for the far side of the relationship. */
  updateById?: Maybe<ShipperProjectionVesselOnShipperProjectionEntryForShipperProjectionEntryVesselIdFkeyUsingShipperProjectionVesselPkeyUpdate>;
  /** The primary key(s) and patch data for `shipperProjectionVessel` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryVesselIdFkeyNodeIdUpdate>;
  /** A `ShipperProjectionVesselInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionEntryVesselIdFkeyShipperProjectionVesselCreateInput>;
};

/** The fields on `shipperProjectionVessel` to look up the row to update. */
export type ShipperProjectionVesselOnShipperProjectionEntryForShipperProjectionEntryVesselIdFkeyUsingShipperProjectionVesselPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
  patch: UpdateShipperProjectionVesselOnShipperProjectionEntryForShipperProjectionEntryVesselIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
export type UpdateShipperProjectionVesselOnShipperProjectionEntryForShipperProjectionEntryVesselIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  previousName?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipperProjectionEntry` in the `ShipperProjectionVesselInput` mutation. */
export type ShipperProjectionEntryVesselIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionEntry` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionEntryShipperProjectionEntryPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionEntryNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionEntryShipperProjectionEntryPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionEntryNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionEntry` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryVesselIdFkeyUsingShipperProjectionEntryPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperProjectionVesselOnShipperProjectionEntryForShipperProjectionEntryVesselIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionEntryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionEntryVesselIdFkeyShipperProjectionEntryCreateInput>>;
};

/** The fields on `shipperProjectionEntry` to look up the row to update. */
export type ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryVesselIdFkeyUsingShipperProjectionEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
  patch: UpdateShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryVesselIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
export type UpdateShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryVesselIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  productId?: Maybe<Scalars['BigInt']>;
  shipperProjectionId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionEntryVesselIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
  shipperProjectionToShipperProjectionId?: Maybe<FkShipperProjectionIdInput>;
};

/** Input for the nested mutation of `shipperProjectionProduct` in the `ShipperProjectionEntryInput` mutation. */
export type ShipperProjectionEntryProductIdFkeyInput = {
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectById?: Maybe<ShipperProjectionProductShipperProjectionProductPkeyConnect>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperProjectionProductNodeIdConnect>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteById?: Maybe<ShipperProjectionProductShipperProjectionProductPkeyDelete>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperProjectionProductNodeIdDelete>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateById?: Maybe<ShipperProjectionProductOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyUsingShipperProjectionProductPkeyUpdate>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyNodeIdUpdate>;
  /** A `ShipperProjectionProductInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionEntryProductIdFkeyShipperProjectionProductCreateInput>;
};

/** The fields on `shipperProjectionProduct` to look up the row to update. */
export type ShipperProjectionProductOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyUsingShipperProjectionProductPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: UpdateShipperProjectionProductOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
export type UpdateShipperProjectionProductOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipperProjectionEntry` in the `ShipperProjectionProductInput` mutation. */
export type ShipperProjectionEntryProductIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionEntry` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionEntryShipperProjectionEntryPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionEntryNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionEntryShipperProjectionEntryPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionEntryNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionEntry` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyUsingShipperProjectionEntryPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperProjectionProductOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionEntryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionEntryProductIdFkeyShipperProjectionEntryCreateInput>>;
};

/** The fields on `shipperProjectionEntry` to look up the row to update. */
export type ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyUsingShipperProjectionEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
  patch: UpdateShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
export type UpdateShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperProjectionId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionEntryVesselIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
  shipperProjectionToShipperProjectionId?: Maybe<FkShipperProjectionIdInput>;
};

/** Input for the nested mutation of `shipperProjection` in the `ShipperProjectionEntryInput` mutation. */
export type FkShipperProjectionIdInput = {
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  connectById?: Maybe<ShipperProjectionShipperProjectionPkeyConnect>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperProjectionNodeIdConnect>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  deleteById?: Maybe<ShipperProjectionShipperProjectionPkeyDelete>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperProjectionNodeIdDelete>;
  /** The primary key(s) and patch data for `shipperProjection` for the far side of the relationship. */
  updateById?: Maybe<ShipperProjectionOnShipperProjectionEntryForFkShipperProjectionIdUsingShipperProjectionPkeyUpdate>;
  /** The primary key(s) and patch data for `shipperProjection` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionEntryOnShipperProjectionEntryForFkShipperProjectionIdNodeIdUpdate>;
  /** A `ShipperProjectionInput` object that will be created and connected to this object. */
  create?: Maybe<FkShipperProjectionIdShipperProjectionCreateInput>;
};

/** The fields on `shipperProjection` to look up the row to update. */
export type ShipperProjectionOnShipperProjectionEntryForFkShipperProjectionIdUsingShipperProjectionPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjection` being updated. */
  patch: UpdateShipperProjectionOnShipperProjectionEntryForFkShipperProjectionIdPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `shipperProjection` being updated. */
export type UpdateShipperProjectionOnShipperProjectionEntryForFkShipperProjectionIdPatch = {
  id?: Maybe<Scalars['BigInt']>;
  completedAt?: Maybe<Scalars['Datetime']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<FkShipperProjectionIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionEntryOnShipperProjectionEntryForFkShipperProjectionIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjection` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjection` being updated. */
  patch: ShipperProjectionPatch;
};

/** Represents an update to a `ShipperProjection`. Fields that are set will be updated. */
export type ShipperProjectionPatch = {
  id?: Maybe<Scalars['BigInt']>;
  completedAt?: Maybe<Scalars['Datetime']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<FkShipperProjectionIdInverseInput>;
};

/** The `shipperProjection` to be created by this mutation. */
export type FkShipperProjectionIdShipperProjectionCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  completedAt?: Maybe<Scalars['Datetime']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<FkShipperProjectionIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionProductOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
  patch: ShipperProjectionEntryPatch;
};

/** Represents an update to a `ShipperProjectionEntry`. Fields that are set will be updated. */
export type ShipperProjectionEntryPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  shipperProjectionId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionEntryVesselIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
  shipperProjectionToShipperProjectionId?: Maybe<FkShipperProjectionIdInput>;
};

/** The `shipperProjectionEntry` to be created by this mutation. */
export type ShipperProjectionEntryProductIdFkeyShipperProjectionEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperProjectionId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionEntryVesselIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
  shipperProjectionToShipperProjectionId?: Maybe<FkShipperProjectionIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionProduct` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: ShipperProjectionProductPatch;
};

/** Represents an update to a `ShipperProjectionProduct`. Fields that are set will be updated. */
export type ShipperProjectionProductPatch = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** The `shipperProjectionProduct` to be created by this mutation. */
export type ShipperProjectionEntryProductIdFkeyShipperProjectionProductCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionVesselOnShipperProjectionEntryForShipperProjectionEntryVesselIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
  patch: ShipperProjectionEntryPatch;
};

/** The `shipperProjectionEntry` to be created by this mutation. */
export type ShipperProjectionEntryVesselIdFkeyShipperProjectionEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  productId?: Maybe<Scalars['BigInt']>;
  shipperProjectionId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionEntryVesselIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
  shipperProjectionToShipperProjectionId?: Maybe<FkShipperProjectionIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryVesselIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVessel` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
  patch: ShipperProjectionVesselPatch;
};

/** Represents an update to a `ShipperProjectionVessel`. Fields that are set will be updated. */
export type ShipperProjectionVesselPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  previousName?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselIdFkeyInverseInput>;
};

/** The `shipperProjectionVessel` to be created by this mutation. */
export type ShipperProjectionEntryVesselIdFkeyShipperProjectionVesselCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  previousName?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionOnShipperProjectionEntryForFkShipperProjectionIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
  patch: ShipperProjectionEntryPatch;
};

/** The `shipperProjectionEntry` to be created by this mutation. */
export type FkShipperProjectionIdShipperProjectionEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionEntryVesselIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
  shipperProjectionToShipperProjectionId?: Maybe<FkShipperProjectionIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperOnShipperProjectionForShipperProjectionShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjection` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjection` being updated. */
  patch: ShipperProjectionPatch;
};

/** The `shipperProjection` to be created by this mutation. */
export type ShipperProjectionShipperIdFkeyShipperProjectionCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  completedAt?: Maybe<Scalars['Datetime']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  shipperToShipperId?: Maybe<ShipperProjectionShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<FkShipperProjectionIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: ShipperPatch;
};

/** The `shipper` to be created by this mutation. */
export type ShipperProjectionProductShipperIdFkeyShipperCreateInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionProduct` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: ShipperProjectionProductPatch;
};

/** The `shipperProjectionProduct` to be created by this mutation. */
export type ShipperProjectionProductShipperIdFkeyShipperProjectionProductCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: ShipperPatch;
};

/** The `shipper` to be created by this mutation. */
export type ShipperProjectionVesselShipperIdFkeyShipperCreateInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVessel` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
  patch: ShipperProjectionVesselPatch;
};

/** The `shipperProjectionVessel` to be created by this mutation. */
export type ShipperProjectionVesselShipperIdFkeyShipperProjectionVesselCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  previousName?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CountryOnShipperForShipperCountryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: ShipperPatch;
};

/** The `shipper` to be created by this mutation. */
export type ShipperCountryIdFkeyShipperCreateInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperOnShipperForShipperCountryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `country` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: CountryPatch;
};

/** The `country` to be created by this mutation. */
export type ShipperCountryIdFkeyCountryCreateInput = {
  id: Scalars['String'];
  countryName: Scalars['String'];
  customersUsingId?: Maybe<CustomerCountryIdFkeyInverseInput>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperPersonContactOnShipperPersonContactForShipperPersonContactShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: ShipperPatch;
};

/** The `shipper` to be created by this mutation. */
export type ShipperPersonContactShipperIdFkeyShipperCreateInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperPersonContact` being updated. */
  patch: ShipperPersonContactPatch;
};

/** The `shipperPersonContact` to be created by this mutation. */
export type ShipperPersonContactPersonContactIdFkeyShipperPersonContactCreateInput = {
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperPersonContactShipperIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ShipperPersonContactPersonContactIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `personContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: PersonContactPatch;
};

/** The `personContact` to be created by this mutation. */
export type CustomerPersonContactPersonContactIdFkeyPersonContactCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerPersonContact` being updated. */
  patch: CustomerPersonContactPatch;
};

/** Represents an update to a `CustomerPersonContact`. Fields that are set will be updated. */
export type CustomerPersonContactPatch = {
  customerId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  customerToCustomerId?: Maybe<CustomerPersonContactCustomerIdFkeyInput>;
  personContactToPersonContactId?: Maybe<CustomerPersonContactPersonContactIdFkeyInput>;
};

/** The `customerPersonContact` to be created by this mutation. */
export type CustomerPersonContactCustomerIdFkeyCustomerPersonContactCreateInput = {
  personContactId?: Maybe<Scalars['BigInt']>;
  customerToCustomerId?: Maybe<CustomerPersonContactCustomerIdFkeyInput>;
  personContactToPersonContactId?: Maybe<CustomerPersonContactPersonContactIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CountryOnCustomerForCustomerCountryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: CustomerPatch;
};

/** Represents an update to a `Customer`. Fields that are set will be updated. */
export type CustomerPatch = {
  id?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  countryToCountryId?: Maybe<CustomerCountryIdFkeyInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
};

/** The `customer` to be created by this mutation. */
export type CustomerCountryIdFkeyCustomerCreateInput = {
  id: Scalars['String'];
  customerName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active: Scalars['Boolean'];
  countryToCountryId?: Maybe<CustomerCountryIdFkeyInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerOnCustomerForCustomerCountryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `country` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: CountryPatch;
};

/** The `country` to be created by this mutation. */
export type CustomerCountryIdFkeyCountryCreateInput = {
  id: Scalars['String'];
  countryName: Scalars['String'];
  customersUsingId?: Maybe<CustomerCountryIdFkeyInverseInput>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: CustomerPatch;
};

/** The `customer` to be created by this mutation. */
export type CustomerPersonContactCustomerIdFkeyCustomerCreateInput = {
  id: Scalars['String'];
  customerName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active: Scalars['Boolean'];
  countryToCountryId?: Maybe<CustomerCountryIdFkeyInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerPersonContact` being updated. */
  patch: CustomerPersonContactPatch;
};

/** The `customerPersonContact` to be created by this mutation. */
export type CustomerPersonContactPersonContactIdFkeyCustomerPersonContactCreateInput = {
  customerId?: Maybe<Scalars['String']>;
  customerToCustomerId?: Maybe<CustomerPersonContactCustomerIdFkeyInput>;
  personContactToPersonContactId?: Maybe<CustomerPersonContactPersonContactIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnUserForUserPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `personContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: PersonContactPatch;
};

/** The `personContact` to be created by this mutation. */
export type UserPersonContactIdFkeyPersonContactCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
};

/** The output of our create `UserMessage` mutation. */
export type CreateUserMessagePayload = {
  __typename?: 'CreateUserMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserMessage` that was created by this mutation. */
  userMessage?: Maybe<UserMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserMessage`. */
  user?: Maybe<User>;
  /** An edge for our `UserMessage`. May be used by Relay 1. */
  userMessageEdge?: Maybe<UserMessagesEdge>;
};


/** The output of our create `UserMessage` mutation. */
export type CreateUserMessagePayloadUserMessageEdgeArgs = {
  orderBy?: Maybe<Array<UserMessagesOrderBy>>;
};

/** All input for the create `UserMessage` mutation. */
export type CreateUserMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserMessage` to be created by this mutation. */
  userMessage: UserMessageInput;
};

/** An input for mutations affecting `UserMessage` */
export type UserMessageInput = {
  id?: Maybe<Scalars['BigInt']>;
  actionLink?: Maybe<Scalars['String']>;
  actionText?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  header?: Maybe<Scalars['String']>;
  isRead: Scalars['Boolean'];
  messageDate?: Maybe<Scalars['Datetime']>;
  priority?: Maybe<Scalars['BigFloat']>;
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<UserMessageUserIdFkeyInput>;
};

/** The output of our create `ContactGroup` mutation. */
export type CreateContactGroupPayload = {
  __typename?: 'CreateContactGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroup` that was created by this mutation. */
  contactGroup?: Maybe<ContactGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ContactGroup`. */
  user?: Maybe<User>;
  /** An edge for our `ContactGroup`. May be used by Relay 1. */
  contactGroupEdge?: Maybe<ContactGroupsEdge>;
};


/** The output of our create `ContactGroup` mutation. */
export type CreateContactGroupPayloadContactGroupEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupsOrderBy>>;
};

/** All input for the create `ContactGroup` mutation. */
export type CreateContactGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroup` to be created by this mutation. */
  contactGroup: ContactGroupInput;
};

/** An input for mutations affecting `ContactGroup` */
export type ContactGroupInput = {
  id?: Maybe<Scalars['BigInt']>;
  groupDescription: Scalars['String'];
  groupName: Scalars['String'];
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<ContactGroupUserIdFkeyInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactGroupIdFkeyInverseInput>;
};

/** The output of our create `ContactGroupPersonContact` mutation. */
export type CreateContactGroupPersonContactPayload = {
  __typename?: 'CreateContactGroupPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroupPersonContact` that was created by this mutation. */
  contactGroupPersonContact?: Maybe<ContactGroupPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ContactGroup` that is related to this `ContactGroupPersonContact`. */
  group?: Maybe<ContactGroup>;
  /** Reads a single `PersonContact` that is related to this `ContactGroupPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ContactGroupPersonContact`. May be used by Relay 1. */
  contactGroupPersonContactEdge?: Maybe<ContactGroupPersonContactsEdge>;
};


/** The output of our create `ContactGroupPersonContact` mutation. */
export type CreateContactGroupPersonContactPayloadContactGroupPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupPersonContactsOrderBy>>;
};

/** All input for the create `ContactGroupPersonContact` mutation. */
export type CreateContactGroupPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroupPersonContact` to be created by this mutation. */
  contactGroupPersonContact: ContactGroupPersonContactInput;
};

/** An input for mutations affecting `ContactGroupPersonContact` */
export type ContactGroupPersonContactInput = {
  groupId?: Maybe<Scalars['BigInt']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  contactGroupToGroupId?: Maybe<ContactGroupPersonContactGroupIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInput>;
};

/** The output of our create `Country` mutation. */
export type CreateCountryPayload = {
  __typename?: 'CreateCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was created by this mutation. */
  country?: Maybe<Country>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our create `Country` mutation. */
export type CreateCountryPayloadCountryEdgeArgs = {
  orderBy?: Maybe<Array<CountriesOrderBy>>;
};

/** All input for the create `Country` mutation. */
export type CreateCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` to be created by this mutation. */
  country: CountryInput;
};

/** An input for mutations affecting `Country` */
export type CountryInput = {
  id: Scalars['String'];
  countryName: Scalars['String'];
  customersUsingId?: Maybe<CustomerCountryIdFkeyInverseInput>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** The output of our create `Customer` mutation. */
export type CreateCustomerPayload = {
  __typename?: 'CreateCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was created by this mutation. */
  customer?: Maybe<Customer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Customer`. */
  country?: Maybe<Country>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our create `Customer` mutation. */
export type CreateCustomerPayloadCustomerEdgeArgs = {
  orderBy?: Maybe<Array<CustomersOrderBy>>;
};

/** All input for the create `Customer` mutation. */
export type CreateCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` to be created by this mutation. */
  customer: CustomerInput;
};

/** An input for mutations affecting `Customer` */
export type CustomerInput = {
  id: Scalars['String'];
  customerName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active: Scalars['Boolean'];
  countryToCountryId?: Maybe<CustomerCountryIdFkeyInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
};

/** The output of our create `CustomerPersonContact` mutation. */
export type CreateCustomerPersonContactPayload = {
  __typename?: 'CreateCustomerPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPersonContact` that was created by this mutation. */
  customerPersonContact?: Maybe<CustomerPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `CustomerPersonContact`. */
  customer?: Maybe<Customer>;
  /** Reads a single `PersonContact` that is related to this `CustomerPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `CustomerPersonContact`. May be used by Relay 1. */
  customerPersonContactEdge?: Maybe<CustomerPersonContactsEdge>;
};


/** The output of our create `CustomerPersonContact` mutation. */
export type CreateCustomerPersonContactPayloadCustomerPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<CustomerPersonContactsOrderBy>>;
};

/** All input for the create `CustomerPersonContact` mutation. */
export type CreateCustomerPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPersonContact` to be created by this mutation. */
  customerPersonContact: CustomerPersonContactInput;
};

/** An input for mutations affecting `CustomerPersonContact` */
export type CustomerPersonContactInput = {
  customerId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  customerToCustomerId?: Maybe<CustomerPersonContactCustomerIdFkeyInput>;
  personContactToPersonContactId?: Maybe<CustomerPersonContactPersonContactIdFkeyInput>;
};

/** The output of our create `PersonContact` mutation. */
export type CreatePersonContactPayload = {
  __typename?: 'CreatePersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PersonContact` that was created by this mutation. */
  personContact?: Maybe<PersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PersonContact`. May be used by Relay 1. */
  personContactEdge?: Maybe<PersonContactsEdge>;
};


/** The output of our create `PersonContact` mutation. */
export type CreatePersonContactPayloadPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
};

/** All input for the create `PersonContact` mutation. */
export type CreatePersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PersonContact` to be created by this mutation. */
  personContact: PersonContactInput;
};

/** An input for mutations affecting `PersonContact` */
export type PersonContactInput = {
  id?: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
};

/** The output of our create `Shipper` mutation. */
export type CreateShipperPayload = {
  __typename?: 'CreateShipperPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipper` that was created by this mutation. */
  shipper?: Maybe<Shipper>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Shipper`. */
  country?: Maybe<Country>;
  /** An edge for our `Shipper`. May be used by Relay 1. */
  shipperEdge?: Maybe<ShippersEdge>;
};


/** The output of our create `Shipper` mutation. */
export type CreateShipperPayloadShipperEdgeArgs = {
  orderBy?: Maybe<Array<ShippersOrderBy>>;
};

/** All input for the create `Shipper` mutation. */
export type CreateShipperInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipper` to be created by this mutation. */
  shipper: ShipperInput;
};

/** An input for mutations affecting `Shipper` */
export type ShipperInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
};

/** The output of our create `ShipperPersonContact` mutation. */
export type CreateShipperPersonContactPayload = {
  __typename?: 'CreateShipperPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperPersonContact` that was created by this mutation. */
  shipperPersonContact?: Maybe<ShipperPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperPersonContact`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `PersonContact` that is related to this `ShipperPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ShipperPersonContact`. May be used by Relay 1. */
  shipperPersonContactEdge?: Maybe<ShipperPersonContactsEdge>;
};


/** The output of our create `ShipperPersonContact` mutation. */
export type CreateShipperPersonContactPayloadShipperPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ShipperPersonContactsOrderBy>>;
};

/** All input for the create `ShipperPersonContact` mutation. */
export type CreateShipperPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperPersonContact` to be created by this mutation. */
  shipperPersonContact: ShipperPersonContactInput;
};

/** An input for mutations affecting `ShipperPersonContact` */
export type ShipperPersonContactInput = {
  shipperId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  shipperToShipperId?: Maybe<ShipperPersonContactShipperIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ShipperPersonContactPersonContactIdFkeyInput>;
};

/** The output of our create `Warehouse` mutation. */
export type CreateWarehousePayload = {
  __typename?: 'CreateWarehousePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` that was created by this mutation. */
  warehouse?: Maybe<Warehouse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Warehouse`. */
  country?: Maybe<Country>;
  /** An edge for our `Warehouse`. May be used by Relay 1. */
  warehouseEdge?: Maybe<WarehousesEdge>;
};


/** The output of our create `Warehouse` mutation. */
export type CreateWarehousePayloadWarehouseEdgeArgs = {
  orderBy?: Maybe<Array<WarehousesOrderBy>>;
};

/** All input for the create `Warehouse` mutation. */
export type CreateWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` to be created by this mutation. */
  warehouse: WarehouseInput;
};

/** An input for mutations affecting `Warehouse` */
export type WarehouseInput = {
  id: Scalars['String'];
  warehouseName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<WarehouseCountryIdFkeyInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactWarehouseIdFkeyInverseInput>;
};

/** The output of our create `WarehousePersonContact` mutation. */
export type CreateWarehousePersonContactPayload = {
  __typename?: 'CreateWarehousePersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WarehousePersonContact` that was created by this mutation. */
  warehousePersonContact?: Maybe<WarehousePersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Warehouse` that is related to this `WarehousePersonContact`. */
  warehouse?: Maybe<Warehouse>;
  /** Reads a single `PersonContact` that is related to this `WarehousePersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `WarehousePersonContact`. May be used by Relay 1. */
  warehousePersonContactEdge?: Maybe<WarehousePersonContactsEdge>;
};


/** The output of our create `WarehousePersonContact` mutation. */
export type CreateWarehousePersonContactPayloadWarehousePersonContactEdgeArgs = {
  orderBy?: Maybe<Array<WarehousePersonContactsOrderBy>>;
};

/** All input for the create `WarehousePersonContact` mutation. */
export type CreateWarehousePersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WarehousePersonContact` to be created by this mutation. */
  warehousePersonContact: WarehousePersonContactInput;
};

/** An input for mutations affecting `WarehousePersonContact` */
export type WarehousePersonContactInput = {
  warehouseId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  warehouseToWarehouseId?: Maybe<WarehousePersonContactWarehouseIdFkeyInput>;
  personContactToPersonContactId?: Maybe<WarehousePersonContactPersonContactIdFkeyInput>;
};

/** The output of our create `ChileDepartureInspectionPallet` mutation. */
export type CreateChileDepartureInspectionPalletPayload = {
  __typename?: 'CreateChileDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ChileDepartureInspectionPallet` that was created by this mutation. */
  chileDepartureInspectionPallet?: Maybe<ChileDepartureInspectionPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ChileDepartureInspectionPallet`. May be used by Relay 1. */
  chileDepartureInspectionPalletEdge?: Maybe<ChileDepartureInspectionPalletsEdge>;
};


/** The output of our create `ChileDepartureInspectionPallet` mutation. */
export type CreateChileDepartureInspectionPalletPayloadChileDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<ChileDepartureInspectionPalletsOrderBy>>;
};

/** All input for the create `ChileDepartureInspectionPallet` mutation. */
export type CreateChileDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ChileDepartureInspectionPallet` to be created by this mutation. */
  chileDepartureInspectionPallet: ChileDepartureInspectionPalletInput;
};

/** An input for mutations affecting `ChileDepartureInspectionPallet` */
export type ChileDepartureInspectionPalletInput = {
  id: Scalars['String'];
  lotId?: Maybe<Scalars['String']>;
  lotNumber?: Maybe<Scalars['String']>;
  locationName?: Maybe<Scalars['String']>;
  shipper?: Maybe<Scalars['String']>;
  inspectionDate?: Maybe<Scalars['Date']>;
  productName?: Maybe<Scalars['String']>;
  packingType?: Maybe<Scalars['String']>;
  productType?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  supervisor?: Maybe<Scalars['String']>;
  palletNumber?: Maybe<Scalars['String']>;
  boxesCount?: Maybe<Scalars['BigFloat']>;
  netWeight?: Maybe<Scalars['BigFloat']>;
  grower?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  packingDate?: Maybe<Scalars['Date']>;
  label?: Maybe<Scalars['String']>;
  temperature?: Maybe<Scalars['String']>;
  openAppearance?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  stem?: Maybe<Scalars['String']>;
  texture?: Maybe<Scalars['String']>;
  bunchesCount?: Maybe<Scalars['BigFloat']>;
  brix?: Maybe<Scalars['BigFloat']>;
  diameterMin?: Maybe<Scalars['BigFloat']>;
  diameterMax?: Maybe<Scalars['BigFloat']>;
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  decayPct?: Maybe<Scalars['BigFloat']>;
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  shatterPct?: Maybe<Scalars['BigFloat']>;
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  scoreName?: Maybe<Scalars['String']>;
  reportLink?: Maybe<Scalars['String']>;
  imagesLink?: Maybe<Scalars['String']>;
};

/** The output of our create `PeruDepartureInspection` mutation. */
export type CreatePeruDepartureInspectionPayload = {
  __typename?: 'CreatePeruDepartureInspectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspection` that was created by this mutation. */
  peruDepartureInspection?: Maybe<PeruDepartureInspection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PeruDepartureInspection`. May be used by Relay 1. */
  peruDepartureInspectionEdge?: Maybe<PeruDepartureInspectionsEdge>;
};


/** The output of our create `PeruDepartureInspection` mutation. */
export type CreatePeruDepartureInspectionPayloadPeruDepartureInspectionEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionsOrderBy>>;
};

/** All input for the create `PeruDepartureInspection` mutation. */
export type CreatePeruDepartureInspectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspection` to be created by this mutation. */
  peruDepartureInspection: PeruDepartureInspectionInput;
};

/** An input for mutations affecting `PeruDepartureInspection` */
export type PeruDepartureInspectionInput = {
  containerId: Scalars['String'];
  avgBunchesPerBox: Scalars['BigFloat'];
  avgNetWeight: Scalars['BigFloat'];
  bagsPerBox: Scalars['BigFloat'];
  bagType?: Maybe<Scalars['String']>;
  brand: Scalars['String'];
  brixAvg: Scalars['BigFloat'];
  brixMax: Scalars['BigFloat'];
  brixMin: Scalars['BigFloat'];
  category: Scalars['String'];
  comments: Scalars['String'];
  conditionScore: Scalars['BigFloat'];
  departureWeek: Scalars['String'];
  destination: Scalars['String'];
  exporter: Scalars['String'];
  inspectionDate: Scalars['Date'];
  packingDate: Scalars['Date'];
  packingHouse: Scalars['String'];
  packingMaterial: Scalars['String'];
  presentation: Scalars['String'];
  qualityScore: Scalars['BigFloat'];
  variety: Scalars['String'];
  peruDepartureInspectionPalletsUsingContainerId?: Maybe<FkContainerInverseInput>;
};

/** Input for the nested mutation of `peruDepartureInspectionPallet` in the `PeruDepartureInspectionInput` mutation. */
export type FkContainerInverseInput = {
  /** Flag indicating whether all other `peruDepartureInspectionPallet` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `peruDepartureInspectionPallet` for the far side of the relationship. */
  connectById?: Maybe<Array<PeruDepartureInspectionPalletPeruDepartureInspectionPalletPkeyConnect>>;
  /** The primary key(s) for `peruDepartureInspectionPallet` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PeruDepartureInspectionPalletNodeIdConnect>>;
  /** The primary key(s) for `peruDepartureInspectionPallet` for the far side of the relationship. */
  deleteById?: Maybe<Array<PeruDepartureInspectionPalletPeruDepartureInspectionPalletPkeyDelete>>;
  /** The primary key(s) for `peruDepartureInspectionPallet` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PeruDepartureInspectionPalletNodeIdDelete>>;
  /** The primary key(s) and patch data for `peruDepartureInspectionPallet` for the far side of the relationship. */
  updateById?: Maybe<Array<PeruDepartureInspectionPalletOnPeruDepartureInspectionPalletForFkContainerUsingPeruDepartureInspectionPalletPkeyUpdate>>;
  /** The primary key(s) and patch data for `peruDepartureInspectionPallet` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PeruDepartureInspectionOnPeruDepartureInspectionPalletForFkContainerNodeIdUpdate>>;
  /** A `PeruDepartureInspectionPalletInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkContainerPeruDepartureInspectionPalletCreateInput>>;
};

/** The fields on `peruDepartureInspectionPallet` to look up the row to connect. */
export type PeruDepartureInspectionPalletPeruDepartureInspectionPalletPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type PeruDepartureInspectionPalletNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `peruDepartureInspectionPallet` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `peruDepartureInspectionPallet` to look up the row to delete. */
export type PeruDepartureInspectionPalletPeruDepartureInspectionPalletPkeyDelete = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PeruDepartureInspectionPalletNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `peruDepartureInspectionPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `peruDepartureInspectionPallet` to look up the row to update. */
export type PeruDepartureInspectionPalletOnPeruDepartureInspectionPalletForFkContainerUsingPeruDepartureInspectionPalletPkeyUpdate = {
  /** An object where the defined keys will be set on the `peruDepartureInspectionPallet` being updated. */
  patch: UpdatePeruDepartureInspectionPalletOnPeruDepartureInspectionPalletForFkContainerPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `peruDepartureInspectionPallet` being updated. */
export type UpdatePeruDepartureInspectionPalletOnPeruDepartureInspectionPalletForFkContainerPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletId?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  netWeight?: Maybe<Scalars['BigFloat']>;
  openingScore?: Maybe<Scalars['BigFloat']>;
  colorScore?: Maybe<Scalars['BigFloat']>;
  stemScore?: Maybe<Scalars['BigFloat']>;
  textureScore?: Maybe<Scalars['BigFloat']>;
  bunchesPerBox?: Maybe<Scalars['BigFloat']>;
  brix?: Maybe<Scalars['BigFloat']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  decayPct?: Maybe<Scalars['BigFloat']>;
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  shatterPct?: Maybe<Scalars['BigFloat']>;
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalDefectsPct?: Maybe<Scalars['BigFloat']>;
  peruDepartureInspectionToContainerId?: Maybe<FkContainerInput>;
};

/** Input for the nested mutation of `peruDepartureInspection` in the `PeruDepartureInspectionPalletInput` mutation. */
export type FkContainerInput = {
  /** The primary key(s) for `peruDepartureInspection` for the far side of the relationship. */
  connectByContainerId?: Maybe<PeruDepartureInspectionPeruDepartureInspectionPkeyConnect>;
  /** The primary key(s) for `peruDepartureInspection` for the far side of the relationship. */
  connectByNodeId?: Maybe<PeruDepartureInspectionNodeIdConnect>;
  /** The primary key(s) for `peruDepartureInspection` for the far side of the relationship. */
  deleteByContainerId?: Maybe<PeruDepartureInspectionPeruDepartureInspectionPkeyDelete>;
  /** The primary key(s) for `peruDepartureInspection` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PeruDepartureInspectionNodeIdDelete>;
  /** The primary key(s) and patch data for `peruDepartureInspection` for the far side of the relationship. */
  updateByContainerId?: Maybe<PeruDepartureInspectionOnPeruDepartureInspectionPalletForFkContainerUsingPeruDepartureInspectionPkeyUpdate>;
  /** The primary key(s) and patch data for `peruDepartureInspection` for the far side of the relationship. */
  updateByNodeId?: Maybe<PeruDepartureInspectionPalletOnPeruDepartureInspectionPalletForFkContainerNodeIdUpdate>;
  /** A `PeruDepartureInspectionInput` object that will be created and connected to this object. */
  create?: Maybe<FkContainerPeruDepartureInspectionCreateInput>;
};

/** The fields on `peruDepartureInspection` to look up the row to connect. */
export type PeruDepartureInspectionPeruDepartureInspectionPkeyConnect = {
  containerId: Scalars['String'];
};

/** The globally unique `ID` look up for the row to connect. */
export type PeruDepartureInspectionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `peruDepartureInspection` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `peruDepartureInspection` to look up the row to delete. */
export type PeruDepartureInspectionPeruDepartureInspectionPkeyDelete = {
  containerId: Scalars['String'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PeruDepartureInspectionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `peruDepartureInspection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `peruDepartureInspection` to look up the row to update. */
export type PeruDepartureInspectionOnPeruDepartureInspectionPalletForFkContainerUsingPeruDepartureInspectionPkeyUpdate = {
  /** An object where the defined keys will be set on the `peruDepartureInspection` being updated. */
  patch: UpdatePeruDepartureInspectionOnPeruDepartureInspectionPalletForFkContainerPatch;
  containerId: Scalars['String'];
};

/** An object where the defined keys will be set on the `peruDepartureInspection` being updated. */
export type UpdatePeruDepartureInspectionOnPeruDepartureInspectionPalletForFkContainerPatch = {
  avgBunchesPerBox?: Maybe<Scalars['BigFloat']>;
  avgNetWeight?: Maybe<Scalars['BigFloat']>;
  bagsPerBox?: Maybe<Scalars['BigFloat']>;
  bagType?: Maybe<Scalars['String']>;
  brand?: Maybe<Scalars['String']>;
  brixAvg?: Maybe<Scalars['BigFloat']>;
  brixMax?: Maybe<Scalars['BigFloat']>;
  brixMin?: Maybe<Scalars['BigFloat']>;
  category?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  departureWeek?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  exporter?: Maybe<Scalars['String']>;
  inspectionDate?: Maybe<Scalars['Date']>;
  packingDate?: Maybe<Scalars['Date']>;
  packingHouse?: Maybe<Scalars['String']>;
  packingMaterial?: Maybe<Scalars['String']>;
  presentation?: Maybe<Scalars['String']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  variety?: Maybe<Scalars['String']>;
  peruDepartureInspectionPalletsUsingContainerId?: Maybe<FkContainerInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PeruDepartureInspectionPalletOnPeruDepartureInspectionPalletForFkContainerNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `peruDepartureInspection` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `peruDepartureInspection` being updated. */
  patch: PeruDepartureInspectionPatch;
};

/** Represents an update to a `PeruDepartureInspection`. Fields that are set will be updated. */
export type PeruDepartureInspectionPatch = {
  containerId?: Maybe<Scalars['String']>;
  avgBunchesPerBox?: Maybe<Scalars['BigFloat']>;
  avgNetWeight?: Maybe<Scalars['BigFloat']>;
  bagsPerBox?: Maybe<Scalars['BigFloat']>;
  bagType?: Maybe<Scalars['String']>;
  brand?: Maybe<Scalars['String']>;
  brixAvg?: Maybe<Scalars['BigFloat']>;
  brixMax?: Maybe<Scalars['BigFloat']>;
  brixMin?: Maybe<Scalars['BigFloat']>;
  category?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  departureWeek?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  exporter?: Maybe<Scalars['String']>;
  inspectionDate?: Maybe<Scalars['Date']>;
  packingDate?: Maybe<Scalars['Date']>;
  packingHouse?: Maybe<Scalars['String']>;
  packingMaterial?: Maybe<Scalars['String']>;
  presentation?: Maybe<Scalars['String']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  variety?: Maybe<Scalars['String']>;
  peruDepartureInspectionPalletsUsingContainerId?: Maybe<FkContainerInverseInput>;
};

/** The `peruDepartureInspection` to be created by this mutation. */
export type FkContainerPeruDepartureInspectionCreateInput = {
  avgBunchesPerBox: Scalars['BigFloat'];
  avgNetWeight: Scalars['BigFloat'];
  bagsPerBox: Scalars['BigFloat'];
  bagType?: Maybe<Scalars['String']>;
  brand: Scalars['String'];
  brixAvg: Scalars['BigFloat'];
  brixMax: Scalars['BigFloat'];
  brixMin: Scalars['BigFloat'];
  category: Scalars['String'];
  comments: Scalars['String'];
  conditionScore: Scalars['BigFloat'];
  departureWeek: Scalars['String'];
  destination: Scalars['String'];
  exporter: Scalars['String'];
  inspectionDate: Scalars['Date'];
  packingDate: Scalars['Date'];
  packingHouse: Scalars['String'];
  packingMaterial: Scalars['String'];
  presentation: Scalars['String'];
  qualityScore: Scalars['BigFloat'];
  variety: Scalars['String'];
  peruDepartureInspectionPalletsUsingContainerId?: Maybe<FkContainerInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PeruDepartureInspectionOnPeruDepartureInspectionPalletForFkContainerNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `peruDepartureInspectionPallet` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `peruDepartureInspectionPallet` being updated. */
  patch: PeruDepartureInspectionPalletPatch;
};

/** Represents an update to a `PeruDepartureInspectionPallet`. Fields that are set will be updated. */
export type PeruDepartureInspectionPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletId?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  netWeight?: Maybe<Scalars['BigFloat']>;
  openingScore?: Maybe<Scalars['BigFloat']>;
  colorScore?: Maybe<Scalars['BigFloat']>;
  stemScore?: Maybe<Scalars['BigFloat']>;
  textureScore?: Maybe<Scalars['BigFloat']>;
  bunchesPerBox?: Maybe<Scalars['BigFloat']>;
  brix?: Maybe<Scalars['BigFloat']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  decayPct?: Maybe<Scalars['BigFloat']>;
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  shatterPct?: Maybe<Scalars['BigFloat']>;
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalDefectsPct?: Maybe<Scalars['BigFloat']>;
  peruDepartureInspectionToContainerId?: Maybe<FkContainerInput>;
};

/** The `peruDepartureInspectionPallet` to be created by this mutation. */
export type FkContainerPeruDepartureInspectionPalletCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletId: Scalars['String'];
  size: Scalars['String'];
  netWeight: Scalars['BigFloat'];
  openingScore: Scalars['BigFloat'];
  colorScore: Scalars['BigFloat'];
  stemScore: Scalars['BigFloat'];
  textureScore: Scalars['BigFloat'];
  bunchesPerBox: Scalars['BigFloat'];
  brix: Scalars['BigFloat'];
  qualityScore: Scalars['BigFloat'];
  conditionScore: Scalars['BigFloat'];
  stragglyTightPct: Scalars['BigFloat'];
  surfaceDiscPct: Scalars['BigFloat'];
  russetScarsPct: Scalars['BigFloat'];
  sunburnPct: Scalars['BigFloat'];
  undersizedBunchesPct: Scalars['BigFloat'];
  otherDefectsPct: Scalars['BigFloat'];
  totalQualityDefectsPct: Scalars['BigFloat'];
  stemDehyPct: Scalars['BigFloat'];
  glassyWeakPct: Scalars['BigFloat'];
  decayPct: Scalars['BigFloat'];
  splitCrushedPct: Scalars['BigFloat'];
  drySplitPct: Scalars['BigFloat'];
  wetStickyPct: Scalars['BigFloat'];
  waterberriesPct: Scalars['BigFloat'];
  shatterPct: Scalars['BigFloat'];
  totalConditionDefectsPct: Scalars['BigFloat'];
  totalDefectsPct: Scalars['BigFloat'];
  peruDepartureInspectionToContainerId?: Maybe<FkContainerInput>;
};

/** The output of our create `PeruDepartureInspectionPallet` mutation. */
export type CreatePeruDepartureInspectionPalletPayload = {
  __typename?: 'CreatePeruDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspectionPallet` that was created by this mutation. */
  peruDepartureInspectionPallet?: Maybe<PeruDepartureInspectionPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PeruDepartureInspection` that is related to this `PeruDepartureInspectionPallet`. */
  container?: Maybe<PeruDepartureInspection>;
  /** An edge for our `PeruDepartureInspectionPallet`. May be used by Relay 1. */
  peruDepartureInspectionPalletEdge?: Maybe<PeruDepartureInspectionPalletsEdge>;
};


/** The output of our create `PeruDepartureInspectionPallet` mutation. */
export type CreatePeruDepartureInspectionPalletPayloadPeruDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionPalletsOrderBy>>;
};

/** All input for the create `PeruDepartureInspectionPallet` mutation. */
export type CreatePeruDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspectionPallet` to be created by this mutation. */
  peruDepartureInspectionPallet: PeruDepartureInspectionPalletInput;
};

/** An input for mutations affecting `PeruDepartureInspectionPallet` */
export type PeruDepartureInspectionPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletId: Scalars['String'];
  containerId?: Maybe<Scalars['String']>;
  size: Scalars['String'];
  netWeight: Scalars['BigFloat'];
  openingScore: Scalars['BigFloat'];
  colorScore: Scalars['BigFloat'];
  stemScore: Scalars['BigFloat'];
  textureScore: Scalars['BigFloat'];
  bunchesPerBox: Scalars['BigFloat'];
  brix: Scalars['BigFloat'];
  qualityScore: Scalars['BigFloat'];
  conditionScore: Scalars['BigFloat'];
  stragglyTightPct: Scalars['BigFloat'];
  surfaceDiscPct: Scalars['BigFloat'];
  russetScarsPct: Scalars['BigFloat'];
  sunburnPct: Scalars['BigFloat'];
  undersizedBunchesPct: Scalars['BigFloat'];
  otherDefectsPct: Scalars['BigFloat'];
  totalQualityDefectsPct: Scalars['BigFloat'];
  stemDehyPct: Scalars['BigFloat'];
  glassyWeakPct: Scalars['BigFloat'];
  decayPct: Scalars['BigFloat'];
  splitCrushedPct: Scalars['BigFloat'];
  drySplitPct: Scalars['BigFloat'];
  wetStickyPct: Scalars['BigFloat'];
  waterberriesPct: Scalars['BigFloat'];
  shatterPct: Scalars['BigFloat'];
  totalConditionDefectsPct: Scalars['BigFloat'];
  totalDefectsPct: Scalars['BigFloat'];
  peruDepartureInspectionToContainerId?: Maybe<FkContainerInput>;
};

/** The output of our create `PsaApplePallet` mutation. */
export type CreatePsaApplePalletPayload = {
  __typename?: 'CreatePsaApplePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaApplePallet` that was created by this mutation. */
  psaApplePallet?: Maybe<PsaApplePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaApplePallet`. May be used by Relay 1. */
  psaApplePalletEdge?: Maybe<PsaApplePalletsEdge>;
};


/** The output of our create `PsaApplePallet` mutation. */
export type CreatePsaApplePalletPayloadPsaApplePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaApplePalletsOrderBy>>;
};

/** All input for the create `PsaApplePallet` mutation. */
export type CreatePsaApplePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaApplePallet` to be created by this mutation. */
  psaApplePallet: PsaApplePalletInput;
};

/** An input for mutations affecting `PsaApplePallet` */
export type PsaApplePalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  stemPuncturesPct?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  sunScaldPieces?: Maybe<Scalars['String']>;
  sunScaldPct?: Maybe<Scalars['String']>;
  sunScaldDeg?: Maybe<Scalars['String']>;
  scaldPieces?: Maybe<Scalars['String']>;
  scaldPct?: Maybe<Scalars['String']>;
  scaldDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  crackingPieces?: Maybe<Scalars['String']>;
  crackingPct?: Maybe<Scalars['String']>;
  bitterPitPieces?: Maybe<Scalars['String']>;
  bitterPitPct?: Maybe<Scalars['String']>;
  bitterPitDeg?: Maybe<Scalars['String']>;
  lenticelBreakdownPieces?: Maybe<Scalars['String']>;
  lenticelBreakdownPct?: Maybe<Scalars['String']>;
  lenticelBreakdownDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  watercorePieces?: Maybe<Scalars['String']>;
  watercorePct?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** The output of our create `PsaArrivalPicture` mutation. */
export type CreatePsaArrivalPicturePayload = {
  __typename?: 'CreatePsaArrivalPicturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalPicture` that was created by this mutation. */
  psaArrivalPicture?: Maybe<PsaArrivalPicture>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalPicture`. May be used by Relay 1. */
  psaArrivalPictureEdge?: Maybe<PsaArrivalPicturesEdge>;
};


/** The output of our create `PsaArrivalPicture` mutation. */
export type CreatePsaArrivalPicturePayloadPsaArrivalPictureEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalPicturesOrderBy>>;
};

/** All input for the create `PsaArrivalPicture` mutation. */
export type CreatePsaArrivalPictureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalPicture` to be created by this mutation. */
  psaArrivalPicture: PsaArrivalPictureInput;
};

/** An input for mutations affecting `PsaArrivalPicture` */
export type PsaArrivalPictureInput = {
  id: Scalars['BigInt'];
  pictureDate?: Maybe<Scalars['Date']>;
  arrivalCode?: Maybe<Scalars['String']>;
  pictureDescription?: Maybe<Scalars['String']>;
  exporterId?: Maybe<Scalars['BigInt']>;
  palletId?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  varietyName?: Maybe<Scalars['String']>;
};

/** The output of our create `PsaArrivalReport` mutation. */
export type CreatePsaArrivalReportPayload = {
  __typename?: 'CreatePsaArrivalReportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalReport` that was created by this mutation. */
  psaArrivalReport?: Maybe<PsaArrivalReport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalReport`. May be used by Relay 1. */
  psaArrivalReportEdge?: Maybe<PsaArrivalReportsEdge>;
};


/** The output of our create `PsaArrivalReport` mutation. */
export type CreatePsaArrivalReportPayloadPsaArrivalReportEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalReportsOrderBy>>;
};

/** All input for the create `PsaArrivalReport` mutation. */
export type CreatePsaArrivalReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalReport` to be created by this mutation. */
  psaArrivalReport: PsaArrivalReportInput;
};

/** An input for mutations affecting `PsaArrivalReport` */
export type PsaArrivalReportInput = {
  id: Scalars['BigInt'];
  reportDate?: Maybe<Scalars['Date']>;
  locationName?: Maybe<Scalars['String']>;
  arrivalCode?: Maybe<Scalars['String']>;
  arrivalName?: Maybe<Scalars['String']>;
  exporterId?: Maybe<Scalars['BigInt']>;
  exporterName?: Maybe<Scalars['String']>;
};

/** The output of our create `PsaCherryPallet` mutation. */
export type CreatePsaCherryPalletPayload = {
  __typename?: 'CreatePsaCherryPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCherryPallet` that was created by this mutation. */
  psaCherryPallet?: Maybe<PsaCherryPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCherryPallet`. May be used by Relay 1. */
  psaCherryPalletEdge?: Maybe<PsaCherryPalletsEdge>;
};


/** The output of our create `PsaCherryPallet` mutation. */
export type CreatePsaCherryPalletPayloadPsaCherryPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCherryPalletsOrderBy>>;
};

/** All input for the create `PsaCherryPallet` mutation. */
export type CreatePsaCherryPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCherryPallet` to be created by this mutation. */
  psaCherryPallet: PsaCherryPalletInput;
};

/** An input for mutations affecting `PsaCherryPallet` */
export type PsaCherryPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  sizeMin?: Maybe<Scalars['String']>;
  sizeMax?: Maybe<Scalars['String']>;
  sizeMost?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  scarsMarksPieces?: Maybe<Scalars['String']>;
  scarsMarksPct?: Maybe<Scalars['String']>;
  scarsMarksDeg?: Maybe<Scalars['String']>;
  misshapenPieces?: Maybe<Scalars['String']>;
  misshapenPct?: Maybe<Scalars['String']>;
  stemlessPieces?: Maybe<Scalars['String']>;
  stemlessPct?: Maybe<Scalars['String']>;
  splitsPieces?: Maybe<Scalars['String']>;
  splitsPct?: Maybe<Scalars['String']>;
  splitsDeg?: Maybe<Scalars['String']>;
  firmness?: Maybe<Scalars['String']>;
  pittingBruisingPieces?: Maybe<Scalars['String']>;
  pittingBruisingPct?: Maybe<Scalars['String']>;
  pittingBruisingDeg?: Maybe<Scalars['String']>;
  stemDehydrationPieces?: Maybe<Scalars['String']>;
  stemDehydrationPct?: Maybe<Scalars['String']>;
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** The output of our create `PsaCitrusPallet` mutation. */
export type CreatePsaCitrusPalletPayload = {
  __typename?: 'CreatePsaCitrusPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCitrusPallet` that was created by this mutation. */
  psaCitrusPallet?: Maybe<PsaCitrusPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCitrusPallet`. May be used by Relay 1. */
  psaCitrusPalletEdge?: Maybe<PsaCitrusPalletsEdge>;
};


/** The output of our create `PsaCitrusPallet` mutation. */
export type CreatePsaCitrusPalletPayloadPsaCitrusPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCitrusPalletsOrderBy>>;
};

/** All input for the create `PsaCitrusPallet` mutation. */
export type CreatePsaCitrusPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCitrusPallet` to be created by this mutation. */
  psaCitrusPallet: PsaCitrusPalletInput;
};

/** An input for mutations affecting `PsaCitrusPallet` */
export type PsaCitrusPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  diameterMinMm?: Maybe<Scalars['String']>;
  diameterMinInches?: Maybe<Scalars['String']>;
  diameterMaxMm?: Maybe<Scalars['String']>;
  diameterMaxInches?: Maybe<Scalars['String']>;
  diameterMostMm?: Maybe<Scalars['String']>;
  diameterMostInches?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  greenHazePieces?: Maybe<Scalars['String']>;
  greenHazePct?: Maybe<Scalars['String']>;
  greenHazeDeg?: Maybe<Scalars['String']>;
  oilSpotsPieces?: Maybe<Scalars['String']>;
  oilSpotsPct?: Maybe<Scalars['String']>;
  oilSpotsDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  dryPulpPieces?: Maybe<Scalars['String']>;
  dryPulpPct?: Maybe<Scalars['String']>;
  dryPulpDeg?: Maybe<Scalars['String']>;
  seedsPieces?: Maybe<Scalars['String']>;
  seedsPct?: Maybe<Scalars['String']>;
  skinBreakdownPieces?: Maybe<Scalars['String']>;
  skinBreakdownPct?: Maybe<Scalars['String']>;
  skinBreakdownDeg?: Maybe<Scalars['String']>;
  creasingPieces?: Maybe<Scalars['String']>;
  creasingPct?: Maybe<Scalars['String']>;
  creasingDeg?: Maybe<Scalars['String']>;
  puffinessPieces?: Maybe<Scalars['String']>;
  puffinessPct?: Maybe<Scalars['String']>;
  puffinessDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  sporesPieces?: Maybe<Scalars['String']>;
  sporesPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** The output of our create `PsaGrapePallet` mutation. */
export type CreatePsaGrapePalletPayload = {
  __typename?: 'CreatePsaGrapePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaGrapePallet` that was created by this mutation. */
  psaGrapePallet?: Maybe<PsaGrapePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaGrapePallet`. May be used by Relay 1. */
  psaGrapePalletEdge?: Maybe<PsaGrapePalletsEdge>;
};


/** The output of our create `PsaGrapePallet` mutation. */
export type CreatePsaGrapePalletPayloadPsaGrapePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaGrapePalletsOrderBy>>;
};

/** All input for the create `PsaGrapePallet` mutation. */
export type CreatePsaGrapePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaGrapePallet` to be created by this mutation. */
  psaGrapePallet: PsaGrapePalletInput;
};

/** An input for mutations affecting `PsaGrapePallet` */
export type PsaGrapePalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['Date']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  autoOpening?: Maybe<Scalars['String']>;
  bunches?: Maybe<Scalars['String']>;
  sizeMin?: Maybe<Scalars['String']>;
  sizeMax?: Maybe<Scalars['String']>;
  sizeMost?: Maybe<Scalars['String']>;
  undersizeBunchesCount?: Maybe<Scalars['String']>;
  autoUndersizeBerriesBunches?: Maybe<Scalars['String']>;
  undersizeBerriesPct?: Maybe<Scalars['String']>;
  colorMin?: Maybe<Scalars['String']>;
  colorMax?: Maybe<Scalars['String']>;
  colorMost?: Maybe<Scalars['String']>;
  colorConsistency?: Maybe<Scalars['String']>;
  autoColorConsistency?: Maybe<Scalars['String']>;
  sunburnBunches?: Maybe<Scalars['String']>;
  autoSunburnBunches?: Maybe<Scalars['String']>;
  sunburnPct?: Maybe<Scalars['String']>;
  sunburnBunchesDeg?: Maybe<Scalars['String']>;
  bunchConformation?: Maybe<Scalars['String']>;
  autoBunchConformation?: Maybe<Scalars['String']>;
  stragglyBunches?: Maybe<Scalars['String']>;
  stragglyPct?: Maybe<Scalars['String']>;
  smallBunches?: Maybe<Scalars['String']>;
  russetMarksBunches?: Maybe<Scalars['String']>;
  russetMarksPct?: Maybe<Scalars['String']>;
  autoRussetMarksPct?: Maybe<Scalars['String']>;
  dustPct?: Maybe<Scalars['String']>;
  autoDustPct?: Maybe<Scalars['String']>;
  residuesPct?: Maybe<Scalars['String']>;
  autoResiduesPct?: Maybe<Scalars['String']>;
  tightBunches?: Maybe<Scalars['String']>;
  autoTightBunches?: Maybe<Scalars['String']>;
  bruisingBunches?: Maybe<Scalars['String']>;
  autoBruisingBunches?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  stemDehydrationPct?: Maybe<Scalars['String']>;
  autoStemDehydrationPct?: Maybe<Scalars['String']>;
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  berryCondition?: Maybe<Scalars['String']>;
  autoBerryCondition?: Maybe<Scalars['String']>;
  h2OBerries?: Maybe<Scalars['String']>;
  autoH2OBerries?: Maybe<Scalars['String']>;
  so2DamagePct?: Maybe<Scalars['String']>;
  autoSo2DamagePct?: Maybe<Scalars['String']>;
  so2DamageDeg?: Maybe<Scalars['String']>;
  weakBunches?: Maybe<Scalars['String']>;
  autoWeakBunches?: Maybe<Scalars['String']>;
  splitsHairlinePct?: Maybe<Scalars['String']>;
  autoSplitsHairlinePct?: Maybe<Scalars['String']>;
  splitsWetCrushPct?: Maybe<Scalars['String']>;
  autoSplitsWetCrushPct?: Maybe<Scalars['String']>;
  splitsDryPct?: Maybe<Scalars['String']>;
  autoSplitsDryPct?: Maybe<Scalars['String']>;
  intDisc?: Maybe<Scalars['String']>;
  autoIntDisc?: Maybe<Scalars['String']>;
  intDiscDeg?: Maybe<Scalars['String']>;
  decayMoldBerries?: Maybe<Scalars['String']>;
  autoDecayMoldBerries?: Maybe<Scalars['String']>;
  decaySlipskinBerries?: Maybe<Scalars['String']>;
  autoDecaySlipskinBerries?: Maybe<Scalars['String']>;
  decayNestBerries?: Maybe<Scalars['String']>;
  autoDecayNestBerries?: Maybe<Scalars['String']>;
  decayNestDeg?: Maybe<Scalars['String']>;
  shatterPct?: Maybe<Scalars['String']>;
  autoShatterPct?: Maybe<Scalars['String']>;
  brixMin?: Maybe<Scalars['String']>;
  brixMax?: Maybe<Scalars['String']>;
  brixMost?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  autoOverallQuality?: Maybe<Scalars['String']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  autoOverallCondition?: Maybe<Scalars['String']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** The output of our create `PsaLemonPallet` mutation. */
export type CreatePsaLemonPalletPayload = {
  __typename?: 'CreatePsaLemonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaLemonPallet` that was created by this mutation. */
  psaLemonPallet?: Maybe<PsaLemonPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaLemonPallet`. May be used by Relay 1. */
  psaLemonPalletEdge?: Maybe<PsaLemonPalletsEdge>;
};


/** The output of our create `PsaLemonPallet` mutation. */
export type CreatePsaLemonPalletPayloadPsaLemonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaLemonPalletsOrderBy>>;
};

/** All input for the create `PsaLemonPallet` mutation. */
export type CreatePsaLemonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaLemonPallet` to be created by this mutation. */
  psaLemonPallet: PsaLemonPalletInput;
};

/** An input for mutations affecting `PsaLemonPallet` */
export type PsaLemonPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  diameterMinMm?: Maybe<Scalars['String']>;
  diameterMinInches?: Maybe<Scalars['String']>;
  diameterMaxMm?: Maybe<Scalars['String']>;
  diameterMaxInches?: Maybe<Scalars['String']>;
  diameterMostMm?: Maybe<Scalars['String']>;
  diameterMostInches?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  greenHazePieces?: Maybe<Scalars['String']>;
  greenHazePct?: Maybe<Scalars['String']>;
  greenHazeDeg?: Maybe<Scalars['String']>;
  oilSpotsPieces?: Maybe<Scalars['String']>;
  oilSpotsPct?: Maybe<Scalars['String']>;
  oilSpotsDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  dryPulpPieces?: Maybe<Scalars['String']>;
  dryPulpPct?: Maybe<Scalars['String']>;
  dryPulpDeg?: Maybe<Scalars['String']>;
  skinDamagePieces?: Maybe<Scalars['String']>;
  skinDamagePct?: Maybe<Scalars['String']>;
  skinDamageDeg?: Maybe<Scalars['String']>;
  petecaPieces?: Maybe<Scalars['String']>;
  petecaPct?: Maybe<Scalars['String']>;
  petecaDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  sporesPieces?: Maybe<Scalars['String']>;
  sporesPct?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** The output of our create `PsaPearPallet` mutation. */
export type CreatePsaPearPalletPayload = {
  __typename?: 'CreatePsaPearPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPearPallet` that was created by this mutation. */
  psaPearPallet?: Maybe<PsaPearPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPearPallet`. May be used by Relay 1. */
  psaPearPalletEdge?: Maybe<PsaPearPalletsEdge>;
};


/** The output of our create `PsaPearPallet` mutation. */
export type CreatePsaPearPalletPayloadPsaPearPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPearPalletsOrderBy>>;
};

/** All input for the create `PsaPearPallet` mutation. */
export type CreatePsaPearPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPearPallet` to be created by this mutation. */
  psaPearPallet: PsaPearPalletInput;
};

/** An input for mutations affecting `PsaPearPallet` */
export type PsaPearPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsRussetPieces?: Maybe<Scalars['String']>;
  scarsRussetPct?: Maybe<Scalars['String']>;
  scarsRussetDeg?: Maybe<Scalars['String']>;
  russetPerPiecePct?: Maybe<Scalars['String']>;
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  stemPuncturesPct?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  turningColorPieces?: Maybe<Scalars['String']>;
  turningColorPct?: Maybe<Scalars['String']>;
  turningColorDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** The output of our create `PsaPersimmonPallet` mutation. */
export type CreatePsaPersimmonPalletPayload = {
  __typename?: 'CreatePsaPersimmonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPersimmonPallet` that was created by this mutation. */
  psaPersimmonPallet?: Maybe<PsaPersimmonPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPersimmonPallet`. May be used by Relay 1. */
  psaPersimmonPalletEdge?: Maybe<PsaPersimmonPalletsEdge>;
};


/** The output of our create `PsaPersimmonPallet` mutation. */
export type CreatePsaPersimmonPalletPayloadPsaPersimmonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPersimmonPalletsOrderBy>>;
};

/** All input for the create `PsaPersimmonPallet` mutation. */
export type CreatePsaPersimmonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPersimmonPallet` to be created by this mutation. */
  psaPersimmonPallet: PsaPersimmonPalletInput;
};

/** An input for mutations affecting `PsaPersimmonPallet` */
export type PsaPersimmonPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  scarsMarksPieces?: Maybe<Scalars['String']>;
  scarsMarksPct?: Maybe<Scalars['String']>;
  scarsMarksDeg?: Maybe<Scalars['String']>;
  greenColorPieces?: Maybe<Scalars['String']>;
  greenColor?: Maybe<Scalars['String']>;
  greenColorDeg?: Maybe<Scalars['String']>;
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  cutsSplitsPct?: Maybe<Scalars['String']>;
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  seedsPieces?: Maybe<Scalars['String']>;
  seedsPct?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  internalDamageDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** The output of our create `PsaPomegranatePallet` mutation. */
export type CreatePsaPomegranatePalletPayload = {
  __typename?: 'CreatePsaPomegranatePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPomegranatePallet` that was created by this mutation. */
  psaPomegranatePallet?: Maybe<PsaPomegranatePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPomegranatePallet`. May be used by Relay 1. */
  psaPomegranatePalletEdge?: Maybe<PsaPomegranatePalletsEdge>;
};


/** The output of our create `PsaPomegranatePallet` mutation. */
export type CreatePsaPomegranatePalletPayloadPsaPomegranatePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPomegranatePalletsOrderBy>>;
};

/** All input for the create `PsaPomegranatePallet` mutation. */
export type CreatePsaPomegranatePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPomegranatePallet` to be created by this mutation. */
  psaPomegranatePallet: PsaPomegranatePalletInput;
};

/** An input for mutations affecting `PsaPomegranatePallet` */
export type PsaPomegranatePalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  arilsColor?: Maybe<Scalars['String']>;
  scarsRussetPieces?: Maybe<Scalars['String']>;
  scarsRussetPct?: Maybe<Scalars['String']>;
  scarsRussetDeg?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  sunScaldPieces?: Maybe<Scalars['String']>;
  sunScaldPct?: Maybe<Scalars['String']>;
  sunScaldDeg?: Maybe<Scalars['String']>;
  scaldPieces?: Maybe<Scalars['String']>;
  scaldPct?: Maybe<Scalars['String']>;
  scaldDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brixMin?: Maybe<Scalars['String']>;
  brixMax?: Maybe<Scalars['String']>;
  brixMost?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** The output of our create `PsaStoneFruitPallet` mutation. */
export type CreatePsaStoneFruitPalletPayload = {
  __typename?: 'CreatePsaStoneFruitPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaStoneFruitPallet` that was created by this mutation. */
  psaStoneFruitPallet?: Maybe<PsaStoneFruitPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaStoneFruitPallet`. May be used by Relay 1. */
  psaStoneFruitPalletEdge?: Maybe<PsaStoneFruitPalletsEdge>;
};


/** The output of our create `PsaStoneFruitPallet` mutation. */
export type CreatePsaStoneFruitPalletPayloadPsaStoneFruitPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaStoneFruitPalletsOrderBy>>;
};

/** All input for the create `PsaStoneFruitPallet` mutation. */
export type CreatePsaStoneFruitPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaStoneFruitPallet` to be created by this mutation. */
  psaStoneFruitPallet: PsaStoneFruitPalletInput;
};

/** An input for mutations affecting `PsaStoneFruitPallet` */
export type PsaStoneFruitPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  ripening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  cutsSplitsPct?: Maybe<Scalars['String']>;
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  splitPitPieces?: Maybe<Scalars['String']>;
  splitPitPct?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  softTipsPieces?: Maybe<Scalars['String']>;
  softTipsPct?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  mealinessPieces?: Maybe<Scalars['String']>;
  mealinessPct?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** The output of our create `AgendaItem` mutation. */
export type CreateAgendaItemPayload = {
  __typename?: 'CreateAgendaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgendaItem` that was created by this mutation. */
  agendaItem?: Maybe<AgendaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `AgendaItem`. May be used by Relay 1. */
  agendaItemEdge?: Maybe<AgendaItemsEdge>;
};


/** The output of our create `AgendaItem` mutation. */
export type CreateAgendaItemPayloadAgendaItemEdgeArgs = {
  orderBy?: Maybe<Array<AgendaItemsOrderBy>>;
};

/** All input for the create `AgendaItem` mutation. */
export type CreateAgendaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgendaItem` to be created by this mutation. */
  agendaItem: AgendaItemInput;
};

/** An input for mutations affecting `AgendaItem` */
export type AgendaItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  content: Scalars['String'];
  itemDate: Scalars['Date'];
  sortOrder: Scalars['Int'];
};

/** The output of our create `CalendarEvent` mutation. */
export type CreateCalendarEventPayload = {
  __typename?: 'CreateCalendarEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CalendarEvent` that was created by this mutation. */
  calendarEvent?: Maybe<CalendarEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CalendarEvent`. May be used by Relay 1. */
  calendarEventEdge?: Maybe<CalendarEventsEdge>;
};


/** The output of our create `CalendarEvent` mutation. */
export type CreateCalendarEventPayloadCalendarEventEdgeArgs = {
  orderBy?: Maybe<Array<CalendarEventsOrderBy>>;
};

/** All input for the create `CalendarEvent` mutation. */
export type CreateCalendarEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CalendarEvent` to be created by this mutation. */
  calendarEvent: CalendarEventInput;
};

/** An input for mutations affecting `CalendarEvent` */
export type CalendarEventInput = {
  id?: Maybe<Scalars['BigInt']>;
  title?: Maybe<Scalars['String']>;
  eventDescription?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['Datetime']>;
  endDate?: Maybe<Scalars['Datetime']>;
  allDay?: Maybe<Scalars['Boolean']>;
  rrule?: Maybe<Scalars['String']>;
};

/** The output of our create `PriceCategory` mutation. */
export type CreatePriceCategoryPayload = {
  __typename?: 'CreatePriceCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceCategory` that was created by this mutation. */
  priceCategory?: Maybe<PriceCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PriceCategory`. May be used by Relay 1. */
  priceCategoryEdge?: Maybe<PriceCategoriesEdge>;
};


/** The output of our create `PriceCategory` mutation. */
export type CreatePriceCategoryPayloadPriceCategoryEdgeArgs = {
  orderBy?: Maybe<Array<PriceCategoriesOrderBy>>;
};

/** All input for the create `PriceCategory` mutation. */
export type CreatePriceCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceCategory` to be created by this mutation. */
  priceCategory: PriceCategoryInput;
};

/** An input for mutations affecting `PriceCategory` */
export type PriceCategoryInput = {
  id?: Maybe<Scalars['BigInt']>;
  categoryName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceProductsUsingId?: Maybe<PriceProductCategoryIdFkeyInverseInput>;
};

/** Input for the nested mutation of `priceProduct` in the `PriceCategoryInput` mutation. */
export type PriceProductCategoryIdFkeyInverseInput = {
  /** Flag indicating whether all other `priceProduct` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  connectById?: Maybe<Array<PriceProductPriceProductPkeyConnect>>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PriceProductNodeIdConnect>>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  deleteById?: Maybe<Array<PriceProductPriceProductPkeyDelete>>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PriceProductNodeIdDelete>>;
  /** The primary key(s) and patch data for `priceProduct` for the far side of the relationship. */
  updateById?: Maybe<Array<PriceProductOnPriceProductForPriceProductCategoryIdFkeyUsingPriceProductPkeyUpdate>>;
  /** The primary key(s) and patch data for `priceProduct` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PriceCategoryOnPriceProductForPriceProductCategoryIdFkeyNodeIdUpdate>>;
  /** A `PriceProductInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PriceProductCategoryIdFkeyPriceProductCreateInput>>;
};

/** The fields on `priceProduct` to look up the row to connect. */
export type PriceProductPriceProductPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type PriceProductNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `priceProduct` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `priceProduct` to look up the row to delete. */
export type PriceProductPriceProductPkeyDelete = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PriceProductNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `priceProduct` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `priceProduct` to look up the row to update. */
export type PriceProductOnPriceProductForPriceProductCategoryIdFkeyUsingPriceProductPkeyUpdate = {
  /** An object where the defined keys will be set on the `priceProduct` being updated. */
  patch: UpdatePriceProductOnPriceProductForPriceProductCategoryIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `priceProduct` being updated. */
export type UpdatePriceProductOnPriceProductForPriceProductCategoryIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  color?: Maybe<Scalars['String']>;
  productName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceCategoryToCategoryId?: Maybe<PriceProductCategoryIdFkeyInput>;
  priceSizesUsingId?: Maybe<PriceSizeProductIdFkeyInverseInput>;
};

/** Input for the nested mutation of `priceCategory` in the `PriceProductInput` mutation. */
export type PriceProductCategoryIdFkeyInput = {
  /** The primary key(s) for `priceCategory` for the far side of the relationship. */
  connectById?: Maybe<PriceCategoryPriceCategoryPkeyConnect>;
  /** The primary key(s) for `priceCategory` for the far side of the relationship. */
  connectByNodeId?: Maybe<PriceCategoryNodeIdConnect>;
  /** The primary key(s) for `priceCategory` for the far side of the relationship. */
  deleteById?: Maybe<PriceCategoryPriceCategoryPkeyDelete>;
  /** The primary key(s) for `priceCategory` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PriceCategoryNodeIdDelete>;
  /** The primary key(s) and patch data for `priceCategory` for the far side of the relationship. */
  updateById?: Maybe<PriceCategoryOnPriceProductForPriceProductCategoryIdFkeyUsingPriceCategoryPkeyUpdate>;
  /** The primary key(s) and patch data for `priceCategory` for the far side of the relationship. */
  updateByNodeId?: Maybe<PriceProductOnPriceProductForPriceProductCategoryIdFkeyNodeIdUpdate>;
  /** A `PriceCategoryInput` object that will be created and connected to this object. */
  create?: Maybe<PriceProductCategoryIdFkeyPriceCategoryCreateInput>;
};

/** The fields on `priceCategory` to look up the row to connect. */
export type PriceCategoryPriceCategoryPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type PriceCategoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `priceCategory` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `priceCategory` to look up the row to delete. */
export type PriceCategoryPriceCategoryPkeyDelete = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PriceCategoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `priceCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `priceCategory` to look up the row to update. */
export type PriceCategoryOnPriceProductForPriceProductCategoryIdFkeyUsingPriceCategoryPkeyUpdate = {
  /** An object where the defined keys will be set on the `priceCategory` being updated. */
  patch: UpdatePriceCategoryOnPriceProductForPriceProductCategoryIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `priceCategory` being updated. */
export type UpdatePriceCategoryOnPriceProductForPriceProductCategoryIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  categoryName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceProductsUsingId?: Maybe<PriceProductCategoryIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PriceProductOnPriceProductForPriceProductCategoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `priceCategory` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `priceCategory` being updated. */
  patch: PriceCategoryPatch;
};

/** Represents an update to a `PriceCategory`. Fields that are set will be updated. */
export type PriceCategoryPatch = {
  id?: Maybe<Scalars['BigInt']>;
  categoryName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceProductsUsingId?: Maybe<PriceProductCategoryIdFkeyInverseInput>;
};

/** The `priceCategory` to be created by this mutation. */
export type PriceProductCategoryIdFkeyPriceCategoryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  categoryName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceProductsUsingId?: Maybe<PriceProductCategoryIdFkeyInverseInput>;
};

/** Input for the nested mutation of `priceSize` in the `PriceProductInput` mutation. */
export type PriceSizeProductIdFkeyInverseInput = {
  /** Flag indicating whether all other `priceSize` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  connectById?: Maybe<Array<PriceSizePriceSizePkeyConnect>>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PriceSizeNodeIdConnect>>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  deleteById?: Maybe<Array<PriceSizePriceSizePkeyDelete>>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PriceSizeNodeIdDelete>>;
  /** The primary key(s) and patch data for `priceSize` for the far side of the relationship. */
  updateById?: Maybe<Array<PriceSizeOnPriceSizeForPriceSizeProductIdFkeyUsingPriceSizePkeyUpdate>>;
  /** The primary key(s) and patch data for `priceSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PriceProductOnPriceSizeForPriceSizeProductIdFkeyNodeIdUpdate>>;
  /** A `PriceSizeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PriceSizeProductIdFkeyPriceSizeCreateInput>>;
};

/** The fields on `priceSize` to look up the row to connect. */
export type PriceSizePriceSizePkeyConnect = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type PriceSizeNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `priceSize` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `priceSize` to look up the row to delete. */
export type PriceSizePriceSizePkeyDelete = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PriceSizeNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `priceSize` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `priceSize` to look up the row to update. */
export type PriceSizeOnPriceSizeForPriceSizeProductIdFkeyUsingPriceSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `priceSize` being updated. */
  patch: UpdatePriceSizeOnPriceSizeForPriceSizeProductIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `priceSize` being updated. */
export type UpdatePriceSizeOnPriceSizeForPriceSizeProductIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceProductToProductId?: Maybe<PriceSizeProductIdFkeyInput>;
  priceEntriesUsingId?: Maybe<PriceEntrySizeIdFkeyInverseInput>;
};

/** Input for the nested mutation of `priceProduct` in the `PriceSizeInput` mutation. */
export type PriceSizeProductIdFkeyInput = {
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  connectById?: Maybe<PriceProductPriceProductPkeyConnect>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  connectByNodeId?: Maybe<PriceProductNodeIdConnect>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  deleteById?: Maybe<PriceProductPriceProductPkeyDelete>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PriceProductNodeIdDelete>;
  /** The primary key(s) and patch data for `priceProduct` for the far side of the relationship. */
  updateById?: Maybe<PriceProductOnPriceSizeForPriceSizeProductIdFkeyUsingPriceProductPkeyUpdate>;
  /** The primary key(s) and patch data for `priceProduct` for the far side of the relationship. */
  updateByNodeId?: Maybe<PriceSizeOnPriceSizeForPriceSizeProductIdFkeyNodeIdUpdate>;
  /** A `PriceProductInput` object that will be created and connected to this object. */
  create?: Maybe<PriceSizeProductIdFkeyPriceProductCreateInput>;
};

/** The fields on `priceProduct` to look up the row to update. */
export type PriceProductOnPriceSizeForPriceSizeProductIdFkeyUsingPriceProductPkeyUpdate = {
  /** An object where the defined keys will be set on the `priceProduct` being updated. */
  patch: UpdatePriceProductOnPriceSizeForPriceSizeProductIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `priceProduct` being updated. */
export type UpdatePriceProductOnPriceSizeForPriceSizeProductIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  categoryId?: Maybe<Scalars['BigInt']>;
  color?: Maybe<Scalars['String']>;
  productName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceCategoryToCategoryId?: Maybe<PriceProductCategoryIdFkeyInput>;
  priceSizesUsingId?: Maybe<PriceSizeProductIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PriceSizeOnPriceSizeForPriceSizeProductIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `priceProduct` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `priceProduct` being updated. */
  patch: PriceProductPatch;
};

/** Represents an update to a `PriceProduct`. Fields that are set will be updated. */
export type PriceProductPatch = {
  id?: Maybe<Scalars['BigInt']>;
  categoryId?: Maybe<Scalars['BigInt']>;
  color?: Maybe<Scalars['String']>;
  productName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceCategoryToCategoryId?: Maybe<PriceProductCategoryIdFkeyInput>;
  priceSizesUsingId?: Maybe<PriceSizeProductIdFkeyInverseInput>;
};

/** The `priceProduct` to be created by this mutation. */
export type PriceSizeProductIdFkeyPriceProductCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  categoryId?: Maybe<Scalars['BigInt']>;
  color: Scalars['String'];
  productName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceCategoryToCategoryId?: Maybe<PriceProductCategoryIdFkeyInput>;
  priceSizesUsingId?: Maybe<PriceSizeProductIdFkeyInverseInput>;
};

/** Input for the nested mutation of `priceEntry` in the `PriceSizeInput` mutation. */
export type PriceEntrySizeIdFkeyInverseInput = {
  /** Flag indicating whether all other `priceEntry` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `priceEntry` for the far side of the relationship. */
  connectById?: Maybe<Array<PriceEntryPriceEntryPkeyConnect>>;
  /** The primary key(s) for `priceEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PriceEntryNodeIdConnect>>;
  /** The primary key(s) for `priceEntry` for the far side of the relationship. */
  deleteById?: Maybe<Array<PriceEntryPriceEntryPkeyDelete>>;
  /** The primary key(s) for `priceEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PriceEntryNodeIdDelete>>;
  /** The primary key(s) and patch data for `priceEntry` for the far side of the relationship. */
  updateById?: Maybe<Array<PriceEntryOnPriceEntryForPriceEntrySizeIdFkeyUsingPriceEntryPkeyUpdate>>;
  /** The primary key(s) and patch data for `priceEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PriceSizeOnPriceEntryForPriceEntrySizeIdFkeyNodeIdUpdate>>;
  /** A `PriceEntryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PriceEntrySizeIdFkeyPriceEntryCreateInput>>;
};

/** The fields on `priceEntry` to look up the row to connect. */
export type PriceEntryPriceEntryPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type PriceEntryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `priceEntry` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `priceEntry` to look up the row to delete. */
export type PriceEntryPriceEntryPkeyDelete = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PriceEntryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `priceEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `priceEntry` to look up the row to update. */
export type PriceEntryOnPriceEntryForPriceEntrySizeIdFkeyUsingPriceEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `priceEntry` being updated. */
  patch: UpdatePriceEntryOnPriceEntryForPriceEntrySizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `priceEntry` being updated. */
export type UpdatePriceEntryOnPriceEntryForPriceEntrySizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  entryDate?: Maybe<Scalars['Date']>;
  entryDescription?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  highlight?: Maybe<Scalars['Boolean']>;
  priceSizeToSizeId?: Maybe<PriceEntrySizeIdFkeyInput>;
};

/** Input for the nested mutation of `priceSize` in the `PriceEntryInput` mutation. */
export type PriceEntrySizeIdFkeyInput = {
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  connectById?: Maybe<PriceSizePriceSizePkeyConnect>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<PriceSizeNodeIdConnect>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  deleteById?: Maybe<PriceSizePriceSizePkeyDelete>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PriceSizeNodeIdDelete>;
  /** The primary key(s) and patch data for `priceSize` for the far side of the relationship. */
  updateById?: Maybe<PriceSizeOnPriceEntryForPriceEntrySizeIdFkeyUsingPriceSizePkeyUpdate>;
  /** The primary key(s) and patch data for `priceSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<PriceEntryOnPriceEntryForPriceEntrySizeIdFkeyNodeIdUpdate>;
  /** A `PriceSizeInput` object that will be created and connected to this object. */
  create?: Maybe<PriceEntrySizeIdFkeyPriceSizeCreateInput>;
};

/** The fields on `priceSize` to look up the row to update. */
export type PriceSizeOnPriceEntryForPriceEntrySizeIdFkeyUsingPriceSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `priceSize` being updated. */
  patch: UpdatePriceSizeOnPriceEntryForPriceEntrySizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** An object where the defined keys will be set on the `priceSize` being updated. */
export type UpdatePriceSizeOnPriceEntryForPriceEntrySizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceProductToProductId?: Maybe<PriceSizeProductIdFkeyInput>;
  priceEntriesUsingId?: Maybe<PriceEntrySizeIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PriceEntryOnPriceEntryForPriceEntrySizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `priceSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `priceSize` being updated. */
  patch: PriceSizePatch;
};

/** Represents an update to a `PriceSize`. Fields that are set will be updated. */
export type PriceSizePatch = {
  id?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceProductToProductId?: Maybe<PriceSizeProductIdFkeyInput>;
  priceEntriesUsingId?: Maybe<PriceEntrySizeIdFkeyInverseInput>;
};

/** The `priceSize` to be created by this mutation. */
export type PriceEntrySizeIdFkeyPriceSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  sizeName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceProductToProductId?: Maybe<PriceSizeProductIdFkeyInput>;
  priceEntriesUsingId?: Maybe<PriceEntrySizeIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PriceSizeOnPriceEntryForPriceEntrySizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `priceEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `priceEntry` being updated. */
  patch: PriceEntryPatch;
};

/** Represents an update to a `PriceEntry`. Fields that are set will be updated. */
export type PriceEntryPatch = {
  id?: Maybe<Scalars['BigInt']>;
  sizeId?: Maybe<Scalars['BigInt']>;
  entryDate?: Maybe<Scalars['Date']>;
  entryDescription?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  highlight?: Maybe<Scalars['Boolean']>;
  priceSizeToSizeId?: Maybe<PriceEntrySizeIdFkeyInput>;
};

/** The `priceEntry` to be created by this mutation. */
export type PriceEntrySizeIdFkeyPriceEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  entryDate: Scalars['Date'];
  entryDescription: Scalars['String'];
  content: Scalars['String'];
  highlight: Scalars['Boolean'];
  priceSizeToSizeId?: Maybe<PriceEntrySizeIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PriceProductOnPriceSizeForPriceSizeProductIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `priceSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `priceSize` being updated. */
  patch: PriceSizePatch;
};

/** The `priceSize` to be created by this mutation. */
export type PriceSizeProductIdFkeyPriceSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceProductToProductId?: Maybe<PriceSizeProductIdFkeyInput>;
  priceEntriesUsingId?: Maybe<PriceEntrySizeIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PriceCategoryOnPriceProductForPriceProductCategoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `priceProduct` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `priceProduct` being updated. */
  patch: PriceProductPatch;
};

/** The `priceProduct` to be created by this mutation. */
export type PriceProductCategoryIdFkeyPriceProductCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  color: Scalars['String'];
  productName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceCategoryToCategoryId?: Maybe<PriceProductCategoryIdFkeyInput>;
  priceSizesUsingId?: Maybe<PriceSizeProductIdFkeyInverseInput>;
};

/** The output of our create `PriceEntry` mutation. */
export type CreatePriceEntryPayload = {
  __typename?: 'CreatePriceEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceEntry` that was created by this mutation. */
  priceEntry?: Maybe<PriceEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceSize` that is related to this `PriceEntry`. */
  size?: Maybe<PriceSize>;
  /** An edge for our `PriceEntry`. May be used by Relay 1. */
  priceEntryEdge?: Maybe<PriceEntriesEdge>;
};


/** The output of our create `PriceEntry` mutation. */
export type CreatePriceEntryPayloadPriceEntryEdgeArgs = {
  orderBy?: Maybe<Array<PriceEntriesOrderBy>>;
};

/** All input for the create `PriceEntry` mutation. */
export type CreatePriceEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceEntry` to be created by this mutation. */
  priceEntry: PriceEntryInput;
};

/** An input for mutations affecting `PriceEntry` */
export type PriceEntryInput = {
  id?: Maybe<Scalars['BigInt']>;
  sizeId?: Maybe<Scalars['BigInt']>;
  entryDate: Scalars['Date'];
  entryDescription: Scalars['String'];
  content: Scalars['String'];
  highlight: Scalars['Boolean'];
  priceSizeToSizeId?: Maybe<PriceEntrySizeIdFkeyInput>;
};

/** The output of our create `PriceProduct` mutation. */
export type CreatePriceProductPayload = {
  __typename?: 'CreatePriceProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceProduct` that was created by this mutation. */
  priceProduct?: Maybe<PriceProduct>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceCategory` that is related to this `PriceProduct`. */
  category?: Maybe<PriceCategory>;
  /** An edge for our `PriceProduct`. May be used by Relay 1. */
  priceProductEdge?: Maybe<PriceProductsEdge>;
};


/** The output of our create `PriceProduct` mutation. */
export type CreatePriceProductPayloadPriceProductEdgeArgs = {
  orderBy?: Maybe<Array<PriceProductsOrderBy>>;
};

/** All input for the create `PriceProduct` mutation. */
export type CreatePriceProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceProduct` to be created by this mutation. */
  priceProduct: PriceProductInput;
};

/** An input for mutations affecting `PriceProduct` */
export type PriceProductInput = {
  id?: Maybe<Scalars['BigInt']>;
  categoryId?: Maybe<Scalars['BigInt']>;
  color: Scalars['String'];
  productName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceCategoryToCategoryId?: Maybe<PriceProductCategoryIdFkeyInput>;
  priceSizesUsingId?: Maybe<PriceSizeProductIdFkeyInverseInput>;
};

/** The output of our create `PriceSize` mutation. */
export type CreatePriceSizePayload = {
  __typename?: 'CreatePriceSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceSize` that was created by this mutation. */
  priceSize?: Maybe<PriceSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceProduct` that is related to this `PriceSize`. */
  product?: Maybe<PriceProduct>;
  /** An edge for our `PriceSize`. May be used by Relay 1. */
  priceSizeEdge?: Maybe<PriceSizesEdge>;
};


/** The output of our create `PriceSize` mutation. */
export type CreatePriceSizePayloadPriceSizeEdgeArgs = {
  orderBy?: Maybe<Array<PriceSizesOrderBy>>;
};

/** All input for the create `PriceSize` mutation. */
export type CreatePriceSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceSize` to be created by this mutation. */
  priceSize: PriceSizeInput;
};

/** An input for mutations affecting `PriceSize` */
export type PriceSizeInput = {
  id?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  sizeName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceProductToProductId?: Maybe<PriceSizeProductIdFkeyInput>;
  priceEntriesUsingId?: Maybe<PriceEntrySizeIdFkeyInverseInput>;
};

/** The output of our create `InventoryItem` mutation. */
export type CreateInventoryItemPayload = {
  __typename?: 'CreateInventoryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InventoryItem` that was created by this mutation. */
  inventoryItem?: Maybe<InventoryItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InventoryItem`. May be used by Relay 1. */
  inventoryItemEdge?: Maybe<InventoryItemsEdge>;
};


/** The output of our create `InventoryItem` mutation. */
export type CreateInventoryItemPayloadInventoryItemEdgeArgs = {
  orderBy?: Maybe<Array<InventoryItemsOrderBy>>;
};

/** All input for the create `InventoryItem` mutation. */
export type CreateInventoryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InventoryItem` to be created by this mutation. */
  inventoryItem: InventoryItemInput;
};

/** An input for mutations affecting `InventoryItem` */
export type InventoryItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['String']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  palletsReceived?: Maybe<Scalars['BigFloat']>;
  palletsCommitted?: Maybe<Scalars['BigFloat']>;
  palletsOnHand?: Maybe<Scalars['BigFloat']>;
  palletsAvailable?: Maybe<Scalars['BigFloat']>;
  palletsShipped?: Maybe<Scalars['BigFloat']>;
  palletsTransferredIn?: Maybe<Scalars['BigFloat']>;
  palletsTransferredOut?: Maybe<Scalars['BigFloat']>;
  plu?: Maybe<Scalars['Boolean']>;
  countryId?: Maybe<Scalars['String']>;
  specialLotNumber?: Maybe<Scalars['String']>;
  coast?: Maybe<Scalars['String']>;
  storageRank?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
};

/** The output of our create `PackAtmosphere` mutation. */
export type CreatePackAtmospherePayload = {
  __typename?: 'CreatePackAtmospherePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackAtmosphere` that was created by this mutation. */
  packAtmosphere?: Maybe<PackAtmosphere>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackAtmosphere`. May be used by Relay 1. */
  packAtmosphereEdge?: Maybe<PackAtmospheresEdge>;
};


/** The output of our create `PackAtmosphere` mutation. */
export type CreatePackAtmospherePayloadPackAtmosphereEdgeArgs = {
  orderBy?: Maybe<Array<PackAtmospheresOrderBy>>;
};

/** All input for the create `PackAtmosphere` mutation. */
export type CreatePackAtmosphereInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackAtmosphere` to be created by this mutation. */
  packAtmosphere: PackAtmosphereInput;
};

/** An input for mutations affecting `PackAtmosphere` */
export type PackAtmosphereInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  maCode?: Maybe<Scalars['String']>;
  maDescription?: Maybe<Scalars['String']>;
};

/** The output of our create `PackBoxStyle` mutation. */
export type CreatePackBoxStylePayload = {
  __typename?: 'CreatePackBoxStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxStyle` that was created by this mutation. */
  packBoxStyle?: Maybe<PackBoxStyle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxStyle`. May be used by Relay 1. */
  packBoxStyleEdge?: Maybe<PackBoxStylesEdge>;
};


/** The output of our create `PackBoxStyle` mutation. */
export type CreatePackBoxStylePayloadPackBoxStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxStylesOrderBy>>;
};

/** All input for the create `PackBoxStyle` mutation. */
export type CreatePackBoxStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxStyle` to be created by this mutation. */
  packBoxStyle: PackBoxStyleInput;
};

/** An input for mutations affecting `PackBoxStyle` */
export type PackBoxStyleInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  boxStyle?: Maybe<Scalars['String']>;
  boxDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
};

/** The output of our create `PackBoxType` mutation. */
export type CreatePackBoxTypePayload = {
  __typename?: 'CreatePackBoxTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxType` that was created by this mutation. */
  packBoxType?: Maybe<PackBoxType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxType`. May be used by Relay 1. */
  packBoxTypeEdge?: Maybe<PackBoxTypesEdge>;
};


/** The output of our create `PackBoxType` mutation. */
export type CreatePackBoxTypePayloadPackBoxTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxTypesOrderBy>>;
};

/** All input for the create `PackBoxType` mutation. */
export type CreatePackBoxTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxType` to be created by this mutation. */
  packBoxType: PackBoxTypeInput;
};

/** An input for mutations affecting `PackBoxType` */
export type PackBoxTypeInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  boxType?: Maybe<Scalars['String']>;
  boxDescription?: Maybe<Scalars['String']>;
};

/** The output of our create `PackDestination` mutation. */
export type CreatePackDestinationPayload = {
  __typename?: 'CreatePackDestinationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackDestination` that was created by this mutation. */
  packDestination?: Maybe<PackDestination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackDestination`. May be used by Relay 1. */
  packDestinationEdge?: Maybe<PackDestinationsEdge>;
};


/** The output of our create `PackDestination` mutation. */
export type CreatePackDestinationPayloadPackDestinationEdgeArgs = {
  orderBy?: Maybe<Array<PackDestinationsOrderBy>>;
};

/** All input for the create `PackDestination` mutation. */
export type CreatePackDestinationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackDestination` to be created by this mutation. */
  packDestination: PackDestinationInput;
};

/** An input for mutations affecting `PackDestination` */
export type PackDestinationInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  destinationCode?: Maybe<Scalars['String']>;
  destinationDescription?: Maybe<Scalars['String']>;
};

/** The output of our create `PackGrade` mutation. */
export type CreatePackGradePayload = {
  __typename?: 'CreatePackGradePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackGrade` that was created by this mutation. */
  packGrade?: Maybe<PackGrade>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackGrade`. May be used by Relay 1. */
  packGradeEdge?: Maybe<PackGradesEdge>;
};


/** The output of our create `PackGrade` mutation. */
export type CreatePackGradePayloadPackGradeEdgeArgs = {
  orderBy?: Maybe<Array<PackGradesOrderBy>>;
};

/** All input for the create `PackGrade` mutation. */
export type CreatePackGradeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackGrade` to be created by this mutation. */
  packGrade: PackGradeInput;
};

/** An input for mutations affecting `PackGrade` */
export type PackGradeInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  gradeCode?: Maybe<Scalars['String']>;
  gradeDescription?: Maybe<Scalars['String']>;
};

/** The output of our create `PackHold` mutation. */
export type CreatePackHoldPayload = {
  __typename?: 'CreatePackHoldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackHold` that was created by this mutation. */
  packHold?: Maybe<PackHold>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackHold`. May be used by Relay 1. */
  packHoldEdge?: Maybe<PackHoldsEdge>;
};


/** The output of our create `PackHold` mutation. */
export type CreatePackHoldPayloadPackHoldEdgeArgs = {
  orderBy?: Maybe<Array<PackHoldsOrderBy>>;
};

/** All input for the create `PackHold` mutation. */
export type CreatePackHoldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackHold` to be created by this mutation. */
  packHold: PackHoldInput;
};

/** An input for mutations affecting `PackHold` */
export type PackHoldInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  holdCode?: Maybe<Scalars['String']>;
  holdDescription?: Maybe<Scalars['String']>;
};

/** The output of our create `PackLabel` mutation. */
export type CreatePackLabelPayload = {
  __typename?: 'CreatePackLabelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLabel` that was created by this mutation. */
  packLabel?: Maybe<PackLabel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLabel`. May be used by Relay 1. */
  packLabelEdge?: Maybe<PackLabelsEdge>;
};


/** The output of our create `PackLabel` mutation. */
export type CreatePackLabelPayloadPackLabelEdgeArgs = {
  orderBy?: Maybe<Array<PackLabelsOrderBy>>;
};

/** All input for the create `PackLabel` mutation. */
export type CreatePackLabelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLabel` to be created by this mutation. */
  packLabel: PackLabelInput;
};

/** An input for mutations affecting `PackLabel` */
export type PackLabelInput = {
  id?: Maybe<Scalars['BigInt']>;
  labelCode?: Maybe<Scalars['String']>;
  labelName?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
};

/** The output of our create `PackLiner` mutation. */
export type CreatePackLinerPayload = {
  __typename?: 'CreatePackLinerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLiner` that was created by this mutation. */
  packLiner?: Maybe<PackLiner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLiner`. May be used by Relay 1. */
  packLinerEdge?: Maybe<PackLinersEdge>;
};


/** The output of our create `PackLiner` mutation. */
export type CreatePackLinerPayloadPackLinerEdgeArgs = {
  orderBy?: Maybe<Array<PackLinersOrderBy>>;
};

/** All input for the create `PackLiner` mutation. */
export type CreatePackLinerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLiner` to be created by this mutation. */
  packLiner: PackLinerInput;
};

/** An input for mutations affecting `PackLiner` */
export type PackLinerInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  linerCode?: Maybe<Scalars['String']>;
  linerDescription?: Maybe<Scalars['String']>;
};

/** The output of our create `PackMaster` mutation. */
export type CreatePackMasterPayload = {
  __typename?: 'CreatePackMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackMaster` that was created by this mutation. */
  packMaster?: Maybe<PackMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackMaster`. May be used by Relay 1. */
  packMasterEdge?: Maybe<PackMastersEdge>;
};


/** The output of our create `PackMaster` mutation. */
export type CreatePackMasterPayloadPackMasterEdgeArgs = {
  orderBy?: Maybe<Array<PackMastersOrderBy>>;
};

/** All input for the create `PackMaster` mutation. */
export type CreatePackMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackMaster` to be created by this mutation. */
  packMaster: PackMasterInput;
};

/** An input for mutations affecting `PackMaster` */
export type PackMasterInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  labelCodeId?: Maybe<Scalars['String']>;
  customerCodeId?: Maybe<Scalars['String']>;
  boxTypeId?: Maybe<Scalars['String']>;
  boxStyleId?: Maybe<Scalars['String']>;
  packStyleId?: Maybe<Scalars['String']>;
  outCodeId?: Maybe<Scalars['String']>;
  outQuantity?: Maybe<Scalars['String']>;
  outWeight?: Maybe<Scalars['String']>;
  productionCodeId?: Maybe<Scalars['String']>;
  treeRipeId?: Maybe<Scalars['String']>;
  gradeCodeId?: Maybe<Scalars['String']>;
  maCodeId?: Maybe<Scalars['String']>;
  linerCodeId?: Maybe<Scalars['String']>;
  netWeightContents?: Maybe<Scalars['BigFloat']>;
  netWeightBox?: Maybe<Scalars['BigFloat']>;
  boxLength?: Maybe<Scalars['BigFloat']>;
  boxWidth?: Maybe<Scalars['BigFloat']>;
  boxHeight?: Maybe<Scalars['BigFloat']>;
  palletTypeId?: Maybe<Scalars['String']>;
  defaultPalletQuantity?: Maybe<Scalars['BigFloat']>;
  pluUpcCode?: Maybe<Scalars['String']>;
  destinationCodeId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  oldLabelCode?: Maybe<Scalars['String']>;
  jvPackCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  speciesId?: Maybe<Scalars['String']>;
  holdCodeId?: Maybe<Scalars['String']>;
};

/** The output of our create `PackOut` mutation. */
export type CreatePackOutPayload = {
  __typename?: 'CreatePackOutPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackOut` that was created by this mutation. */
  packOut?: Maybe<PackOut>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackOut`. May be used by Relay 1. */
  packOutEdge?: Maybe<PackOutsEdge>;
};


/** The output of our create `PackOut` mutation. */
export type CreatePackOutPayloadPackOutEdgeArgs = {
  orderBy?: Maybe<Array<PackOutsOrderBy>>;
};

/** All input for the create `PackOut` mutation. */
export type CreatePackOutInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackOut` to be created by this mutation. */
  packOut: PackOutInput;
};

/** An input for mutations affecting `PackOut` */
export type PackOutInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  outCode?: Maybe<Scalars['String']>;
  outDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** The output of our create `PackPalletType` mutation. */
export type CreatePackPalletTypePayload = {
  __typename?: 'CreatePackPalletTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackPalletType` that was created by this mutation. */
  packPalletType?: Maybe<PackPalletType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackPalletType`. May be used by Relay 1. */
  packPalletTypeEdge?: Maybe<PackPalletTypesEdge>;
};


/** The output of our create `PackPalletType` mutation. */
export type CreatePackPalletTypePayloadPackPalletTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackPalletTypesOrderBy>>;
};

/** All input for the create `PackPalletType` mutation. */
export type CreatePackPalletTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackPalletType` to be created by this mutation. */
  packPalletType: PackPalletTypeInput;
};

/** An input for mutations affecting `PackPalletType` */
export type PackPalletTypeInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  palletType?: Maybe<Scalars['String']>;
  palletTypeDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** The output of our create `PackProduction` mutation. */
export type CreatePackProductionPayload = {
  __typename?: 'CreatePackProductionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackProduction` that was created by this mutation. */
  packProduction?: Maybe<PackProduction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackProduction`. May be used by Relay 1. */
  packProductionEdge?: Maybe<PackProductionsEdge>;
};


/** The output of our create `PackProduction` mutation. */
export type CreatePackProductionPayloadPackProductionEdgeArgs = {
  orderBy?: Maybe<Array<PackProductionsOrderBy>>;
};

/** All input for the create `PackProduction` mutation. */
export type CreatePackProductionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackProduction` to be created by this mutation. */
  packProduction: PackProductionInput;
};

/** An input for mutations affecting `PackProduction` */
export type PackProductionInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  productionCode?: Maybe<Scalars['String']>;
  productionDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** The output of our create `PackSpecial` mutation. */
export type CreatePackSpecialPayload = {
  __typename?: 'CreatePackSpecialPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackSpecial` that was created by this mutation. */
  packSpecial?: Maybe<PackSpecial>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackSpecial`. May be used by Relay 1. */
  packSpecialEdge?: Maybe<PackSpecialsEdge>;
};


/** The output of our create `PackSpecial` mutation. */
export type CreatePackSpecialPayloadPackSpecialEdgeArgs = {
  orderBy?: Maybe<Array<PackSpecialsOrderBy>>;
};

/** All input for the create `PackSpecial` mutation. */
export type CreatePackSpecialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackSpecial` to be created by this mutation. */
  packSpecial: PackSpecialInput;
};

/** An input for mutations affecting `PackSpecial` */
export type PackSpecialInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  customerCode?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
};

/** The output of our create `PackStyle` mutation. */
export type CreatePackStylePayload = {
  __typename?: 'CreatePackStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackStyle` that was created by this mutation. */
  packStyle?: Maybe<PackStyle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackStyle`. May be used by Relay 1. */
  packStyleEdge?: Maybe<PackStylesEdge>;
};


/** The output of our create `PackStyle` mutation. */
export type CreatePackStylePayloadPackStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackStylesOrderBy>>;
};

/** All input for the create `PackStyle` mutation. */
export type CreatePackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackStyle` to be created by this mutation. */
  packStyle: PackStyleInput;
};

/** An input for mutations affecting `PackStyle` */
export type PackStyleInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  packStyle?: Maybe<Scalars['String']>;
  styleDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** The output of our create `PackTreeRipe` mutation. */
export type CreatePackTreeRipePayload = {
  __typename?: 'CreatePackTreeRipePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackTreeRipe` that was created by this mutation. */
  packTreeRipe?: Maybe<PackTreeRipe>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackTreeRipe`. May be used by Relay 1. */
  packTreeRipeEdge?: Maybe<PackTreeRipesEdge>;
};


/** The output of our create `PackTreeRipe` mutation. */
export type CreatePackTreeRipePayloadPackTreeRipeEdgeArgs = {
  orderBy?: Maybe<Array<PackTreeRipesOrderBy>>;
};

/** All input for the create `PackTreeRipe` mutation. */
export type CreatePackTreeRipeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackTreeRipe` to be created by this mutation. */
  packTreeRipe: PackTreeRipeInput;
};

/** An input for mutations affecting `PackTreeRipe` */
export type PackTreeRipeInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  treeRipe?: Maybe<Scalars['String']>;
  treeRipeDescription?: Maybe<Scalars['String']>;
};

/** The output of our create `Pallet` mutation. */
export type CreatePalletPayload = {
  __typename?: 'CreatePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Pallet` that was created by this mutation. */
  pallet?: Maybe<Pallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Pallet`. May be used by Relay 1. */
  palletEdge?: Maybe<PalletsEdge>;
};


/** The output of our create `Pallet` mutation. */
export type CreatePalletPayloadPalletEdgeArgs = {
  orderBy?: Maybe<Array<PalletsOrderBy>>;
};

/** All input for the create `Pallet` mutation. */
export type CreatePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Pallet` to be created by this mutation. */
  pallet: PalletInput;
};

/** An input for mutations affecting `Pallet` */
export type PalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  productId?: Maybe<Scalars['String']>;
  currentBoxQuantity?: Maybe<Scalars['BigFloat']>;
  receivedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  returnedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  room?: Maybe<Scalars['String']>;
  section?: Maybe<Scalars['String']>;
  row?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  dateTransferredToStorage?: Maybe<Scalars['Date']>;
  orderId?: Maybe<Scalars['String']>;
  backOrderId?: Maybe<Scalars['String']>;
  shipped?: Maybe<Scalars['Boolean']>;
  age?: Maybe<Scalars['BigFloat']>;
  volumeDiscountCode?: Maybe<Scalars['String']>;
  originalLocationId?: Maybe<Scalars['String']>;
  filler?: Maybe<Scalars['String']>;
  growerId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  billOfLading?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  temperatureRecording?: Maybe<Scalars['String']>;
};

/** The output of our create `PalletSection` mutation. */
export type CreatePalletSectionPayload = {
  __typename?: 'CreatePalletSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletSection` that was created by this mutation. */
  palletSection?: Maybe<PalletSection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PalletSection`. May be used by Relay 1. */
  palletSectionEdge?: Maybe<PalletSectionsEdge>;
};


/** The output of our create `PalletSection` mutation. */
export type CreatePalletSectionPayloadPalletSectionEdgeArgs = {
  orderBy?: Maybe<Array<PalletSectionsOrderBy>>;
};

/** All input for the create `PalletSection` mutation. */
export type CreatePalletSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletSection` to be created by this mutation. */
  palletSection: PalletSectionInput;
};

/** An input for mutations affecting `PalletSection` */
export type PalletSectionInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletId: Scalars['String'];
  growerId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  sizeId?: Maybe<Scalars['String']>;
  boxQuantity?: Maybe<Scalars['BigFloat']>;
  packDate?: Maybe<Scalars['String']>;
};

/** The output of our create `PalletTempOne` mutation. */
export type CreatePalletTempOnePayload = {
  __typename?: 'CreatePalletTempOnePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletTempOne` that was created by this mutation. */
  palletTempOne?: Maybe<PalletTempOne>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PalletTempOne`. May be used by Relay 1. */
  palletTempOneEdge?: Maybe<PalletTempOnesEdge>;
};


/** The output of our create `PalletTempOne` mutation. */
export type CreatePalletTempOnePayloadPalletTempOneEdgeArgs = {
  orderBy?: Maybe<Array<PalletTempOnesOrderBy>>;
};

/** All input for the create `PalletTempOne` mutation. */
export type CreatePalletTempOneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletTempOne` to be created by this mutation. */
  palletTempOne: PalletTempOneInput;
};

/** An input for mutations affecting `PalletTempOne` */
export type PalletTempOneInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode: Scalars['String'];
  palletId: Scalars['String'];
  productId?: Maybe<Scalars['String']>;
  currentBoxQuantity?: Maybe<Scalars['BigFloat']>;
  receivedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  returnedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  room?: Maybe<Scalars['String']>;
  section?: Maybe<Scalars['String']>;
  row?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  dateTransferredToStorage?: Maybe<Scalars['Date']>;
  orderId?: Maybe<Scalars['String']>;
  backOrderId?: Maybe<Scalars['String']>;
  shipped?: Maybe<Scalars['Boolean']>;
  age?: Maybe<Scalars['BigFloat']>;
  volumeDiscountCode?: Maybe<Scalars['String']>;
  originalLocationId?: Maybe<Scalars['String']>;
};

/** The output of our create `PalletTempTwo` mutation. */
export type CreatePalletTempTwoPayload = {
  __typename?: 'CreatePalletTempTwoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletTempTwo` that was created by this mutation. */
  palletTempTwo?: Maybe<PalletTempTwo>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PalletTempTwo`. May be used by Relay 1. */
  palletTempTwoEdge?: Maybe<PalletTempTwosEdge>;
};


/** The output of our create `PalletTempTwo` mutation. */
export type CreatePalletTempTwoPayloadPalletTempTwoEdgeArgs = {
  orderBy?: Maybe<Array<PalletTempTwosOrderBy>>;
};

/** All input for the create `PalletTempTwo` mutation. */
export type CreatePalletTempTwoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletTempTwo` to be created by this mutation. */
  palletTempTwo: PalletTempTwoInput;
};

/** An input for mutations affecting `PalletTempTwo` */
export type PalletTempTwoInput = {
  id?: Maybe<Scalars['BigInt']>;
  filler?: Maybe<Scalars['String']>;
  palletId: Scalars['String'];
  growerId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  billOfLading?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  temperatureRecording?: Maybe<Scalars['String']>;
};

/** The output of our create `ProductMaster` mutation. */
export type CreateProductMasterPayload = {
  __typename?: 'CreateProductMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductMaster` that was created by this mutation. */
  productMaster?: Maybe<ProductMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductMaster`. May be used by Relay 1. */
  productMasterEdge?: Maybe<ProductMastersEdge>;
};


/** The output of our create `ProductMaster` mutation. */
export type CreateProductMasterPayloadProductMasterEdgeArgs = {
  orderBy?: Maybe<Array<ProductMastersOrderBy>>;
};

/** All input for the create `ProductMaster` mutation. */
export type CreateProductMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductMaster` to be created by this mutation. */
  productMaster: ProductMasterInput;
};

/** An input for mutations affecting `ProductMaster` */
export type ProductMasterInput = {
  id: Scalars['String'];
  defaultPalletQuantity?: Maybe<Scalars['String']>;
  lotNumber?: Maybe<Scalars['String']>;
};

/** The output of our create `ProductSize` mutation. */
export type CreateProductSizePayload = {
  __typename?: 'CreateProductSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSize` that was created by this mutation. */
  productSize?: Maybe<ProductSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSize`. May be used by Relay 1. */
  productSizeEdge?: Maybe<ProductSizesEdge>;
};


/** The output of our create `ProductSize` mutation. */
export type CreateProductSizePayloadProductSizeEdgeArgs = {
  orderBy?: Maybe<Array<ProductSizesOrderBy>>;
};

/** All input for the create `ProductSize` mutation. */
export type CreateProductSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSize` to be created by this mutation. */
  productSize: ProductSizeInput;
};

/** An input for mutations affecting `ProductSize` */
export type ProductSizeInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  jvCode?: Maybe<Scalars['String']>;
  jvDescription?: Maybe<Scalars['String']>;
  shipperCode?: Maybe<Scalars['String']>;
  shipperDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
};

/** The output of our create `ProductSpecies` mutation. */
export type CreateProductSpeciesPayload = {
  __typename?: 'CreateProductSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSpecies` that was created by this mutation. */
  productSpecies?: Maybe<ProductSpecies>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSpecies`. May be used by Relay 1. */
  productSpeciesEdge?: Maybe<ProductSpeciesEdge>;
};


/** The output of our create `ProductSpecies` mutation. */
export type CreateProductSpeciesPayloadProductSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<ProductSpeciesOrderBy>>;
};

/** All input for the create `ProductSpecies` mutation. */
export type CreateProductSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSpecies` to be created by this mutation. */
  productSpecies: ProductSpeciesInput;
};

/** An input for mutations affecting `ProductSpecies` */
export type ProductSpeciesInput = {
  id: Scalars['String'];
  speciesDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  fdaProductCode?: Maybe<Scalars['String']>;
  fdaIndustryCode?: Maybe<Scalars['String']>;
  defaultTemperature?: Maybe<Scalars['String']>;
};

/** The output of our create `ProductVariety` mutation. */
export type CreateProductVarietyPayload = {
  __typename?: 'CreateProductVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductVariety` that was created by this mutation. */
  productVariety?: Maybe<ProductVariety>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductVariety`. May be used by Relay 1. */
  productVarietyEdge?: Maybe<ProductVarietiesEdge>;
};


/** The output of our create `ProductVariety` mutation. */
export type CreateProductVarietyPayloadProductVarietyEdgeArgs = {
  orderBy?: Maybe<Array<ProductVarietiesOrderBy>>;
};

/** All input for the create `ProductVariety` mutation. */
export type CreateProductVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductVariety` to be created by this mutation. */
  productVariety: ProductVarietyInput;
};

/** An input for mutations affecting `ProductVariety` */
export type ProductVarietyInput = {
  id: Scalars['String'];
  varietyDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  customerLetterSequence?: Maybe<Scalars['String']>;
  summaryCode?: Maybe<Scalars['String']>;
  varietyGroup?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** The output of our create `ShipperProjection` mutation. */
export type CreateShipperProjectionPayload = {
  __typename?: 'CreateShipperProjectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjection` that was created by this mutation. */
  shipperProjection?: Maybe<ShipperProjection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjection`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjection`. May be used by Relay 1. */
  shipperProjectionEdge?: Maybe<ShipperProjectionsEdge>;
};


/** The output of our create `ShipperProjection` mutation. */
export type CreateShipperProjectionPayloadShipperProjectionEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
};

/** All input for the create `ShipperProjection` mutation. */
export type CreateShipperProjectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjection` to be created by this mutation. */
  shipperProjection: ShipperProjectionInput;
};

/** An input for mutations affecting `ShipperProjection` */
export type ShipperProjectionInput = {
  id?: Maybe<Scalars['BigInt']>;
  completedAt?: Maybe<Scalars['Datetime']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<FkShipperProjectionIdInverseInput>;
};

/** The output of our create `ShipperProjectionEntry` mutation. */
export type CreateShipperProjectionEntryPayload = {
  __typename?: 'CreateShipperProjectionEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionEntry` that was created by this mutation. */
  shipperProjectionEntry?: Maybe<ShipperProjectionEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProjectionVessel` that is related to this `ShipperProjectionEntry`. */
  vessel?: Maybe<ShipperProjectionVessel>;
  /** Reads a single `ShipperProjectionProduct` that is related to this `ShipperProjectionEntry`. */
  product?: Maybe<ShipperProjectionProduct>;
  /** Reads a single `ShipperProjection` that is related to this `ShipperProjectionEntry`. */
  shipperProjection?: Maybe<ShipperProjection>;
  /** An edge for our `ShipperProjectionEntry`. May be used by Relay 1. */
  shipperProjectionEntryEdge?: Maybe<ShipperProjectionEntriesEdge>;
};


/** The output of our create `ShipperProjectionEntry` mutation. */
export type CreateShipperProjectionEntryPayloadShipperProjectionEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
};

/** All input for the create `ShipperProjectionEntry` mutation. */
export type CreateShipperProjectionEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionEntry` to be created by this mutation. */
  shipperProjectionEntry: ShipperProjectionEntryInput;
};

/** An input for mutations affecting `ShipperProjectionEntry` */
export type ShipperProjectionEntryInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  shipperProjectionId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionEntryVesselIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
  shipperProjectionToShipperProjectionId?: Maybe<FkShipperProjectionIdInput>;
};

/** The output of our create `ShipperProjectionProduct` mutation. */
export type CreateShipperProjectionProductPayload = {
  __typename?: 'CreateShipperProjectionProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionProduct` that was created by this mutation. */
  shipperProjectionProduct?: Maybe<ShipperProjectionProduct>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionProduct`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjectionProduct`. May be used by Relay 1. */
  shipperProjectionProductEdge?: Maybe<ShipperProjectionProductsEdge>;
};


/** The output of our create `ShipperProjectionProduct` mutation. */
export type CreateShipperProjectionProductPayloadShipperProjectionProductEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
};

/** All input for the create `ShipperProjectionProduct` mutation. */
export type CreateShipperProjectionProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionProduct` to be created by this mutation. */
  shipperProjectionProduct: ShipperProjectionProductInput;
};

/** An input for mutations affecting `ShipperProjectionProduct` */
export type ShipperProjectionProductInput = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** The output of our create `ShipperProjectionVessel` mutation. */
export type CreateShipperProjectionVesselPayload = {
  __typename?: 'CreateShipperProjectionVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVessel` that was created by this mutation. */
  shipperProjectionVessel?: Maybe<ShipperProjectionVessel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVessel`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjectionVessel`. May be used by Relay 1. */
  shipperProjectionVesselEdge?: Maybe<ShipperProjectionVesselsEdge>;
};


/** The output of our create `ShipperProjectionVessel` mutation. */
export type CreateShipperProjectionVesselPayloadShipperProjectionVesselEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
};

/** All input for the create `ShipperProjectionVessel` mutation. */
export type CreateShipperProjectionVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVessel` to be created by this mutation. */
  shipperProjectionVessel: ShipperProjectionVesselInput;
};

/** An input for mutations affecting `ShipperProjectionVessel` */
export type ShipperProjectionVesselInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  isReviewed?: Maybe<Scalars['Boolean']>;
  previousName?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselIdFkeyInverseInput>;
};

/** The output of our create `Vessel` mutation. */
export type CreateVesselPayload = {
  __typename?: 'CreateVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vessel` that was created by this mutation. */
  vessel?: Maybe<Vessel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vessel`. May be used by Relay 1. */
  vesselEdge?: Maybe<VesselsEdge>;
};


/** The output of our create `Vessel` mutation. */
export type CreateVesselPayloadVesselEdgeArgs = {
  orderBy?: Maybe<Array<VesselsOrderBy>>;
};

/** All input for the create `Vessel` mutation. */
export type CreateVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vessel` to be created by this mutation. */
  vessel: VesselInput;
};

/** An input for mutations affecting `Vessel` */
export type VesselInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode: Scalars['String'];
  vesselName?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  dischargeDate?: Maybe<Scalars['Date']>;
  coast?: Maybe<Scalars['String']>;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PersonContact` that is related to this `User`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  id: Scalars['BigInt'];
};

/** All input for the `updateUserByPin` mutation. */
export type UpdateUserByPinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  pin: Scalars['String'];
};

/** The output of our update `UserMessage` mutation. */
export type UpdateUserMessagePayload = {
  __typename?: 'UpdateUserMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserMessage` that was updated by this mutation. */
  userMessage?: Maybe<UserMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserMessage`. */
  user?: Maybe<User>;
  /** An edge for our `UserMessage`. May be used by Relay 1. */
  userMessageEdge?: Maybe<UserMessagesEdge>;
};


/** The output of our update `UserMessage` mutation. */
export type UpdateUserMessagePayloadUserMessageEdgeArgs = {
  orderBy?: Maybe<Array<UserMessagesOrderBy>>;
};

/** All input for the `updateUserMessageByNodeId` mutation. */
export type UpdateUserMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserMessage` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UserMessage` being updated. */
  patch: UserMessagePatch;
};

/** All input for the `updateUserMessage` mutation. */
export type UpdateUserMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `UserMessage` being updated. */
  patch: UserMessagePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ContactGroup` mutation. */
export type UpdateContactGroupPayload = {
  __typename?: 'UpdateContactGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroup` that was updated by this mutation. */
  contactGroup?: Maybe<ContactGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ContactGroup`. */
  user?: Maybe<User>;
  /** An edge for our `ContactGroup`. May be used by Relay 1. */
  contactGroupEdge?: Maybe<ContactGroupsEdge>;
};


/** The output of our update `ContactGroup` mutation. */
export type UpdateContactGroupPayloadContactGroupEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupsOrderBy>>;
};

/** All input for the `updateContactGroupByNodeId` mutation. */
export type UpdateContactGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContactGroup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ContactGroup` being updated. */
  patch: ContactGroupPatch;
};

/** All input for the `updateContactGroup` mutation. */
export type UpdateContactGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ContactGroup` being updated. */
  patch: ContactGroupPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ContactGroupPersonContact` mutation. */
export type UpdateContactGroupPersonContactPayload = {
  __typename?: 'UpdateContactGroupPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroupPersonContact` that was updated by this mutation. */
  contactGroupPersonContact?: Maybe<ContactGroupPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ContactGroup` that is related to this `ContactGroupPersonContact`. */
  group?: Maybe<ContactGroup>;
  /** Reads a single `PersonContact` that is related to this `ContactGroupPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ContactGroupPersonContact`. May be used by Relay 1. */
  contactGroupPersonContactEdge?: Maybe<ContactGroupPersonContactsEdge>;
};


/** The output of our update `ContactGroupPersonContact` mutation. */
export type UpdateContactGroupPersonContactPayloadContactGroupPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupPersonContactsOrderBy>>;
};

/** All input for the `updateContactGroupPersonContactByNodeId` mutation. */
export type UpdateContactGroupPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContactGroupPersonContact` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ContactGroupPersonContact` being updated. */
  patch: ContactGroupPersonContactPatch;
};

/** All input for the `updateContactGroupPersonContact` mutation. */
export type UpdateContactGroupPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ContactGroupPersonContact` being updated. */
  patch: ContactGroupPersonContactPatch;
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};

/** The output of our update `Country` mutation. */
export type UpdateCountryPayload = {
  __typename?: 'UpdateCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was updated by this mutation. */
  country?: Maybe<Country>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our update `Country` mutation. */
export type UpdateCountryPayloadCountryEdgeArgs = {
  orderBy?: Maybe<Array<CountriesOrderBy>>;
};

/** All input for the `updateCountryByNodeId` mutation. */
export type UpdateCountryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Country` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Country` being updated. */
  patch: CountryPatch;
};

/** All input for the `updateCountry` mutation. */
export type UpdateCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Country` being updated. */
  patch: CountryPatch;
  id: Scalars['String'];
};

/** The output of our update `Customer` mutation. */
export type UpdateCustomerPayload = {
  __typename?: 'UpdateCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was updated by this mutation. */
  customer?: Maybe<Customer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Customer`. */
  country?: Maybe<Country>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our update `Customer` mutation. */
export type UpdateCustomerPayloadCustomerEdgeArgs = {
  orderBy?: Maybe<Array<CustomersOrderBy>>;
};

/** All input for the `updateCustomerByNodeId` mutation. */
export type UpdateCustomerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customer` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Customer` being updated. */
  patch: CustomerPatch;
};

/** All input for the `updateCustomer` mutation. */
export type UpdateCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Customer` being updated. */
  patch: CustomerPatch;
  id: Scalars['String'];
};

/** The output of our update `CustomerPersonContact` mutation. */
export type UpdateCustomerPersonContactPayload = {
  __typename?: 'UpdateCustomerPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPersonContact` that was updated by this mutation. */
  customerPersonContact?: Maybe<CustomerPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `CustomerPersonContact`. */
  customer?: Maybe<Customer>;
  /** Reads a single `PersonContact` that is related to this `CustomerPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `CustomerPersonContact`. May be used by Relay 1. */
  customerPersonContactEdge?: Maybe<CustomerPersonContactsEdge>;
};


/** The output of our update `CustomerPersonContact` mutation. */
export type UpdateCustomerPersonContactPayloadCustomerPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<CustomerPersonContactsOrderBy>>;
};

/** All input for the `updateCustomerPersonContactByNodeId` mutation. */
export type UpdateCustomerPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerPersonContact` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CustomerPersonContact` being updated. */
  patch: CustomerPersonContactPatch;
};

/** All input for the `updateCustomerPersonContact` mutation. */
export type UpdateCustomerPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CustomerPersonContact` being updated. */
  patch: CustomerPersonContactPatch;
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our update `PersonContact` mutation. */
export type UpdatePersonContactPayload = {
  __typename?: 'UpdatePersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PersonContact` that was updated by this mutation. */
  personContact?: Maybe<PersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PersonContact`. May be used by Relay 1. */
  personContactEdge?: Maybe<PersonContactsEdge>;
};


/** The output of our update `PersonContact` mutation. */
export type UpdatePersonContactPayloadPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
};

/** All input for the `updatePersonContactByNodeId` mutation. */
export type UpdatePersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PersonContact` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PersonContact` being updated. */
  patch: PersonContactPatch;
};

/** All input for the `updatePersonContact` mutation. */
export type UpdatePersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PersonContact` being updated. */
  patch: PersonContactPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Shipper` mutation. */
export type UpdateShipperPayload = {
  __typename?: 'UpdateShipperPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipper` that was updated by this mutation. */
  shipper?: Maybe<Shipper>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Shipper`. */
  country?: Maybe<Country>;
  /** An edge for our `Shipper`. May be used by Relay 1. */
  shipperEdge?: Maybe<ShippersEdge>;
};


/** The output of our update `Shipper` mutation. */
export type UpdateShipperPayloadShipperEdgeArgs = {
  orderBy?: Maybe<Array<ShippersOrderBy>>;
};

/** All input for the `updateShipperByNodeId` mutation. */
export type UpdateShipperByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Shipper` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Shipper` being updated. */
  patch: ShipperPatch;
};

/** All input for the `updateShipper` mutation. */
export type UpdateShipperInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Shipper` being updated. */
  patch: ShipperPatch;
  id: Scalars['String'];
};

/** The output of our update `ShipperPersonContact` mutation. */
export type UpdateShipperPersonContactPayload = {
  __typename?: 'UpdateShipperPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperPersonContact` that was updated by this mutation. */
  shipperPersonContact?: Maybe<ShipperPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperPersonContact`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `PersonContact` that is related to this `ShipperPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ShipperPersonContact`. May be used by Relay 1. */
  shipperPersonContactEdge?: Maybe<ShipperPersonContactsEdge>;
};


/** The output of our update `ShipperPersonContact` mutation. */
export type UpdateShipperPersonContactPayloadShipperPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ShipperPersonContactsOrderBy>>;
};

/** All input for the `updateShipperPersonContactByNodeId` mutation. */
export type UpdateShipperPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperPersonContact` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperPersonContact` being updated. */
  patch: ShipperPersonContactPatch;
};

/** All input for the `updateShipperPersonContact` mutation. */
export type UpdateShipperPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperPersonContact` being updated. */
  patch: ShipperPersonContactPatch;
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our update `Warehouse` mutation. */
export type UpdateWarehousePayload = {
  __typename?: 'UpdateWarehousePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` that was updated by this mutation. */
  warehouse?: Maybe<Warehouse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Warehouse`. */
  country?: Maybe<Country>;
  /** An edge for our `Warehouse`. May be used by Relay 1. */
  warehouseEdge?: Maybe<WarehousesEdge>;
};


/** The output of our update `Warehouse` mutation. */
export type UpdateWarehousePayloadWarehouseEdgeArgs = {
  orderBy?: Maybe<Array<WarehousesOrderBy>>;
};

/** All input for the `updateWarehouseByNodeId` mutation. */
export type UpdateWarehouseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Warehouse` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Warehouse` being updated. */
  patch: WarehousePatch;
};

/** All input for the `updateWarehouse` mutation. */
export type UpdateWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Warehouse` being updated. */
  patch: WarehousePatch;
  id: Scalars['String'];
};

/** The output of our update `WarehousePersonContact` mutation. */
export type UpdateWarehousePersonContactPayload = {
  __typename?: 'UpdateWarehousePersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WarehousePersonContact` that was updated by this mutation. */
  warehousePersonContact?: Maybe<WarehousePersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Warehouse` that is related to this `WarehousePersonContact`. */
  warehouse?: Maybe<Warehouse>;
  /** Reads a single `PersonContact` that is related to this `WarehousePersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `WarehousePersonContact`. May be used by Relay 1. */
  warehousePersonContactEdge?: Maybe<WarehousePersonContactsEdge>;
};


/** The output of our update `WarehousePersonContact` mutation. */
export type UpdateWarehousePersonContactPayloadWarehousePersonContactEdgeArgs = {
  orderBy?: Maybe<Array<WarehousePersonContactsOrderBy>>;
};

/** All input for the `updateWarehousePersonContactByNodeId` mutation. */
export type UpdateWarehousePersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WarehousePersonContact` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `WarehousePersonContact` being updated. */
  patch: WarehousePersonContactPatch;
};

/** All input for the `updateWarehousePersonContact` mutation. */
export type UpdateWarehousePersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `WarehousePersonContact` being updated. */
  patch: WarehousePersonContactPatch;
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our update `ChileDepartureInspectionPallet` mutation. */
export type UpdateChileDepartureInspectionPalletPayload = {
  __typename?: 'UpdateChileDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ChileDepartureInspectionPallet` that was updated by this mutation. */
  chileDepartureInspectionPallet?: Maybe<ChileDepartureInspectionPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ChileDepartureInspectionPallet`. May be used by Relay 1. */
  chileDepartureInspectionPalletEdge?: Maybe<ChileDepartureInspectionPalletsEdge>;
};


/** The output of our update `ChileDepartureInspectionPallet` mutation. */
export type UpdateChileDepartureInspectionPalletPayloadChileDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<ChileDepartureInspectionPalletsOrderBy>>;
};

/** All input for the `updateChileDepartureInspectionPalletByNodeId` mutation. */
export type UpdateChileDepartureInspectionPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ChileDepartureInspectionPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ChileDepartureInspectionPallet` being updated. */
  patch: ChileDepartureInspectionPalletPatch;
};

/** Represents an update to a `ChileDepartureInspectionPallet`. Fields that are set will be updated. */
export type ChileDepartureInspectionPalletPatch = {
  id?: Maybe<Scalars['String']>;
  lotId?: Maybe<Scalars['String']>;
  lotNumber?: Maybe<Scalars['String']>;
  locationName?: Maybe<Scalars['String']>;
  shipper?: Maybe<Scalars['String']>;
  inspectionDate?: Maybe<Scalars['Date']>;
  productName?: Maybe<Scalars['String']>;
  packingType?: Maybe<Scalars['String']>;
  productType?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  supervisor?: Maybe<Scalars['String']>;
  palletNumber?: Maybe<Scalars['String']>;
  boxesCount?: Maybe<Scalars['BigFloat']>;
  netWeight?: Maybe<Scalars['BigFloat']>;
  grower?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  packingDate?: Maybe<Scalars['Date']>;
  label?: Maybe<Scalars['String']>;
  temperature?: Maybe<Scalars['String']>;
  openAppearance?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  stem?: Maybe<Scalars['String']>;
  texture?: Maybe<Scalars['String']>;
  bunchesCount?: Maybe<Scalars['BigFloat']>;
  brix?: Maybe<Scalars['BigFloat']>;
  diameterMin?: Maybe<Scalars['BigFloat']>;
  diameterMax?: Maybe<Scalars['BigFloat']>;
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  decayPct?: Maybe<Scalars['BigFloat']>;
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  shatterPct?: Maybe<Scalars['BigFloat']>;
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  scoreName?: Maybe<Scalars['String']>;
  reportLink?: Maybe<Scalars['String']>;
  imagesLink?: Maybe<Scalars['String']>;
};

/** All input for the `updateChileDepartureInspectionPallet` mutation. */
export type UpdateChileDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ChileDepartureInspectionPallet` being updated. */
  patch: ChileDepartureInspectionPalletPatch;
  id: Scalars['String'];
};

/** The output of our update `PeruDepartureInspection` mutation. */
export type UpdatePeruDepartureInspectionPayload = {
  __typename?: 'UpdatePeruDepartureInspectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspection` that was updated by this mutation. */
  peruDepartureInspection?: Maybe<PeruDepartureInspection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PeruDepartureInspection`. May be used by Relay 1. */
  peruDepartureInspectionEdge?: Maybe<PeruDepartureInspectionsEdge>;
};


/** The output of our update `PeruDepartureInspection` mutation. */
export type UpdatePeruDepartureInspectionPayloadPeruDepartureInspectionEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionsOrderBy>>;
};

/** All input for the `updatePeruDepartureInspectionByNodeId` mutation. */
export type UpdatePeruDepartureInspectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PeruDepartureInspection` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PeruDepartureInspection` being updated. */
  patch: PeruDepartureInspectionPatch;
};

/** All input for the `updatePeruDepartureInspection` mutation. */
export type UpdatePeruDepartureInspectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PeruDepartureInspection` being updated. */
  patch: PeruDepartureInspectionPatch;
  containerId: Scalars['String'];
};

/** The output of our update `PeruDepartureInspectionPallet` mutation. */
export type UpdatePeruDepartureInspectionPalletPayload = {
  __typename?: 'UpdatePeruDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspectionPallet` that was updated by this mutation. */
  peruDepartureInspectionPallet?: Maybe<PeruDepartureInspectionPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PeruDepartureInspection` that is related to this `PeruDepartureInspectionPallet`. */
  container?: Maybe<PeruDepartureInspection>;
  /** An edge for our `PeruDepartureInspectionPallet`. May be used by Relay 1. */
  peruDepartureInspectionPalletEdge?: Maybe<PeruDepartureInspectionPalletsEdge>;
};


/** The output of our update `PeruDepartureInspectionPallet` mutation. */
export type UpdatePeruDepartureInspectionPalletPayloadPeruDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionPalletsOrderBy>>;
};

/** All input for the `updatePeruDepartureInspectionPalletByNodeId` mutation. */
export type UpdatePeruDepartureInspectionPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PeruDepartureInspectionPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PeruDepartureInspectionPallet` being updated. */
  patch: PeruDepartureInspectionPalletPatch;
};

/** All input for the `updatePeruDepartureInspectionPallet` mutation. */
export type UpdatePeruDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PeruDepartureInspectionPallet` being updated. */
  patch: PeruDepartureInspectionPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaApplePallet` mutation. */
export type UpdatePsaApplePalletPayload = {
  __typename?: 'UpdatePsaApplePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaApplePallet` that was updated by this mutation. */
  psaApplePallet?: Maybe<PsaApplePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaApplePallet`. May be used by Relay 1. */
  psaApplePalletEdge?: Maybe<PsaApplePalletsEdge>;
};


/** The output of our update `PsaApplePallet` mutation. */
export type UpdatePsaApplePalletPayloadPsaApplePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaApplePalletsOrderBy>>;
};

/** All input for the `updatePsaApplePalletByNodeId` mutation. */
export type UpdatePsaApplePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaApplePallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaApplePallet` being updated. */
  patch: PsaApplePalletPatch;
};

/** Represents an update to a `PsaApplePallet`. Fields that are set will be updated. */
export type PsaApplePalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  stemPuncturesPct?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  sunScaldPieces?: Maybe<Scalars['String']>;
  sunScaldPct?: Maybe<Scalars['String']>;
  sunScaldDeg?: Maybe<Scalars['String']>;
  scaldPieces?: Maybe<Scalars['String']>;
  scaldPct?: Maybe<Scalars['String']>;
  scaldDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  crackingPieces?: Maybe<Scalars['String']>;
  crackingPct?: Maybe<Scalars['String']>;
  bitterPitPieces?: Maybe<Scalars['String']>;
  bitterPitPct?: Maybe<Scalars['String']>;
  bitterPitDeg?: Maybe<Scalars['String']>;
  lenticelBreakdownPieces?: Maybe<Scalars['String']>;
  lenticelBreakdownPct?: Maybe<Scalars['String']>;
  lenticelBreakdownDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  watercorePieces?: Maybe<Scalars['String']>;
  watercorePct?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** All input for the `updatePsaApplePallet` mutation. */
export type UpdatePsaApplePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaApplePallet` being updated. */
  patch: PsaApplePalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaArrivalPicture` mutation. */
export type UpdatePsaArrivalPicturePayload = {
  __typename?: 'UpdatePsaArrivalPicturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalPicture` that was updated by this mutation. */
  psaArrivalPicture?: Maybe<PsaArrivalPicture>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalPicture`. May be used by Relay 1. */
  psaArrivalPictureEdge?: Maybe<PsaArrivalPicturesEdge>;
};


/** The output of our update `PsaArrivalPicture` mutation. */
export type UpdatePsaArrivalPicturePayloadPsaArrivalPictureEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalPicturesOrderBy>>;
};

/** All input for the `updatePsaArrivalPictureByNodeId` mutation. */
export type UpdatePsaArrivalPictureByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaArrivalPicture` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaArrivalPicture` being updated. */
  patch: PsaArrivalPicturePatch;
};

/** Represents an update to a `PsaArrivalPicture`. Fields that are set will be updated. */
export type PsaArrivalPicturePatch = {
  id?: Maybe<Scalars['BigInt']>;
  pictureDate?: Maybe<Scalars['Date']>;
  arrivalCode?: Maybe<Scalars['String']>;
  pictureDescription?: Maybe<Scalars['String']>;
  exporterId?: Maybe<Scalars['BigInt']>;
  palletId?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  varietyName?: Maybe<Scalars['String']>;
};

/** All input for the `updatePsaArrivalPicture` mutation. */
export type UpdatePsaArrivalPictureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaArrivalPicture` being updated. */
  patch: PsaArrivalPicturePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaArrivalReport` mutation. */
export type UpdatePsaArrivalReportPayload = {
  __typename?: 'UpdatePsaArrivalReportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalReport` that was updated by this mutation. */
  psaArrivalReport?: Maybe<PsaArrivalReport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalReport`. May be used by Relay 1. */
  psaArrivalReportEdge?: Maybe<PsaArrivalReportsEdge>;
};


/** The output of our update `PsaArrivalReport` mutation. */
export type UpdatePsaArrivalReportPayloadPsaArrivalReportEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalReportsOrderBy>>;
};

/** All input for the `updatePsaArrivalReportByNodeId` mutation. */
export type UpdatePsaArrivalReportByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaArrivalReport` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaArrivalReport` being updated. */
  patch: PsaArrivalReportPatch;
};

/** Represents an update to a `PsaArrivalReport`. Fields that are set will be updated. */
export type PsaArrivalReportPatch = {
  id?: Maybe<Scalars['BigInt']>;
  reportDate?: Maybe<Scalars['Date']>;
  locationName?: Maybe<Scalars['String']>;
  arrivalCode?: Maybe<Scalars['String']>;
  arrivalName?: Maybe<Scalars['String']>;
  exporterId?: Maybe<Scalars['BigInt']>;
  exporterName?: Maybe<Scalars['String']>;
};

/** All input for the `updatePsaArrivalReport` mutation. */
export type UpdatePsaArrivalReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaArrivalReport` being updated. */
  patch: PsaArrivalReportPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaCherryPallet` mutation. */
export type UpdatePsaCherryPalletPayload = {
  __typename?: 'UpdatePsaCherryPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCherryPallet` that was updated by this mutation. */
  psaCherryPallet?: Maybe<PsaCherryPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCherryPallet`. May be used by Relay 1. */
  psaCherryPalletEdge?: Maybe<PsaCherryPalletsEdge>;
};


/** The output of our update `PsaCherryPallet` mutation. */
export type UpdatePsaCherryPalletPayloadPsaCherryPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCherryPalletsOrderBy>>;
};

/** All input for the `updatePsaCherryPalletByNodeId` mutation. */
export type UpdatePsaCherryPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaCherryPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaCherryPallet` being updated. */
  patch: PsaCherryPalletPatch;
};

/** Represents an update to a `PsaCherryPallet`. Fields that are set will be updated. */
export type PsaCherryPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  sizeMin?: Maybe<Scalars['String']>;
  sizeMax?: Maybe<Scalars['String']>;
  sizeMost?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  scarsMarksPieces?: Maybe<Scalars['String']>;
  scarsMarksPct?: Maybe<Scalars['String']>;
  scarsMarksDeg?: Maybe<Scalars['String']>;
  misshapenPieces?: Maybe<Scalars['String']>;
  misshapenPct?: Maybe<Scalars['String']>;
  stemlessPieces?: Maybe<Scalars['String']>;
  stemlessPct?: Maybe<Scalars['String']>;
  splitsPieces?: Maybe<Scalars['String']>;
  splitsPct?: Maybe<Scalars['String']>;
  splitsDeg?: Maybe<Scalars['String']>;
  firmness?: Maybe<Scalars['String']>;
  pittingBruisingPieces?: Maybe<Scalars['String']>;
  pittingBruisingPct?: Maybe<Scalars['String']>;
  pittingBruisingDeg?: Maybe<Scalars['String']>;
  stemDehydrationPieces?: Maybe<Scalars['String']>;
  stemDehydrationPct?: Maybe<Scalars['String']>;
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** All input for the `updatePsaCherryPallet` mutation. */
export type UpdatePsaCherryPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaCherryPallet` being updated. */
  patch: PsaCherryPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaCitrusPallet` mutation. */
export type UpdatePsaCitrusPalletPayload = {
  __typename?: 'UpdatePsaCitrusPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCitrusPallet` that was updated by this mutation. */
  psaCitrusPallet?: Maybe<PsaCitrusPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCitrusPallet`. May be used by Relay 1. */
  psaCitrusPalletEdge?: Maybe<PsaCitrusPalletsEdge>;
};


/** The output of our update `PsaCitrusPallet` mutation. */
export type UpdatePsaCitrusPalletPayloadPsaCitrusPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCitrusPalletsOrderBy>>;
};

/** All input for the `updatePsaCitrusPalletByNodeId` mutation. */
export type UpdatePsaCitrusPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaCitrusPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaCitrusPallet` being updated. */
  patch: PsaCitrusPalletPatch;
};

/** Represents an update to a `PsaCitrusPallet`. Fields that are set will be updated. */
export type PsaCitrusPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  diameterMinMm?: Maybe<Scalars['String']>;
  diameterMinInches?: Maybe<Scalars['String']>;
  diameterMaxMm?: Maybe<Scalars['String']>;
  diameterMaxInches?: Maybe<Scalars['String']>;
  diameterMostMm?: Maybe<Scalars['String']>;
  diameterMostInches?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  greenHazePieces?: Maybe<Scalars['String']>;
  greenHazePct?: Maybe<Scalars['String']>;
  greenHazeDeg?: Maybe<Scalars['String']>;
  oilSpotsPieces?: Maybe<Scalars['String']>;
  oilSpotsPct?: Maybe<Scalars['String']>;
  oilSpotsDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  dryPulpPieces?: Maybe<Scalars['String']>;
  dryPulpPct?: Maybe<Scalars['String']>;
  dryPulpDeg?: Maybe<Scalars['String']>;
  seedsPieces?: Maybe<Scalars['String']>;
  seedsPct?: Maybe<Scalars['String']>;
  skinBreakdownPieces?: Maybe<Scalars['String']>;
  skinBreakdownPct?: Maybe<Scalars['String']>;
  skinBreakdownDeg?: Maybe<Scalars['String']>;
  creasingPieces?: Maybe<Scalars['String']>;
  creasingPct?: Maybe<Scalars['String']>;
  creasingDeg?: Maybe<Scalars['String']>;
  puffinessPieces?: Maybe<Scalars['String']>;
  puffinessPct?: Maybe<Scalars['String']>;
  puffinessDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  sporesPieces?: Maybe<Scalars['String']>;
  sporesPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** All input for the `updatePsaCitrusPallet` mutation. */
export type UpdatePsaCitrusPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaCitrusPallet` being updated. */
  patch: PsaCitrusPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaGrapePallet` mutation. */
export type UpdatePsaGrapePalletPayload = {
  __typename?: 'UpdatePsaGrapePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaGrapePallet` that was updated by this mutation. */
  psaGrapePallet?: Maybe<PsaGrapePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaGrapePallet`. May be used by Relay 1. */
  psaGrapePalletEdge?: Maybe<PsaGrapePalletsEdge>;
};


/** The output of our update `PsaGrapePallet` mutation. */
export type UpdatePsaGrapePalletPayloadPsaGrapePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaGrapePalletsOrderBy>>;
};

/** All input for the `updatePsaGrapePalletByNodeId` mutation. */
export type UpdatePsaGrapePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaGrapePallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaGrapePallet` being updated. */
  patch: PsaGrapePalletPatch;
};

/** Represents an update to a `PsaGrapePallet`. Fields that are set will be updated. */
export type PsaGrapePalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['Date']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  autoOpening?: Maybe<Scalars['String']>;
  bunches?: Maybe<Scalars['String']>;
  sizeMin?: Maybe<Scalars['String']>;
  sizeMax?: Maybe<Scalars['String']>;
  sizeMost?: Maybe<Scalars['String']>;
  undersizeBunchesCount?: Maybe<Scalars['String']>;
  autoUndersizeBerriesBunches?: Maybe<Scalars['String']>;
  undersizeBerriesPct?: Maybe<Scalars['String']>;
  colorMin?: Maybe<Scalars['String']>;
  colorMax?: Maybe<Scalars['String']>;
  colorMost?: Maybe<Scalars['String']>;
  colorConsistency?: Maybe<Scalars['String']>;
  autoColorConsistency?: Maybe<Scalars['String']>;
  sunburnBunches?: Maybe<Scalars['String']>;
  autoSunburnBunches?: Maybe<Scalars['String']>;
  sunburnPct?: Maybe<Scalars['String']>;
  sunburnBunchesDeg?: Maybe<Scalars['String']>;
  bunchConformation?: Maybe<Scalars['String']>;
  autoBunchConformation?: Maybe<Scalars['String']>;
  stragglyBunches?: Maybe<Scalars['String']>;
  stragglyPct?: Maybe<Scalars['String']>;
  smallBunches?: Maybe<Scalars['String']>;
  russetMarksBunches?: Maybe<Scalars['String']>;
  russetMarksPct?: Maybe<Scalars['String']>;
  autoRussetMarksPct?: Maybe<Scalars['String']>;
  dustPct?: Maybe<Scalars['String']>;
  autoDustPct?: Maybe<Scalars['String']>;
  residuesPct?: Maybe<Scalars['String']>;
  autoResiduesPct?: Maybe<Scalars['String']>;
  tightBunches?: Maybe<Scalars['String']>;
  autoTightBunches?: Maybe<Scalars['String']>;
  bruisingBunches?: Maybe<Scalars['String']>;
  autoBruisingBunches?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  stemDehydrationPct?: Maybe<Scalars['String']>;
  autoStemDehydrationPct?: Maybe<Scalars['String']>;
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  berryCondition?: Maybe<Scalars['String']>;
  autoBerryCondition?: Maybe<Scalars['String']>;
  h2OBerries?: Maybe<Scalars['String']>;
  autoH2OBerries?: Maybe<Scalars['String']>;
  so2DamagePct?: Maybe<Scalars['String']>;
  autoSo2DamagePct?: Maybe<Scalars['String']>;
  so2DamageDeg?: Maybe<Scalars['String']>;
  weakBunches?: Maybe<Scalars['String']>;
  autoWeakBunches?: Maybe<Scalars['String']>;
  splitsHairlinePct?: Maybe<Scalars['String']>;
  autoSplitsHairlinePct?: Maybe<Scalars['String']>;
  splitsWetCrushPct?: Maybe<Scalars['String']>;
  autoSplitsWetCrushPct?: Maybe<Scalars['String']>;
  splitsDryPct?: Maybe<Scalars['String']>;
  autoSplitsDryPct?: Maybe<Scalars['String']>;
  intDisc?: Maybe<Scalars['String']>;
  autoIntDisc?: Maybe<Scalars['String']>;
  intDiscDeg?: Maybe<Scalars['String']>;
  decayMoldBerries?: Maybe<Scalars['String']>;
  autoDecayMoldBerries?: Maybe<Scalars['String']>;
  decaySlipskinBerries?: Maybe<Scalars['String']>;
  autoDecaySlipskinBerries?: Maybe<Scalars['String']>;
  decayNestBerries?: Maybe<Scalars['String']>;
  autoDecayNestBerries?: Maybe<Scalars['String']>;
  decayNestDeg?: Maybe<Scalars['String']>;
  shatterPct?: Maybe<Scalars['String']>;
  autoShatterPct?: Maybe<Scalars['String']>;
  brixMin?: Maybe<Scalars['String']>;
  brixMax?: Maybe<Scalars['String']>;
  brixMost?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  autoOverallQuality?: Maybe<Scalars['String']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  autoOverallCondition?: Maybe<Scalars['String']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** All input for the `updatePsaGrapePallet` mutation. */
export type UpdatePsaGrapePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaGrapePallet` being updated. */
  patch: PsaGrapePalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaLemonPallet` mutation. */
export type UpdatePsaLemonPalletPayload = {
  __typename?: 'UpdatePsaLemonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaLemonPallet` that was updated by this mutation. */
  psaLemonPallet?: Maybe<PsaLemonPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaLemonPallet`. May be used by Relay 1. */
  psaLemonPalletEdge?: Maybe<PsaLemonPalletsEdge>;
};


/** The output of our update `PsaLemonPallet` mutation. */
export type UpdatePsaLemonPalletPayloadPsaLemonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaLemonPalletsOrderBy>>;
};

/** All input for the `updatePsaLemonPalletByNodeId` mutation. */
export type UpdatePsaLemonPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaLemonPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaLemonPallet` being updated. */
  patch: PsaLemonPalletPatch;
};

/** Represents an update to a `PsaLemonPallet`. Fields that are set will be updated. */
export type PsaLemonPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  diameterMinMm?: Maybe<Scalars['String']>;
  diameterMinInches?: Maybe<Scalars['String']>;
  diameterMaxMm?: Maybe<Scalars['String']>;
  diameterMaxInches?: Maybe<Scalars['String']>;
  diameterMostMm?: Maybe<Scalars['String']>;
  diameterMostInches?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  greenHazePieces?: Maybe<Scalars['String']>;
  greenHazePct?: Maybe<Scalars['String']>;
  greenHazeDeg?: Maybe<Scalars['String']>;
  oilSpotsPieces?: Maybe<Scalars['String']>;
  oilSpotsPct?: Maybe<Scalars['String']>;
  oilSpotsDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  dryPulpPieces?: Maybe<Scalars['String']>;
  dryPulpPct?: Maybe<Scalars['String']>;
  dryPulpDeg?: Maybe<Scalars['String']>;
  skinDamagePieces?: Maybe<Scalars['String']>;
  skinDamagePct?: Maybe<Scalars['String']>;
  skinDamageDeg?: Maybe<Scalars['String']>;
  petecaPieces?: Maybe<Scalars['String']>;
  petecaPct?: Maybe<Scalars['String']>;
  petecaDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  sporesPieces?: Maybe<Scalars['String']>;
  sporesPct?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** All input for the `updatePsaLemonPallet` mutation. */
export type UpdatePsaLemonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaLemonPallet` being updated. */
  patch: PsaLemonPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaPearPallet` mutation. */
export type UpdatePsaPearPalletPayload = {
  __typename?: 'UpdatePsaPearPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPearPallet` that was updated by this mutation. */
  psaPearPallet?: Maybe<PsaPearPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPearPallet`. May be used by Relay 1. */
  psaPearPalletEdge?: Maybe<PsaPearPalletsEdge>;
};


/** The output of our update `PsaPearPallet` mutation. */
export type UpdatePsaPearPalletPayloadPsaPearPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPearPalletsOrderBy>>;
};

/** All input for the `updatePsaPearPalletByNodeId` mutation. */
export type UpdatePsaPearPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaPearPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaPearPallet` being updated. */
  patch: PsaPearPalletPatch;
};

/** Represents an update to a `PsaPearPallet`. Fields that are set will be updated. */
export type PsaPearPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsRussetPieces?: Maybe<Scalars['String']>;
  scarsRussetPct?: Maybe<Scalars['String']>;
  scarsRussetDeg?: Maybe<Scalars['String']>;
  russetPerPiecePct?: Maybe<Scalars['String']>;
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  stemPuncturesPct?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  turningColorPieces?: Maybe<Scalars['String']>;
  turningColorPct?: Maybe<Scalars['String']>;
  turningColorDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** All input for the `updatePsaPearPallet` mutation. */
export type UpdatePsaPearPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaPearPallet` being updated. */
  patch: PsaPearPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaPersimmonPallet` mutation. */
export type UpdatePsaPersimmonPalletPayload = {
  __typename?: 'UpdatePsaPersimmonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPersimmonPallet` that was updated by this mutation. */
  psaPersimmonPallet?: Maybe<PsaPersimmonPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPersimmonPallet`. May be used by Relay 1. */
  psaPersimmonPalletEdge?: Maybe<PsaPersimmonPalletsEdge>;
};


/** The output of our update `PsaPersimmonPallet` mutation. */
export type UpdatePsaPersimmonPalletPayloadPsaPersimmonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPersimmonPalletsOrderBy>>;
};

/** All input for the `updatePsaPersimmonPalletByNodeId` mutation. */
export type UpdatePsaPersimmonPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaPersimmonPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaPersimmonPallet` being updated. */
  patch: PsaPersimmonPalletPatch;
};

/** Represents an update to a `PsaPersimmonPallet`. Fields that are set will be updated. */
export type PsaPersimmonPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  scarsMarksPieces?: Maybe<Scalars['String']>;
  scarsMarksPct?: Maybe<Scalars['String']>;
  scarsMarksDeg?: Maybe<Scalars['String']>;
  greenColorPieces?: Maybe<Scalars['String']>;
  greenColor?: Maybe<Scalars['String']>;
  greenColorDeg?: Maybe<Scalars['String']>;
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  cutsSplitsPct?: Maybe<Scalars['String']>;
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  seedsPieces?: Maybe<Scalars['String']>;
  seedsPct?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  internalDamageDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** All input for the `updatePsaPersimmonPallet` mutation. */
export type UpdatePsaPersimmonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaPersimmonPallet` being updated. */
  patch: PsaPersimmonPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaPomegranatePallet` mutation. */
export type UpdatePsaPomegranatePalletPayload = {
  __typename?: 'UpdatePsaPomegranatePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPomegranatePallet` that was updated by this mutation. */
  psaPomegranatePallet?: Maybe<PsaPomegranatePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPomegranatePallet`. May be used by Relay 1. */
  psaPomegranatePalletEdge?: Maybe<PsaPomegranatePalletsEdge>;
};


/** The output of our update `PsaPomegranatePallet` mutation. */
export type UpdatePsaPomegranatePalletPayloadPsaPomegranatePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPomegranatePalletsOrderBy>>;
};

/** All input for the `updatePsaPomegranatePalletByNodeId` mutation. */
export type UpdatePsaPomegranatePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaPomegranatePallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaPomegranatePallet` being updated. */
  patch: PsaPomegranatePalletPatch;
};

/** Represents an update to a `PsaPomegranatePallet`. Fields that are set will be updated. */
export type PsaPomegranatePalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  arilsColor?: Maybe<Scalars['String']>;
  scarsRussetPieces?: Maybe<Scalars['String']>;
  scarsRussetPct?: Maybe<Scalars['String']>;
  scarsRussetDeg?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  sunScaldPieces?: Maybe<Scalars['String']>;
  sunScaldPct?: Maybe<Scalars['String']>;
  sunScaldDeg?: Maybe<Scalars['String']>;
  scaldPieces?: Maybe<Scalars['String']>;
  scaldPct?: Maybe<Scalars['String']>;
  scaldDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brixMin?: Maybe<Scalars['String']>;
  brixMax?: Maybe<Scalars['String']>;
  brixMost?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** All input for the `updatePsaPomegranatePallet` mutation. */
export type UpdatePsaPomegranatePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaPomegranatePallet` being updated. */
  patch: PsaPomegranatePalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaStoneFruitPallet` mutation. */
export type UpdatePsaStoneFruitPalletPayload = {
  __typename?: 'UpdatePsaStoneFruitPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaStoneFruitPallet` that was updated by this mutation. */
  psaStoneFruitPallet?: Maybe<PsaStoneFruitPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaStoneFruitPallet`. May be used by Relay 1. */
  psaStoneFruitPalletEdge?: Maybe<PsaStoneFruitPalletsEdge>;
};


/** The output of our update `PsaStoneFruitPallet` mutation. */
export type UpdatePsaStoneFruitPalletPayloadPsaStoneFruitPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaStoneFruitPalletsOrderBy>>;
};

/** All input for the `updatePsaStoneFruitPalletByNodeId` mutation. */
export type UpdatePsaStoneFruitPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaStoneFruitPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaStoneFruitPallet` being updated. */
  patch: PsaStoneFruitPalletPatch;
};

/** Represents an update to a `PsaStoneFruitPallet`. Fields that are set will be updated. */
export type PsaStoneFruitPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  ripening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  cutsSplitsPct?: Maybe<Scalars['String']>;
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  splitPitPieces?: Maybe<Scalars['String']>;
  splitPitPct?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  softTipsPieces?: Maybe<Scalars['String']>;
  softTipsPct?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  mealinessPieces?: Maybe<Scalars['String']>;
  mealinessPct?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** All input for the `updatePsaStoneFruitPallet` mutation. */
export type UpdatePsaStoneFruitPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaStoneFruitPallet` being updated. */
  patch: PsaStoneFruitPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `AgendaItem` mutation. */
export type UpdateAgendaItemPayload = {
  __typename?: 'UpdateAgendaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgendaItem` that was updated by this mutation. */
  agendaItem?: Maybe<AgendaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `AgendaItem`. May be used by Relay 1. */
  agendaItemEdge?: Maybe<AgendaItemsEdge>;
};


/** The output of our update `AgendaItem` mutation. */
export type UpdateAgendaItemPayloadAgendaItemEdgeArgs = {
  orderBy?: Maybe<Array<AgendaItemsOrderBy>>;
};

/** All input for the `updateAgendaItemByNodeId` mutation. */
export type UpdateAgendaItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AgendaItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `AgendaItem` being updated. */
  patch: AgendaItemPatch;
};

/** Represents an update to a `AgendaItem`. Fields that are set will be updated. */
export type AgendaItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  content?: Maybe<Scalars['String']>;
  itemDate?: Maybe<Scalars['Date']>;
  sortOrder?: Maybe<Scalars['Int']>;
};

/** All input for the `updateAgendaItem` mutation. */
export type UpdateAgendaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `AgendaItem` being updated. */
  patch: AgendaItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CalendarEvent` mutation. */
export type UpdateCalendarEventPayload = {
  __typename?: 'UpdateCalendarEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CalendarEvent` that was updated by this mutation. */
  calendarEvent?: Maybe<CalendarEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CalendarEvent`. May be used by Relay 1. */
  calendarEventEdge?: Maybe<CalendarEventsEdge>;
};


/** The output of our update `CalendarEvent` mutation. */
export type UpdateCalendarEventPayloadCalendarEventEdgeArgs = {
  orderBy?: Maybe<Array<CalendarEventsOrderBy>>;
};

/** All input for the `updateCalendarEventByNodeId` mutation. */
export type UpdateCalendarEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CalendarEvent` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CalendarEvent` being updated. */
  patch: CalendarEventPatch;
};

/** Represents an update to a `CalendarEvent`. Fields that are set will be updated. */
export type CalendarEventPatch = {
  id?: Maybe<Scalars['BigInt']>;
  title?: Maybe<Scalars['String']>;
  eventDescription?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['Datetime']>;
  endDate?: Maybe<Scalars['Datetime']>;
  allDay?: Maybe<Scalars['Boolean']>;
  rrule?: Maybe<Scalars['String']>;
};

/** All input for the `updateCalendarEvent` mutation. */
export type UpdateCalendarEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CalendarEvent` being updated. */
  patch: CalendarEventPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PriceCategory` mutation. */
export type UpdatePriceCategoryPayload = {
  __typename?: 'UpdatePriceCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceCategory` that was updated by this mutation. */
  priceCategory?: Maybe<PriceCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PriceCategory`. May be used by Relay 1. */
  priceCategoryEdge?: Maybe<PriceCategoriesEdge>;
};


/** The output of our update `PriceCategory` mutation. */
export type UpdatePriceCategoryPayloadPriceCategoryEdgeArgs = {
  orderBy?: Maybe<Array<PriceCategoriesOrderBy>>;
};

/** All input for the `updatePriceCategoryByNodeId` mutation. */
export type UpdatePriceCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceCategory` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PriceCategory` being updated. */
  patch: PriceCategoryPatch;
};

/** All input for the `updatePriceCategory` mutation. */
export type UpdatePriceCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PriceCategory` being updated. */
  patch: PriceCategoryPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PriceEntry` mutation. */
export type UpdatePriceEntryPayload = {
  __typename?: 'UpdatePriceEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceEntry` that was updated by this mutation. */
  priceEntry?: Maybe<PriceEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceSize` that is related to this `PriceEntry`. */
  size?: Maybe<PriceSize>;
  /** An edge for our `PriceEntry`. May be used by Relay 1. */
  priceEntryEdge?: Maybe<PriceEntriesEdge>;
};


/** The output of our update `PriceEntry` mutation. */
export type UpdatePriceEntryPayloadPriceEntryEdgeArgs = {
  orderBy?: Maybe<Array<PriceEntriesOrderBy>>;
};

/** All input for the `updatePriceEntryByNodeId` mutation. */
export type UpdatePriceEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceEntry` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PriceEntry` being updated. */
  patch: PriceEntryPatch;
};

/** All input for the `updatePriceEntry` mutation. */
export type UpdatePriceEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PriceEntry` being updated. */
  patch: PriceEntryPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PriceProduct` mutation. */
export type UpdatePriceProductPayload = {
  __typename?: 'UpdatePriceProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceProduct` that was updated by this mutation. */
  priceProduct?: Maybe<PriceProduct>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceCategory` that is related to this `PriceProduct`. */
  category?: Maybe<PriceCategory>;
  /** An edge for our `PriceProduct`. May be used by Relay 1. */
  priceProductEdge?: Maybe<PriceProductsEdge>;
};


/** The output of our update `PriceProduct` mutation. */
export type UpdatePriceProductPayloadPriceProductEdgeArgs = {
  orderBy?: Maybe<Array<PriceProductsOrderBy>>;
};

/** All input for the `updatePriceProductByNodeId` mutation. */
export type UpdatePriceProductByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceProduct` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PriceProduct` being updated. */
  patch: PriceProductPatch;
};

/** All input for the `updatePriceProduct` mutation. */
export type UpdatePriceProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PriceProduct` being updated. */
  patch: PriceProductPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PriceSize` mutation. */
export type UpdatePriceSizePayload = {
  __typename?: 'UpdatePriceSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceSize` that was updated by this mutation. */
  priceSize?: Maybe<PriceSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceProduct` that is related to this `PriceSize`. */
  product?: Maybe<PriceProduct>;
  /** An edge for our `PriceSize`. May be used by Relay 1. */
  priceSizeEdge?: Maybe<PriceSizesEdge>;
};


/** The output of our update `PriceSize` mutation. */
export type UpdatePriceSizePayloadPriceSizeEdgeArgs = {
  orderBy?: Maybe<Array<PriceSizesOrderBy>>;
};

/** All input for the `updatePriceSizeByNodeId` mutation. */
export type UpdatePriceSizeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceSize` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PriceSize` being updated. */
  patch: PriceSizePatch;
};

/** All input for the `updatePriceSize` mutation. */
export type UpdatePriceSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PriceSize` being updated. */
  patch: PriceSizePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `InventoryItem` mutation. */
export type UpdateInventoryItemPayload = {
  __typename?: 'UpdateInventoryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InventoryItem` that was updated by this mutation. */
  inventoryItem?: Maybe<InventoryItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InventoryItem`. May be used by Relay 1. */
  inventoryItemEdge?: Maybe<InventoryItemsEdge>;
};


/** The output of our update `InventoryItem` mutation. */
export type UpdateInventoryItemPayloadInventoryItemEdgeArgs = {
  orderBy?: Maybe<Array<InventoryItemsOrderBy>>;
};

/** All input for the `updateInventoryItemByNodeId` mutation. */
export type UpdateInventoryItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `InventoryItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `InventoryItem` being updated. */
  patch: InventoryItemPatch;
};

/** Represents an update to a `InventoryItem`. Fields that are set will be updated. */
export type InventoryItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['String']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  palletsReceived?: Maybe<Scalars['BigFloat']>;
  palletsCommitted?: Maybe<Scalars['BigFloat']>;
  palletsOnHand?: Maybe<Scalars['BigFloat']>;
  palletsAvailable?: Maybe<Scalars['BigFloat']>;
  palletsShipped?: Maybe<Scalars['BigFloat']>;
  palletsTransferredIn?: Maybe<Scalars['BigFloat']>;
  palletsTransferredOut?: Maybe<Scalars['BigFloat']>;
  plu?: Maybe<Scalars['Boolean']>;
  countryId?: Maybe<Scalars['String']>;
  specialLotNumber?: Maybe<Scalars['String']>;
  coast?: Maybe<Scalars['String']>;
  storageRank?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
};

/** All input for the `updateInventoryItem` mutation. */
export type UpdateInventoryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `InventoryItem` being updated. */
  patch: InventoryItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackAtmosphere` mutation. */
export type UpdatePackAtmospherePayload = {
  __typename?: 'UpdatePackAtmospherePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackAtmosphere` that was updated by this mutation. */
  packAtmosphere?: Maybe<PackAtmosphere>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackAtmosphere`. May be used by Relay 1. */
  packAtmosphereEdge?: Maybe<PackAtmospheresEdge>;
};


/** The output of our update `PackAtmosphere` mutation. */
export type UpdatePackAtmospherePayloadPackAtmosphereEdgeArgs = {
  orderBy?: Maybe<Array<PackAtmospheresOrderBy>>;
};

/** All input for the `updatePackAtmosphereByNodeId` mutation. */
export type UpdatePackAtmosphereByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackAtmosphere` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackAtmosphere` being updated. */
  patch: PackAtmospherePatch;
};

/** Represents an update to a `PackAtmosphere`. Fields that are set will be updated. */
export type PackAtmospherePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  maCode?: Maybe<Scalars['String']>;
  maDescription?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackAtmosphere` mutation. */
export type UpdatePackAtmosphereInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackAtmosphere` being updated. */
  patch: PackAtmospherePatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackAtmosphereByShipperIdAndMaCode` mutation. */
export type UpdatePackAtmosphereByShipperIdAndMaCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackAtmosphere` being updated. */
  patch: PackAtmospherePatch;
  shipperId: Scalars['String'];
  maCode: Scalars['String'];
};

/** The output of our update `PackBoxStyle` mutation. */
export type UpdatePackBoxStylePayload = {
  __typename?: 'UpdatePackBoxStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxStyle` that was updated by this mutation. */
  packBoxStyle?: Maybe<PackBoxStyle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxStyle`. May be used by Relay 1. */
  packBoxStyleEdge?: Maybe<PackBoxStylesEdge>;
};


/** The output of our update `PackBoxStyle` mutation. */
export type UpdatePackBoxStylePayloadPackBoxStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxStylesOrderBy>>;
};

/** All input for the `updatePackBoxStyleByNodeId` mutation. */
export type UpdatePackBoxStyleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackBoxStyle` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackBoxStyle` being updated. */
  patch: PackBoxStylePatch;
};

/** Represents an update to a `PackBoxStyle`. Fields that are set will be updated. */
export type PackBoxStylePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  boxStyle?: Maybe<Scalars['String']>;
  boxDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackBoxStyle` mutation. */
export type UpdatePackBoxStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackBoxStyle` being updated. */
  patch: PackBoxStylePatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackBoxStyleByShipperIdAndBoxStyle` mutation. */
export type UpdatePackBoxStyleByShipperIdAndBoxStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackBoxStyle` being updated. */
  patch: PackBoxStylePatch;
  shipperId: Scalars['String'];
  boxStyle: Scalars['String'];
};

/** The output of our update `PackBoxType` mutation. */
export type UpdatePackBoxTypePayload = {
  __typename?: 'UpdatePackBoxTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxType` that was updated by this mutation. */
  packBoxType?: Maybe<PackBoxType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxType`. May be used by Relay 1. */
  packBoxTypeEdge?: Maybe<PackBoxTypesEdge>;
};


/** The output of our update `PackBoxType` mutation. */
export type UpdatePackBoxTypePayloadPackBoxTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxTypesOrderBy>>;
};

/** All input for the `updatePackBoxTypeByNodeId` mutation. */
export type UpdatePackBoxTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackBoxType` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackBoxType` being updated. */
  patch: PackBoxTypePatch;
};

/** Represents an update to a `PackBoxType`. Fields that are set will be updated. */
export type PackBoxTypePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  boxType?: Maybe<Scalars['String']>;
  boxDescription?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackBoxType` mutation. */
export type UpdatePackBoxTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackBoxType` being updated. */
  patch: PackBoxTypePatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackBoxTypeByShipperIdAndBoxType` mutation. */
export type UpdatePackBoxTypeByShipperIdAndBoxTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackBoxType` being updated. */
  patch: PackBoxTypePatch;
  shipperId: Scalars['String'];
  boxType: Scalars['String'];
};

/** The output of our update `PackDestination` mutation. */
export type UpdatePackDestinationPayload = {
  __typename?: 'UpdatePackDestinationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackDestination` that was updated by this mutation. */
  packDestination?: Maybe<PackDestination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackDestination`. May be used by Relay 1. */
  packDestinationEdge?: Maybe<PackDestinationsEdge>;
};


/** The output of our update `PackDestination` mutation. */
export type UpdatePackDestinationPayloadPackDestinationEdgeArgs = {
  orderBy?: Maybe<Array<PackDestinationsOrderBy>>;
};

/** All input for the `updatePackDestinationByNodeId` mutation. */
export type UpdatePackDestinationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackDestination` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackDestination` being updated. */
  patch: PackDestinationPatch;
};

/** Represents an update to a `PackDestination`. Fields that are set will be updated. */
export type PackDestinationPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  destinationCode?: Maybe<Scalars['String']>;
  destinationDescription?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackDestination` mutation. */
export type UpdatePackDestinationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackDestination` being updated. */
  patch: PackDestinationPatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackDestinationByShipperIdAndDestinationCode` mutation. */
export type UpdatePackDestinationByShipperIdAndDestinationCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackDestination` being updated. */
  patch: PackDestinationPatch;
  shipperId: Scalars['String'];
  destinationCode: Scalars['String'];
};

/** The output of our update `PackGrade` mutation. */
export type UpdatePackGradePayload = {
  __typename?: 'UpdatePackGradePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackGrade` that was updated by this mutation. */
  packGrade?: Maybe<PackGrade>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackGrade`. May be used by Relay 1. */
  packGradeEdge?: Maybe<PackGradesEdge>;
};


/** The output of our update `PackGrade` mutation. */
export type UpdatePackGradePayloadPackGradeEdgeArgs = {
  orderBy?: Maybe<Array<PackGradesOrderBy>>;
};

/** All input for the `updatePackGradeByNodeId` mutation. */
export type UpdatePackGradeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackGrade` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackGrade` being updated. */
  patch: PackGradePatch;
};

/** Represents an update to a `PackGrade`. Fields that are set will be updated. */
export type PackGradePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  gradeCode?: Maybe<Scalars['String']>;
  gradeDescription?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackGrade` mutation. */
export type UpdatePackGradeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackGrade` being updated. */
  patch: PackGradePatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackGradeByShipperIdAndGradeCode` mutation. */
export type UpdatePackGradeByShipperIdAndGradeCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackGrade` being updated. */
  patch: PackGradePatch;
  shipperId: Scalars['String'];
  gradeCode: Scalars['String'];
};

/** The output of our update `PackHold` mutation. */
export type UpdatePackHoldPayload = {
  __typename?: 'UpdatePackHoldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackHold` that was updated by this mutation. */
  packHold?: Maybe<PackHold>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackHold`. May be used by Relay 1. */
  packHoldEdge?: Maybe<PackHoldsEdge>;
};


/** The output of our update `PackHold` mutation. */
export type UpdatePackHoldPayloadPackHoldEdgeArgs = {
  orderBy?: Maybe<Array<PackHoldsOrderBy>>;
};

/** All input for the `updatePackHoldByNodeId` mutation. */
export type UpdatePackHoldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackHold` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackHold` being updated. */
  patch: PackHoldPatch;
};

/** Represents an update to a `PackHold`. Fields that are set will be updated. */
export type PackHoldPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  holdCode?: Maybe<Scalars['String']>;
  holdDescription?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackHold` mutation. */
export type UpdatePackHoldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackHold` being updated. */
  patch: PackHoldPatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackHoldByShipperIdAndHoldCode` mutation. */
export type UpdatePackHoldByShipperIdAndHoldCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackHold` being updated. */
  patch: PackHoldPatch;
  shipperId: Scalars['String'];
  holdCode: Scalars['String'];
};

/** The output of our update `PackLabel` mutation. */
export type UpdatePackLabelPayload = {
  __typename?: 'UpdatePackLabelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLabel` that was updated by this mutation. */
  packLabel?: Maybe<PackLabel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLabel`. May be used by Relay 1. */
  packLabelEdge?: Maybe<PackLabelsEdge>;
};


/** The output of our update `PackLabel` mutation. */
export type UpdatePackLabelPayloadPackLabelEdgeArgs = {
  orderBy?: Maybe<Array<PackLabelsOrderBy>>;
};

/** All input for the `updatePackLabelByNodeId` mutation. */
export type UpdatePackLabelByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackLabel` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackLabel` being updated. */
  patch: PackLabelPatch;
};

/** Represents an update to a `PackLabel`. Fields that are set will be updated. */
export type PackLabelPatch = {
  id?: Maybe<Scalars['BigInt']>;
  labelCode?: Maybe<Scalars['String']>;
  labelName?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackLabel` mutation. */
export type UpdatePackLabelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackLabel` being updated. */
  patch: PackLabelPatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackLabelByShipperIdAndLabelCode` mutation. */
export type UpdatePackLabelByShipperIdAndLabelCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackLabel` being updated. */
  patch: PackLabelPatch;
  shipperId: Scalars['String'];
  labelCode: Scalars['String'];
};

/** The output of our update `PackLiner` mutation. */
export type UpdatePackLinerPayload = {
  __typename?: 'UpdatePackLinerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLiner` that was updated by this mutation. */
  packLiner?: Maybe<PackLiner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLiner`. May be used by Relay 1. */
  packLinerEdge?: Maybe<PackLinersEdge>;
};


/** The output of our update `PackLiner` mutation. */
export type UpdatePackLinerPayloadPackLinerEdgeArgs = {
  orderBy?: Maybe<Array<PackLinersOrderBy>>;
};

/** All input for the `updatePackLinerByNodeId` mutation. */
export type UpdatePackLinerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackLiner` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackLiner` being updated. */
  patch: PackLinerPatch;
};

/** Represents an update to a `PackLiner`. Fields that are set will be updated. */
export type PackLinerPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  linerCode?: Maybe<Scalars['String']>;
  linerDescription?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackLiner` mutation. */
export type UpdatePackLinerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackLiner` being updated. */
  patch: PackLinerPatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackLinerByShipperIdAndLinerCode` mutation. */
export type UpdatePackLinerByShipperIdAndLinerCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackLiner` being updated. */
  patch: PackLinerPatch;
  shipperId: Scalars['String'];
  linerCode: Scalars['String'];
};

/** The output of our update `PackMaster` mutation. */
export type UpdatePackMasterPayload = {
  __typename?: 'UpdatePackMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackMaster` that was updated by this mutation. */
  packMaster?: Maybe<PackMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackMaster`. May be used by Relay 1. */
  packMasterEdge?: Maybe<PackMastersEdge>;
};


/** The output of our update `PackMaster` mutation. */
export type UpdatePackMasterPayloadPackMasterEdgeArgs = {
  orderBy?: Maybe<Array<PackMastersOrderBy>>;
};

/** All input for the `updatePackMasterByNodeId` mutation. */
export type UpdatePackMasterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackMaster` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackMaster` being updated. */
  patch: PackMasterPatch;
};

/** Represents an update to a `PackMaster`. Fields that are set will be updated. */
export type PackMasterPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  labelCodeId?: Maybe<Scalars['String']>;
  customerCodeId?: Maybe<Scalars['String']>;
  boxTypeId?: Maybe<Scalars['String']>;
  boxStyleId?: Maybe<Scalars['String']>;
  packStyleId?: Maybe<Scalars['String']>;
  outCodeId?: Maybe<Scalars['String']>;
  outQuantity?: Maybe<Scalars['String']>;
  outWeight?: Maybe<Scalars['String']>;
  productionCodeId?: Maybe<Scalars['String']>;
  treeRipeId?: Maybe<Scalars['String']>;
  gradeCodeId?: Maybe<Scalars['String']>;
  maCodeId?: Maybe<Scalars['String']>;
  linerCodeId?: Maybe<Scalars['String']>;
  netWeightContents?: Maybe<Scalars['BigFloat']>;
  netWeightBox?: Maybe<Scalars['BigFloat']>;
  boxLength?: Maybe<Scalars['BigFloat']>;
  boxWidth?: Maybe<Scalars['BigFloat']>;
  boxHeight?: Maybe<Scalars['BigFloat']>;
  palletTypeId?: Maybe<Scalars['String']>;
  defaultPalletQuantity?: Maybe<Scalars['BigFloat']>;
  pluUpcCode?: Maybe<Scalars['String']>;
  destinationCodeId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  oldLabelCode?: Maybe<Scalars['String']>;
  jvPackCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  speciesId?: Maybe<Scalars['String']>;
  holdCodeId?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackMaster` mutation. */
export type UpdatePackMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackMaster` being updated. */
  patch: PackMasterPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackOut` mutation. */
export type UpdatePackOutPayload = {
  __typename?: 'UpdatePackOutPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackOut` that was updated by this mutation. */
  packOut?: Maybe<PackOut>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackOut`. May be used by Relay 1. */
  packOutEdge?: Maybe<PackOutsEdge>;
};


/** The output of our update `PackOut` mutation. */
export type UpdatePackOutPayloadPackOutEdgeArgs = {
  orderBy?: Maybe<Array<PackOutsOrderBy>>;
};

/** All input for the `updatePackOutByNodeId` mutation. */
export type UpdatePackOutByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackOut` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackOut` being updated. */
  patch: PackOutPatch;
};

/** Represents an update to a `PackOut`. Fields that are set will be updated. */
export type PackOutPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  outCode?: Maybe<Scalars['String']>;
  outDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackOut` mutation. */
export type UpdatePackOutInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackOut` being updated. */
  patch: PackOutPatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackOutByShipperIdAndOutCode` mutation. */
export type UpdatePackOutByShipperIdAndOutCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackOut` being updated. */
  patch: PackOutPatch;
  shipperId: Scalars['String'];
  outCode: Scalars['String'];
};

/** The output of our update `PackPalletType` mutation. */
export type UpdatePackPalletTypePayload = {
  __typename?: 'UpdatePackPalletTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackPalletType` that was updated by this mutation. */
  packPalletType?: Maybe<PackPalletType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackPalletType`. May be used by Relay 1. */
  packPalletTypeEdge?: Maybe<PackPalletTypesEdge>;
};


/** The output of our update `PackPalletType` mutation. */
export type UpdatePackPalletTypePayloadPackPalletTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackPalletTypesOrderBy>>;
};

/** All input for the `updatePackPalletTypeByNodeId` mutation. */
export type UpdatePackPalletTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackPalletType` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackPalletType` being updated. */
  patch: PackPalletTypePatch;
};

/** Represents an update to a `PackPalletType`. Fields that are set will be updated. */
export type PackPalletTypePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  palletType?: Maybe<Scalars['String']>;
  palletTypeDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackPalletType` mutation. */
export type UpdatePackPalletTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackPalletType` being updated. */
  patch: PackPalletTypePatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackPalletTypeByShipperIdAndPalletType` mutation. */
export type UpdatePackPalletTypeByShipperIdAndPalletTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackPalletType` being updated. */
  patch: PackPalletTypePatch;
  shipperId: Scalars['String'];
  palletType: Scalars['String'];
};

/** The output of our update `PackProduction` mutation. */
export type UpdatePackProductionPayload = {
  __typename?: 'UpdatePackProductionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackProduction` that was updated by this mutation. */
  packProduction?: Maybe<PackProduction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackProduction`. May be used by Relay 1. */
  packProductionEdge?: Maybe<PackProductionsEdge>;
};


/** The output of our update `PackProduction` mutation. */
export type UpdatePackProductionPayloadPackProductionEdgeArgs = {
  orderBy?: Maybe<Array<PackProductionsOrderBy>>;
};

/** All input for the `updatePackProductionByNodeId` mutation. */
export type UpdatePackProductionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackProduction` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackProduction` being updated. */
  patch: PackProductionPatch;
};

/** Represents an update to a `PackProduction`. Fields that are set will be updated. */
export type PackProductionPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  productionCode?: Maybe<Scalars['String']>;
  productionDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackProduction` mutation. */
export type UpdatePackProductionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackProduction` being updated. */
  patch: PackProductionPatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackProductionByShipperIdAndProductionCode` mutation. */
export type UpdatePackProductionByShipperIdAndProductionCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackProduction` being updated. */
  patch: PackProductionPatch;
  shipperId: Scalars['String'];
  productionCode: Scalars['String'];
};

/** The output of our update `PackSpecial` mutation. */
export type UpdatePackSpecialPayload = {
  __typename?: 'UpdatePackSpecialPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackSpecial` that was updated by this mutation. */
  packSpecial?: Maybe<PackSpecial>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackSpecial`. May be used by Relay 1. */
  packSpecialEdge?: Maybe<PackSpecialsEdge>;
};


/** The output of our update `PackSpecial` mutation. */
export type UpdatePackSpecialPayloadPackSpecialEdgeArgs = {
  orderBy?: Maybe<Array<PackSpecialsOrderBy>>;
};

/** All input for the `updatePackSpecialByNodeId` mutation. */
export type UpdatePackSpecialByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackSpecial` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackSpecial` being updated. */
  patch: PackSpecialPatch;
};

/** Represents an update to a `PackSpecial`. Fields that are set will be updated. */
export type PackSpecialPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  customerCode?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackSpecial` mutation. */
export type UpdatePackSpecialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackSpecial` being updated. */
  patch: PackSpecialPatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackSpecialByShipperIdAndCustomerCode` mutation. */
export type UpdatePackSpecialByShipperIdAndCustomerCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackSpecial` being updated. */
  patch: PackSpecialPatch;
  shipperId: Scalars['String'];
  customerCode: Scalars['String'];
};

/** The output of our update `PackStyle` mutation. */
export type UpdatePackStylePayload = {
  __typename?: 'UpdatePackStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackStyle` that was updated by this mutation. */
  packStyle?: Maybe<PackStyle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackStyle`. May be used by Relay 1. */
  packStyleEdge?: Maybe<PackStylesEdge>;
};


/** The output of our update `PackStyle` mutation. */
export type UpdatePackStylePayloadPackStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackStylesOrderBy>>;
};

/** All input for the `updatePackStyleByNodeId` mutation. */
export type UpdatePackStyleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackStyle` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackStyle` being updated. */
  patch: PackStylePatch;
};

/** Represents an update to a `PackStyle`. Fields that are set will be updated. */
export type PackStylePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  packStyle?: Maybe<Scalars['String']>;
  styleDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackStyle` mutation. */
export type UpdatePackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackStyle` being updated. */
  patch: PackStylePatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackStyleByShipperIdAndPackStyle` mutation. */
export type UpdatePackStyleByShipperIdAndPackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackStyle` being updated. */
  patch: PackStylePatch;
  shipperId: Scalars['String'];
  packStyle: Scalars['String'];
};

/** The output of our update `PackTreeRipe` mutation. */
export type UpdatePackTreeRipePayload = {
  __typename?: 'UpdatePackTreeRipePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackTreeRipe` that was updated by this mutation. */
  packTreeRipe?: Maybe<PackTreeRipe>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackTreeRipe`. May be used by Relay 1. */
  packTreeRipeEdge?: Maybe<PackTreeRipesEdge>;
};


/** The output of our update `PackTreeRipe` mutation. */
export type UpdatePackTreeRipePayloadPackTreeRipeEdgeArgs = {
  orderBy?: Maybe<Array<PackTreeRipesOrderBy>>;
};

/** All input for the `updatePackTreeRipeByNodeId` mutation. */
export type UpdatePackTreeRipeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackTreeRipe` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackTreeRipe` being updated. */
  patch: PackTreeRipePatch;
};

/** Represents an update to a `PackTreeRipe`. Fields that are set will be updated. */
export type PackTreeRipePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  treeRipe?: Maybe<Scalars['String']>;
  treeRipeDescription?: Maybe<Scalars['String']>;
};

/** All input for the `updatePackTreeRipe` mutation. */
export type UpdatePackTreeRipeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackTreeRipe` being updated. */
  patch: PackTreeRipePatch;
  id: Scalars['BigInt'];
};

/** All input for the `updatePackTreeRipeByShipperIdAndTreeRipe` mutation. */
export type UpdatePackTreeRipeByShipperIdAndTreeRipeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackTreeRipe` being updated. */
  patch: PackTreeRipePatch;
  shipperId: Scalars['String'];
  treeRipe: Scalars['String'];
};

/** The output of our update `PalletSection` mutation. */
export type UpdatePalletSectionPayload = {
  __typename?: 'UpdatePalletSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletSection` that was updated by this mutation. */
  palletSection?: Maybe<PalletSection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PalletSection`. May be used by Relay 1. */
  palletSectionEdge?: Maybe<PalletSectionsEdge>;
};


/** The output of our update `PalletSection` mutation. */
export type UpdatePalletSectionPayloadPalletSectionEdgeArgs = {
  orderBy?: Maybe<Array<PalletSectionsOrderBy>>;
};

/** All input for the `updatePalletSectionByNodeId` mutation. */
export type UpdatePalletSectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PalletSection` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PalletSection` being updated. */
  patch: PalletSectionPatch;
};

/** Represents an update to a `PalletSection`. Fields that are set will be updated. */
export type PalletSectionPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletId?: Maybe<Scalars['String']>;
  growerId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  sizeId?: Maybe<Scalars['String']>;
  boxQuantity?: Maybe<Scalars['BigFloat']>;
  packDate?: Maybe<Scalars['String']>;
};

/** All input for the `updatePalletSection` mutation. */
export type UpdatePalletSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PalletSection` being updated. */
  patch: PalletSectionPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PalletTempOne` mutation. */
export type UpdatePalletTempOnePayload = {
  __typename?: 'UpdatePalletTempOnePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletTempOne` that was updated by this mutation. */
  palletTempOne?: Maybe<PalletTempOne>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PalletTempOne`. May be used by Relay 1. */
  palletTempOneEdge?: Maybe<PalletTempOnesEdge>;
};


/** The output of our update `PalletTempOne` mutation. */
export type UpdatePalletTempOnePayloadPalletTempOneEdgeArgs = {
  orderBy?: Maybe<Array<PalletTempOnesOrderBy>>;
};

/** All input for the `updatePalletTempOneByNodeId` mutation. */
export type UpdatePalletTempOneByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PalletTempOne` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PalletTempOne` being updated. */
  patch: PalletTempOnePatch;
};

/** Represents an update to a `PalletTempOne`. Fields that are set will be updated. */
export type PalletTempOnePatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  productId?: Maybe<Scalars['String']>;
  currentBoxQuantity?: Maybe<Scalars['BigFloat']>;
  receivedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  returnedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  room?: Maybe<Scalars['String']>;
  section?: Maybe<Scalars['String']>;
  row?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  dateTransferredToStorage?: Maybe<Scalars['Date']>;
  orderId?: Maybe<Scalars['String']>;
  backOrderId?: Maybe<Scalars['String']>;
  shipped?: Maybe<Scalars['Boolean']>;
  age?: Maybe<Scalars['BigFloat']>;
  volumeDiscountCode?: Maybe<Scalars['String']>;
  originalLocationId?: Maybe<Scalars['String']>;
};

/** All input for the `updatePalletTempOne` mutation. */
export type UpdatePalletTempOneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PalletTempOne` being updated. */
  patch: PalletTempOnePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PalletTempTwo` mutation. */
export type UpdatePalletTempTwoPayload = {
  __typename?: 'UpdatePalletTempTwoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletTempTwo` that was updated by this mutation. */
  palletTempTwo?: Maybe<PalletTempTwo>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PalletTempTwo`. May be used by Relay 1. */
  palletTempTwoEdge?: Maybe<PalletTempTwosEdge>;
};


/** The output of our update `PalletTempTwo` mutation. */
export type UpdatePalletTempTwoPayloadPalletTempTwoEdgeArgs = {
  orderBy?: Maybe<Array<PalletTempTwosOrderBy>>;
};

/** All input for the `updatePalletTempTwoByNodeId` mutation. */
export type UpdatePalletTempTwoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PalletTempTwo` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PalletTempTwo` being updated. */
  patch: PalletTempTwoPatch;
};

/** Represents an update to a `PalletTempTwo`. Fields that are set will be updated. */
export type PalletTempTwoPatch = {
  id?: Maybe<Scalars['BigInt']>;
  filler?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  billOfLading?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  temperatureRecording?: Maybe<Scalars['String']>;
};

/** All input for the `updatePalletTempTwo` mutation. */
export type UpdatePalletTempTwoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PalletTempTwo` being updated. */
  patch: PalletTempTwoPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ProductMaster` mutation. */
export type UpdateProductMasterPayload = {
  __typename?: 'UpdateProductMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductMaster` that was updated by this mutation. */
  productMaster?: Maybe<ProductMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductMaster`. May be used by Relay 1. */
  productMasterEdge?: Maybe<ProductMastersEdge>;
};


/** The output of our update `ProductMaster` mutation. */
export type UpdateProductMasterPayloadProductMasterEdgeArgs = {
  orderBy?: Maybe<Array<ProductMastersOrderBy>>;
};

/** All input for the `updateProductMasterByNodeId` mutation. */
export type UpdateProductMasterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductMaster` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ProductMaster` being updated. */
  patch: ProductMasterPatch;
};

/** Represents an update to a `ProductMaster`. Fields that are set will be updated. */
export type ProductMasterPatch = {
  id?: Maybe<Scalars['String']>;
  defaultPalletQuantity?: Maybe<Scalars['String']>;
  lotNumber?: Maybe<Scalars['String']>;
};

/** All input for the `updateProductMaster` mutation. */
export type UpdateProductMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ProductMaster` being updated. */
  patch: ProductMasterPatch;
  id: Scalars['String'];
};

/** The output of our update `ProductSize` mutation. */
export type UpdateProductSizePayload = {
  __typename?: 'UpdateProductSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSize` that was updated by this mutation. */
  productSize?: Maybe<ProductSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSize`. May be used by Relay 1. */
  productSizeEdge?: Maybe<ProductSizesEdge>;
};


/** The output of our update `ProductSize` mutation. */
export type UpdateProductSizePayloadProductSizeEdgeArgs = {
  orderBy?: Maybe<Array<ProductSizesOrderBy>>;
};

/** All input for the `updateProductSizeByNodeId` mutation. */
export type UpdateProductSizeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductSize` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ProductSize` being updated. */
  patch: ProductSizePatch;
};

/** Represents an update to a `ProductSize`. Fields that are set will be updated. */
export type ProductSizePatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  jvCode?: Maybe<Scalars['String']>;
  jvDescription?: Maybe<Scalars['String']>;
  shipperCode?: Maybe<Scalars['String']>;
  shipperDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
};

/** All input for the `updateProductSize` mutation. */
export type UpdateProductSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ProductSize` being updated. */
  patch: ProductSizePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ProductSpecies` mutation. */
export type UpdateProductSpeciesPayload = {
  __typename?: 'UpdateProductSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSpecies` that was updated by this mutation. */
  productSpecies?: Maybe<ProductSpecies>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSpecies`. May be used by Relay 1. */
  productSpeciesEdge?: Maybe<ProductSpeciesEdge>;
};


/** The output of our update `ProductSpecies` mutation. */
export type UpdateProductSpeciesPayloadProductSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<ProductSpeciesOrderBy>>;
};

/** All input for the `updateProductSpeciesByNodeId` mutation. */
export type UpdateProductSpeciesByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductSpecies` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ProductSpecies` being updated. */
  patch: ProductSpeciesPatch;
};

/** Represents an update to a `ProductSpecies`. Fields that are set will be updated. */
export type ProductSpeciesPatch = {
  id?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  fdaProductCode?: Maybe<Scalars['String']>;
  fdaIndustryCode?: Maybe<Scalars['String']>;
  defaultTemperature?: Maybe<Scalars['String']>;
};

/** All input for the `updateProductSpecies` mutation. */
export type UpdateProductSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ProductSpecies` being updated. */
  patch: ProductSpeciesPatch;
  id: Scalars['String'];
};

/** The output of our update `ProductVariety` mutation. */
export type UpdateProductVarietyPayload = {
  __typename?: 'UpdateProductVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductVariety` that was updated by this mutation. */
  productVariety?: Maybe<ProductVariety>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductVariety`. May be used by Relay 1. */
  productVarietyEdge?: Maybe<ProductVarietiesEdge>;
};


/** The output of our update `ProductVariety` mutation. */
export type UpdateProductVarietyPayloadProductVarietyEdgeArgs = {
  orderBy?: Maybe<Array<ProductVarietiesOrderBy>>;
};

/** All input for the `updateProductVarietyByNodeId` mutation. */
export type UpdateProductVarietyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductVariety` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ProductVariety` being updated. */
  patch: ProductVarietyPatch;
};

/** Represents an update to a `ProductVariety`. Fields that are set will be updated. */
export type ProductVarietyPatch = {
  id?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  customerLetterSequence?: Maybe<Scalars['String']>;
  summaryCode?: Maybe<Scalars['String']>;
  varietyGroup?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** All input for the `updateProductVariety` mutation. */
export type UpdateProductVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ProductVariety` being updated. */
  patch: ProductVarietyPatch;
  id: Scalars['String'];
};

/** The output of our update `ShipperProjection` mutation. */
export type UpdateShipperProjectionPayload = {
  __typename?: 'UpdateShipperProjectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjection` that was updated by this mutation. */
  shipperProjection?: Maybe<ShipperProjection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjection`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjection`. May be used by Relay 1. */
  shipperProjectionEdge?: Maybe<ShipperProjectionsEdge>;
};


/** The output of our update `ShipperProjection` mutation. */
export type UpdateShipperProjectionPayloadShipperProjectionEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
};

/** All input for the `updateShipperProjectionByNodeId` mutation. */
export type UpdateShipperProjectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjection` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperProjection` being updated. */
  patch: ShipperProjectionPatch;
};

/** All input for the `updateShipperProjection` mutation. */
export type UpdateShipperProjectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperProjection` being updated. */
  patch: ShipperProjectionPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ShipperProjectionEntry` mutation. */
export type UpdateShipperProjectionEntryPayload = {
  __typename?: 'UpdateShipperProjectionEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionEntry` that was updated by this mutation. */
  shipperProjectionEntry?: Maybe<ShipperProjectionEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProjectionVessel` that is related to this `ShipperProjectionEntry`. */
  vessel?: Maybe<ShipperProjectionVessel>;
  /** Reads a single `ShipperProjectionProduct` that is related to this `ShipperProjectionEntry`. */
  product?: Maybe<ShipperProjectionProduct>;
  /** Reads a single `ShipperProjection` that is related to this `ShipperProjectionEntry`. */
  shipperProjection?: Maybe<ShipperProjection>;
  /** An edge for our `ShipperProjectionEntry`. May be used by Relay 1. */
  shipperProjectionEntryEdge?: Maybe<ShipperProjectionEntriesEdge>;
};


/** The output of our update `ShipperProjectionEntry` mutation. */
export type UpdateShipperProjectionEntryPayloadShipperProjectionEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
};

/** All input for the `updateShipperProjectionEntryByNodeId` mutation. */
export type UpdateShipperProjectionEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionEntry` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperProjectionEntry` being updated. */
  patch: ShipperProjectionEntryPatch;
};

/** All input for the `updateShipperProjectionEntry` mutation. */
export type UpdateShipperProjectionEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperProjectionEntry` being updated. */
  patch: ShipperProjectionEntryPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ShipperProjectionProduct` mutation. */
export type UpdateShipperProjectionProductPayload = {
  __typename?: 'UpdateShipperProjectionProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionProduct` that was updated by this mutation. */
  shipperProjectionProduct?: Maybe<ShipperProjectionProduct>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionProduct`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjectionProduct`. May be used by Relay 1. */
  shipperProjectionProductEdge?: Maybe<ShipperProjectionProductsEdge>;
};


/** The output of our update `ShipperProjectionProduct` mutation. */
export type UpdateShipperProjectionProductPayloadShipperProjectionProductEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
};

/** All input for the `updateShipperProjectionProductByNodeId` mutation. */
export type UpdateShipperProjectionProductByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionProduct` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperProjectionProduct` being updated. */
  patch: ShipperProjectionProductPatch;
};

/** All input for the `updateShipperProjectionProduct` mutation. */
export type UpdateShipperProjectionProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperProjectionProduct` being updated. */
  patch: ShipperProjectionProductPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ShipperProjectionVessel` mutation. */
export type UpdateShipperProjectionVesselPayload = {
  __typename?: 'UpdateShipperProjectionVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVessel` that was updated by this mutation. */
  shipperProjectionVessel?: Maybe<ShipperProjectionVessel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVessel`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjectionVessel`. May be used by Relay 1. */
  shipperProjectionVesselEdge?: Maybe<ShipperProjectionVesselsEdge>;
};


/** The output of our update `ShipperProjectionVessel` mutation. */
export type UpdateShipperProjectionVesselPayloadShipperProjectionVesselEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
};

/** All input for the `updateShipperProjectionVesselByNodeId` mutation. */
export type UpdateShipperProjectionVesselByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionVessel` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperProjectionVessel` being updated. */
  patch: ShipperProjectionVesselPatch;
};

/** All input for the `updateShipperProjectionVessel` mutation. */
export type UpdateShipperProjectionVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperProjectionVessel` being updated. */
  patch: ShipperProjectionVesselPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Vessel` mutation. */
export type UpdateVesselPayload = {
  __typename?: 'UpdateVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vessel` that was updated by this mutation. */
  vessel?: Maybe<Vessel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vessel`. May be used by Relay 1. */
  vesselEdge?: Maybe<VesselsEdge>;
};


/** The output of our update `Vessel` mutation. */
export type UpdateVesselPayloadVesselEdgeArgs = {
  orderBy?: Maybe<Array<VesselsOrderBy>>;
};

/** All input for the `updateVesselByNodeId` mutation. */
export type UpdateVesselByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Vessel` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Vessel` being updated. */
  patch: VesselPatch;
};

/** Represents an update to a `Vessel`. Fields that are set will be updated. */
export type VesselPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode?: Maybe<Scalars['String']>;
  vesselName?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  dischargeDate?: Maybe<Scalars['Date']>;
  coast?: Maybe<Scalars['String']>;
};

/** All input for the `updateVessel` mutation. */
export type UpdateVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Vessel` being updated. */
  patch: VesselPatch;
  id: Scalars['BigInt'];
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>;
  deletedUserNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PersonContact` that is related to this `User`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteUserByNodeId` mutation. */
export type DeleteUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deleteUserByPin` mutation. */
export type DeleteUserByPinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  pin: Scalars['String'];
};

/** The output of our delete `UserMessage` mutation. */
export type DeleteUserMessagePayload = {
  __typename?: 'DeleteUserMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserMessage` that was deleted by this mutation. */
  userMessage?: Maybe<UserMessage>;
  deletedUserMessageNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserMessage`. */
  user?: Maybe<User>;
  /** An edge for our `UserMessage`. May be used by Relay 1. */
  userMessageEdge?: Maybe<UserMessagesEdge>;
};


/** The output of our delete `UserMessage` mutation. */
export type DeleteUserMessagePayloadUserMessageEdgeArgs = {
  orderBy?: Maybe<Array<UserMessagesOrderBy>>;
};

/** All input for the `deleteUserMessageByNodeId` mutation. */
export type DeleteUserMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserMessage` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserMessage` mutation. */
export type DeleteUserMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ContactGroup` mutation. */
export type DeleteContactGroupPayload = {
  __typename?: 'DeleteContactGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroup` that was deleted by this mutation. */
  contactGroup?: Maybe<ContactGroup>;
  deletedContactGroupNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ContactGroup`. */
  user?: Maybe<User>;
  /** An edge for our `ContactGroup`. May be used by Relay 1. */
  contactGroupEdge?: Maybe<ContactGroupsEdge>;
};


/** The output of our delete `ContactGroup` mutation. */
export type DeleteContactGroupPayloadContactGroupEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupsOrderBy>>;
};

/** All input for the `deleteContactGroupByNodeId` mutation. */
export type DeleteContactGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContactGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteContactGroup` mutation. */
export type DeleteContactGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ContactGroupPersonContact` mutation. */
export type DeleteContactGroupPersonContactPayload = {
  __typename?: 'DeleteContactGroupPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroupPersonContact` that was deleted by this mutation. */
  contactGroupPersonContact?: Maybe<ContactGroupPersonContact>;
  deletedContactGroupPersonContactNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ContactGroup` that is related to this `ContactGroupPersonContact`. */
  group?: Maybe<ContactGroup>;
  /** Reads a single `PersonContact` that is related to this `ContactGroupPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ContactGroupPersonContact`. May be used by Relay 1. */
  contactGroupPersonContactEdge?: Maybe<ContactGroupPersonContactsEdge>;
};


/** The output of our delete `ContactGroupPersonContact` mutation. */
export type DeleteContactGroupPersonContactPayloadContactGroupPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupPersonContactsOrderBy>>;
};

/** All input for the `deleteContactGroupPersonContactByNodeId` mutation. */
export type DeleteContactGroupPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContactGroupPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteContactGroupPersonContact` mutation. */
export type DeleteContactGroupPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};

/** The output of our delete `Country` mutation. */
export type DeleteCountryPayload = {
  __typename?: 'DeleteCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was deleted by this mutation. */
  country?: Maybe<Country>;
  deletedCountryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our delete `Country` mutation. */
export type DeleteCountryPayloadCountryEdgeArgs = {
  orderBy?: Maybe<Array<CountriesOrderBy>>;
};

/** All input for the `deleteCountryByNodeId` mutation. */
export type DeleteCountryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Country` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCountry` mutation. */
export type DeleteCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `Customer` mutation. */
export type DeleteCustomerPayload = {
  __typename?: 'DeleteCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was deleted by this mutation. */
  customer?: Maybe<Customer>;
  deletedCustomerNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Customer`. */
  country?: Maybe<Country>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our delete `Customer` mutation. */
export type DeleteCustomerPayloadCustomerEdgeArgs = {
  orderBy?: Maybe<Array<CustomersOrderBy>>;
};

/** All input for the `deleteCustomerByNodeId` mutation. */
export type DeleteCustomerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomer` mutation. */
export type DeleteCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `CustomerPersonContact` mutation. */
export type DeleteCustomerPersonContactPayload = {
  __typename?: 'DeleteCustomerPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPersonContact` that was deleted by this mutation. */
  customerPersonContact?: Maybe<CustomerPersonContact>;
  deletedCustomerPersonContactNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `CustomerPersonContact`. */
  customer?: Maybe<Customer>;
  /** Reads a single `PersonContact` that is related to this `CustomerPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `CustomerPersonContact`. May be used by Relay 1. */
  customerPersonContactEdge?: Maybe<CustomerPersonContactsEdge>;
};


/** The output of our delete `CustomerPersonContact` mutation. */
export type DeleteCustomerPersonContactPayloadCustomerPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<CustomerPersonContactsOrderBy>>;
};

/** All input for the `deleteCustomerPersonContactByNodeId` mutation. */
export type DeleteCustomerPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomerPersonContact` mutation. */
export type DeleteCustomerPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our delete `PersonContact` mutation. */
export type DeletePersonContactPayload = {
  __typename?: 'DeletePersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PersonContact` that was deleted by this mutation. */
  personContact?: Maybe<PersonContact>;
  deletedPersonContactNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PersonContact`. May be used by Relay 1. */
  personContactEdge?: Maybe<PersonContactsEdge>;
};


/** The output of our delete `PersonContact` mutation. */
export type DeletePersonContactPayloadPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
};

/** All input for the `deletePersonContactByNodeId` mutation. */
export type DeletePersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePersonContact` mutation. */
export type DeletePersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Shipper` mutation. */
export type DeleteShipperPayload = {
  __typename?: 'DeleteShipperPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipper` that was deleted by this mutation. */
  shipper?: Maybe<Shipper>;
  deletedShipperNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Shipper`. */
  country?: Maybe<Country>;
  /** An edge for our `Shipper`. May be used by Relay 1. */
  shipperEdge?: Maybe<ShippersEdge>;
};


/** The output of our delete `Shipper` mutation. */
export type DeleteShipperPayloadShipperEdgeArgs = {
  orderBy?: Maybe<Array<ShippersOrderBy>>;
};

/** All input for the `deleteShipperByNodeId` mutation. */
export type DeleteShipperByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Shipper` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipper` mutation. */
export type DeleteShipperInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `ShipperPersonContact` mutation. */
export type DeleteShipperPersonContactPayload = {
  __typename?: 'DeleteShipperPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperPersonContact` that was deleted by this mutation. */
  shipperPersonContact?: Maybe<ShipperPersonContact>;
  deletedShipperPersonContactNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperPersonContact`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `PersonContact` that is related to this `ShipperPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ShipperPersonContact`. May be used by Relay 1. */
  shipperPersonContactEdge?: Maybe<ShipperPersonContactsEdge>;
};


/** The output of our delete `ShipperPersonContact` mutation. */
export type DeleteShipperPersonContactPayloadShipperPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ShipperPersonContactsOrderBy>>;
};

/** All input for the `deleteShipperPersonContactByNodeId` mutation. */
export type DeleteShipperPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperPersonContact` mutation. */
export type DeleteShipperPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our delete `Warehouse` mutation. */
export type DeleteWarehousePayload = {
  __typename?: 'DeleteWarehousePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` that was deleted by this mutation. */
  warehouse?: Maybe<Warehouse>;
  deletedWarehouseNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Warehouse`. */
  country?: Maybe<Country>;
  /** An edge for our `Warehouse`. May be used by Relay 1. */
  warehouseEdge?: Maybe<WarehousesEdge>;
};


/** The output of our delete `Warehouse` mutation. */
export type DeleteWarehousePayloadWarehouseEdgeArgs = {
  orderBy?: Maybe<Array<WarehousesOrderBy>>;
};

/** All input for the `deleteWarehouseByNodeId` mutation. */
export type DeleteWarehouseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Warehouse` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWarehouse` mutation. */
export type DeleteWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `WarehousePersonContact` mutation. */
export type DeleteWarehousePersonContactPayload = {
  __typename?: 'DeleteWarehousePersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WarehousePersonContact` that was deleted by this mutation. */
  warehousePersonContact?: Maybe<WarehousePersonContact>;
  deletedWarehousePersonContactNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Warehouse` that is related to this `WarehousePersonContact`. */
  warehouse?: Maybe<Warehouse>;
  /** Reads a single `PersonContact` that is related to this `WarehousePersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `WarehousePersonContact`. May be used by Relay 1. */
  warehousePersonContactEdge?: Maybe<WarehousePersonContactsEdge>;
};


/** The output of our delete `WarehousePersonContact` mutation. */
export type DeleteWarehousePersonContactPayloadWarehousePersonContactEdgeArgs = {
  orderBy?: Maybe<Array<WarehousePersonContactsOrderBy>>;
};

/** All input for the `deleteWarehousePersonContactByNodeId` mutation. */
export type DeleteWarehousePersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WarehousePersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWarehousePersonContact` mutation. */
export type DeleteWarehousePersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our delete `ChileDepartureInspectionPallet` mutation. */
export type DeleteChileDepartureInspectionPalletPayload = {
  __typename?: 'DeleteChileDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ChileDepartureInspectionPallet` that was deleted by this mutation. */
  chileDepartureInspectionPallet?: Maybe<ChileDepartureInspectionPallet>;
  deletedChileDepartureInspectionPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ChileDepartureInspectionPallet`. May be used by Relay 1. */
  chileDepartureInspectionPalletEdge?: Maybe<ChileDepartureInspectionPalletsEdge>;
};


/** The output of our delete `ChileDepartureInspectionPallet` mutation. */
export type DeleteChileDepartureInspectionPalletPayloadChileDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<ChileDepartureInspectionPalletsOrderBy>>;
};

/** All input for the `deleteChileDepartureInspectionPalletByNodeId` mutation. */
export type DeleteChileDepartureInspectionPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ChileDepartureInspectionPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteChileDepartureInspectionPallet` mutation. */
export type DeleteChileDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `PeruDepartureInspection` mutation. */
export type DeletePeruDepartureInspectionPayload = {
  __typename?: 'DeletePeruDepartureInspectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspection` that was deleted by this mutation. */
  peruDepartureInspection?: Maybe<PeruDepartureInspection>;
  deletedPeruDepartureInspectionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PeruDepartureInspection`. May be used by Relay 1. */
  peruDepartureInspectionEdge?: Maybe<PeruDepartureInspectionsEdge>;
};


/** The output of our delete `PeruDepartureInspection` mutation. */
export type DeletePeruDepartureInspectionPayloadPeruDepartureInspectionEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionsOrderBy>>;
};

/** All input for the `deletePeruDepartureInspectionByNodeId` mutation. */
export type DeletePeruDepartureInspectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PeruDepartureInspection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePeruDepartureInspection` mutation. */
export type DeletePeruDepartureInspectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  containerId: Scalars['String'];
};

/** The output of our delete `PeruDepartureInspectionPallet` mutation. */
export type DeletePeruDepartureInspectionPalletPayload = {
  __typename?: 'DeletePeruDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspectionPallet` that was deleted by this mutation. */
  peruDepartureInspectionPallet?: Maybe<PeruDepartureInspectionPallet>;
  deletedPeruDepartureInspectionPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PeruDepartureInspection` that is related to this `PeruDepartureInspectionPallet`. */
  container?: Maybe<PeruDepartureInspection>;
  /** An edge for our `PeruDepartureInspectionPallet`. May be used by Relay 1. */
  peruDepartureInspectionPalletEdge?: Maybe<PeruDepartureInspectionPalletsEdge>;
};


/** The output of our delete `PeruDepartureInspectionPallet` mutation. */
export type DeletePeruDepartureInspectionPalletPayloadPeruDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionPalletsOrderBy>>;
};

/** All input for the `deletePeruDepartureInspectionPalletByNodeId` mutation. */
export type DeletePeruDepartureInspectionPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PeruDepartureInspectionPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePeruDepartureInspectionPallet` mutation. */
export type DeletePeruDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaApplePallet` mutation. */
export type DeletePsaApplePalletPayload = {
  __typename?: 'DeletePsaApplePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaApplePallet` that was deleted by this mutation. */
  psaApplePallet?: Maybe<PsaApplePallet>;
  deletedPsaApplePalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaApplePallet`. May be used by Relay 1. */
  psaApplePalletEdge?: Maybe<PsaApplePalletsEdge>;
};


/** The output of our delete `PsaApplePallet` mutation. */
export type DeletePsaApplePalletPayloadPsaApplePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaApplePalletsOrderBy>>;
};

/** All input for the `deletePsaApplePalletByNodeId` mutation. */
export type DeletePsaApplePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaApplePallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaApplePallet` mutation. */
export type DeletePsaApplePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaArrivalPicture` mutation. */
export type DeletePsaArrivalPicturePayload = {
  __typename?: 'DeletePsaArrivalPicturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalPicture` that was deleted by this mutation. */
  psaArrivalPicture?: Maybe<PsaArrivalPicture>;
  deletedPsaArrivalPictureNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalPicture`. May be used by Relay 1. */
  psaArrivalPictureEdge?: Maybe<PsaArrivalPicturesEdge>;
};


/** The output of our delete `PsaArrivalPicture` mutation. */
export type DeletePsaArrivalPicturePayloadPsaArrivalPictureEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalPicturesOrderBy>>;
};

/** All input for the `deletePsaArrivalPictureByNodeId` mutation. */
export type DeletePsaArrivalPictureByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaArrivalPicture` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaArrivalPicture` mutation. */
export type DeletePsaArrivalPictureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaArrivalReport` mutation. */
export type DeletePsaArrivalReportPayload = {
  __typename?: 'DeletePsaArrivalReportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalReport` that was deleted by this mutation. */
  psaArrivalReport?: Maybe<PsaArrivalReport>;
  deletedPsaArrivalReportNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalReport`. May be used by Relay 1. */
  psaArrivalReportEdge?: Maybe<PsaArrivalReportsEdge>;
};


/** The output of our delete `PsaArrivalReport` mutation. */
export type DeletePsaArrivalReportPayloadPsaArrivalReportEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalReportsOrderBy>>;
};

/** All input for the `deletePsaArrivalReportByNodeId` mutation. */
export type DeletePsaArrivalReportByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaArrivalReport` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaArrivalReport` mutation. */
export type DeletePsaArrivalReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaCherryPallet` mutation. */
export type DeletePsaCherryPalletPayload = {
  __typename?: 'DeletePsaCherryPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCherryPallet` that was deleted by this mutation. */
  psaCherryPallet?: Maybe<PsaCherryPallet>;
  deletedPsaCherryPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCherryPallet`. May be used by Relay 1. */
  psaCherryPalletEdge?: Maybe<PsaCherryPalletsEdge>;
};


/** The output of our delete `PsaCherryPallet` mutation. */
export type DeletePsaCherryPalletPayloadPsaCherryPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCherryPalletsOrderBy>>;
};

/** All input for the `deletePsaCherryPalletByNodeId` mutation. */
export type DeletePsaCherryPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaCherryPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaCherryPallet` mutation. */
export type DeletePsaCherryPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaCitrusPallet` mutation. */
export type DeletePsaCitrusPalletPayload = {
  __typename?: 'DeletePsaCitrusPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCitrusPallet` that was deleted by this mutation. */
  psaCitrusPallet?: Maybe<PsaCitrusPallet>;
  deletedPsaCitrusPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCitrusPallet`. May be used by Relay 1. */
  psaCitrusPalletEdge?: Maybe<PsaCitrusPalletsEdge>;
};


/** The output of our delete `PsaCitrusPallet` mutation. */
export type DeletePsaCitrusPalletPayloadPsaCitrusPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCitrusPalletsOrderBy>>;
};

/** All input for the `deletePsaCitrusPalletByNodeId` mutation. */
export type DeletePsaCitrusPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaCitrusPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaCitrusPallet` mutation. */
export type DeletePsaCitrusPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaGrapePallet` mutation. */
export type DeletePsaGrapePalletPayload = {
  __typename?: 'DeletePsaGrapePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaGrapePallet` that was deleted by this mutation. */
  psaGrapePallet?: Maybe<PsaGrapePallet>;
  deletedPsaGrapePalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaGrapePallet`. May be used by Relay 1. */
  psaGrapePalletEdge?: Maybe<PsaGrapePalletsEdge>;
};


/** The output of our delete `PsaGrapePallet` mutation. */
export type DeletePsaGrapePalletPayloadPsaGrapePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaGrapePalletsOrderBy>>;
};

/** All input for the `deletePsaGrapePalletByNodeId` mutation. */
export type DeletePsaGrapePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaGrapePallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaGrapePallet` mutation. */
export type DeletePsaGrapePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaLemonPallet` mutation. */
export type DeletePsaLemonPalletPayload = {
  __typename?: 'DeletePsaLemonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaLemonPallet` that was deleted by this mutation. */
  psaLemonPallet?: Maybe<PsaLemonPallet>;
  deletedPsaLemonPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaLemonPallet`. May be used by Relay 1. */
  psaLemonPalletEdge?: Maybe<PsaLemonPalletsEdge>;
};


/** The output of our delete `PsaLemonPallet` mutation. */
export type DeletePsaLemonPalletPayloadPsaLemonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaLemonPalletsOrderBy>>;
};

/** All input for the `deletePsaLemonPalletByNodeId` mutation. */
export type DeletePsaLemonPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaLemonPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaLemonPallet` mutation. */
export type DeletePsaLemonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaPearPallet` mutation. */
export type DeletePsaPearPalletPayload = {
  __typename?: 'DeletePsaPearPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPearPallet` that was deleted by this mutation. */
  psaPearPallet?: Maybe<PsaPearPallet>;
  deletedPsaPearPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPearPallet`. May be used by Relay 1. */
  psaPearPalletEdge?: Maybe<PsaPearPalletsEdge>;
};


/** The output of our delete `PsaPearPallet` mutation. */
export type DeletePsaPearPalletPayloadPsaPearPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPearPalletsOrderBy>>;
};

/** All input for the `deletePsaPearPalletByNodeId` mutation. */
export type DeletePsaPearPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaPearPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaPearPallet` mutation. */
export type DeletePsaPearPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaPersimmonPallet` mutation. */
export type DeletePsaPersimmonPalletPayload = {
  __typename?: 'DeletePsaPersimmonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPersimmonPallet` that was deleted by this mutation. */
  psaPersimmonPallet?: Maybe<PsaPersimmonPallet>;
  deletedPsaPersimmonPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPersimmonPallet`. May be used by Relay 1. */
  psaPersimmonPalletEdge?: Maybe<PsaPersimmonPalletsEdge>;
};


/** The output of our delete `PsaPersimmonPallet` mutation. */
export type DeletePsaPersimmonPalletPayloadPsaPersimmonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPersimmonPalletsOrderBy>>;
};

/** All input for the `deletePsaPersimmonPalletByNodeId` mutation. */
export type DeletePsaPersimmonPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaPersimmonPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaPersimmonPallet` mutation. */
export type DeletePsaPersimmonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaPomegranatePallet` mutation. */
export type DeletePsaPomegranatePalletPayload = {
  __typename?: 'DeletePsaPomegranatePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPomegranatePallet` that was deleted by this mutation. */
  psaPomegranatePallet?: Maybe<PsaPomegranatePallet>;
  deletedPsaPomegranatePalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPomegranatePallet`. May be used by Relay 1. */
  psaPomegranatePalletEdge?: Maybe<PsaPomegranatePalletsEdge>;
};


/** The output of our delete `PsaPomegranatePallet` mutation. */
export type DeletePsaPomegranatePalletPayloadPsaPomegranatePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPomegranatePalletsOrderBy>>;
};

/** All input for the `deletePsaPomegranatePalletByNodeId` mutation. */
export type DeletePsaPomegranatePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaPomegranatePallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaPomegranatePallet` mutation. */
export type DeletePsaPomegranatePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaStoneFruitPallet` mutation. */
export type DeletePsaStoneFruitPalletPayload = {
  __typename?: 'DeletePsaStoneFruitPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaStoneFruitPallet` that was deleted by this mutation. */
  psaStoneFruitPallet?: Maybe<PsaStoneFruitPallet>;
  deletedPsaStoneFruitPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaStoneFruitPallet`. May be used by Relay 1. */
  psaStoneFruitPalletEdge?: Maybe<PsaStoneFruitPalletsEdge>;
};


/** The output of our delete `PsaStoneFruitPallet` mutation. */
export type DeletePsaStoneFruitPalletPayloadPsaStoneFruitPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaStoneFruitPalletsOrderBy>>;
};

/** All input for the `deletePsaStoneFruitPalletByNodeId` mutation. */
export type DeletePsaStoneFruitPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaStoneFruitPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaStoneFruitPallet` mutation. */
export type DeletePsaStoneFruitPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `AgendaItem` mutation. */
export type DeleteAgendaItemPayload = {
  __typename?: 'DeleteAgendaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgendaItem` that was deleted by this mutation. */
  agendaItem?: Maybe<AgendaItem>;
  deletedAgendaItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `AgendaItem`. May be used by Relay 1. */
  agendaItemEdge?: Maybe<AgendaItemsEdge>;
};


/** The output of our delete `AgendaItem` mutation. */
export type DeleteAgendaItemPayloadAgendaItemEdgeArgs = {
  orderBy?: Maybe<Array<AgendaItemsOrderBy>>;
};

/** All input for the `deleteAgendaItemByNodeId` mutation. */
export type DeleteAgendaItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AgendaItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAgendaItem` mutation. */
export type DeleteAgendaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CalendarEvent` mutation. */
export type DeleteCalendarEventPayload = {
  __typename?: 'DeleteCalendarEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CalendarEvent` that was deleted by this mutation. */
  calendarEvent?: Maybe<CalendarEvent>;
  deletedCalendarEventNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CalendarEvent`. May be used by Relay 1. */
  calendarEventEdge?: Maybe<CalendarEventsEdge>;
};


/** The output of our delete `CalendarEvent` mutation. */
export type DeleteCalendarEventPayloadCalendarEventEdgeArgs = {
  orderBy?: Maybe<Array<CalendarEventsOrderBy>>;
};

/** All input for the `deleteCalendarEventByNodeId` mutation. */
export type DeleteCalendarEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CalendarEvent` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCalendarEvent` mutation. */
export type DeleteCalendarEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PriceCategory` mutation. */
export type DeletePriceCategoryPayload = {
  __typename?: 'DeletePriceCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceCategory` that was deleted by this mutation. */
  priceCategory?: Maybe<PriceCategory>;
  deletedPriceCategoryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PriceCategory`. May be used by Relay 1. */
  priceCategoryEdge?: Maybe<PriceCategoriesEdge>;
};


/** The output of our delete `PriceCategory` mutation. */
export type DeletePriceCategoryPayloadPriceCategoryEdgeArgs = {
  orderBy?: Maybe<Array<PriceCategoriesOrderBy>>;
};

/** All input for the `deletePriceCategoryByNodeId` mutation. */
export type DeletePriceCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePriceCategory` mutation. */
export type DeletePriceCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PriceEntry` mutation. */
export type DeletePriceEntryPayload = {
  __typename?: 'DeletePriceEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceEntry` that was deleted by this mutation. */
  priceEntry?: Maybe<PriceEntry>;
  deletedPriceEntryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceSize` that is related to this `PriceEntry`. */
  size?: Maybe<PriceSize>;
  /** An edge for our `PriceEntry`. May be used by Relay 1. */
  priceEntryEdge?: Maybe<PriceEntriesEdge>;
};


/** The output of our delete `PriceEntry` mutation. */
export type DeletePriceEntryPayloadPriceEntryEdgeArgs = {
  orderBy?: Maybe<Array<PriceEntriesOrderBy>>;
};

/** All input for the `deletePriceEntryByNodeId` mutation. */
export type DeletePriceEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePriceEntry` mutation. */
export type DeletePriceEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PriceProduct` mutation. */
export type DeletePriceProductPayload = {
  __typename?: 'DeletePriceProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceProduct` that was deleted by this mutation. */
  priceProduct?: Maybe<PriceProduct>;
  deletedPriceProductNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceCategory` that is related to this `PriceProduct`. */
  category?: Maybe<PriceCategory>;
  /** An edge for our `PriceProduct`. May be used by Relay 1. */
  priceProductEdge?: Maybe<PriceProductsEdge>;
};


/** The output of our delete `PriceProduct` mutation. */
export type DeletePriceProductPayloadPriceProductEdgeArgs = {
  orderBy?: Maybe<Array<PriceProductsOrderBy>>;
};

/** All input for the `deletePriceProductByNodeId` mutation. */
export type DeletePriceProductByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceProduct` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePriceProduct` mutation. */
export type DeletePriceProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PriceSize` mutation. */
export type DeletePriceSizePayload = {
  __typename?: 'DeletePriceSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceSize` that was deleted by this mutation. */
  priceSize?: Maybe<PriceSize>;
  deletedPriceSizeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceProduct` that is related to this `PriceSize`. */
  product?: Maybe<PriceProduct>;
  /** An edge for our `PriceSize`. May be used by Relay 1. */
  priceSizeEdge?: Maybe<PriceSizesEdge>;
};


/** The output of our delete `PriceSize` mutation. */
export type DeletePriceSizePayloadPriceSizeEdgeArgs = {
  orderBy?: Maybe<Array<PriceSizesOrderBy>>;
};

/** All input for the `deletePriceSizeByNodeId` mutation. */
export type DeletePriceSizeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceSize` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePriceSize` mutation. */
export type DeletePriceSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `InventoryItem` mutation. */
export type DeleteInventoryItemPayload = {
  __typename?: 'DeleteInventoryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InventoryItem` that was deleted by this mutation. */
  inventoryItem?: Maybe<InventoryItem>;
  deletedInventoryItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InventoryItem`. May be used by Relay 1. */
  inventoryItemEdge?: Maybe<InventoryItemsEdge>;
};


/** The output of our delete `InventoryItem` mutation. */
export type DeleteInventoryItemPayloadInventoryItemEdgeArgs = {
  orderBy?: Maybe<Array<InventoryItemsOrderBy>>;
};

/** All input for the `deleteInventoryItemByNodeId` mutation. */
export type DeleteInventoryItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `InventoryItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteInventoryItem` mutation. */
export type DeleteInventoryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackAtmosphere` mutation. */
export type DeletePackAtmospherePayload = {
  __typename?: 'DeletePackAtmospherePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackAtmosphere` that was deleted by this mutation. */
  packAtmosphere?: Maybe<PackAtmosphere>;
  deletedPackAtmosphereNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackAtmosphere`. May be used by Relay 1. */
  packAtmosphereEdge?: Maybe<PackAtmospheresEdge>;
};


/** The output of our delete `PackAtmosphere` mutation. */
export type DeletePackAtmospherePayloadPackAtmosphereEdgeArgs = {
  orderBy?: Maybe<Array<PackAtmospheresOrderBy>>;
};

/** All input for the `deletePackAtmosphereByNodeId` mutation. */
export type DeletePackAtmosphereByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackAtmosphere` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackAtmosphere` mutation. */
export type DeletePackAtmosphereInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackAtmosphereByShipperIdAndMaCode` mutation. */
export type DeletePackAtmosphereByShipperIdAndMaCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  maCode: Scalars['String'];
};

/** The output of our delete `PackBoxStyle` mutation. */
export type DeletePackBoxStylePayload = {
  __typename?: 'DeletePackBoxStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxStyle` that was deleted by this mutation. */
  packBoxStyle?: Maybe<PackBoxStyle>;
  deletedPackBoxStyleNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxStyle`. May be used by Relay 1. */
  packBoxStyleEdge?: Maybe<PackBoxStylesEdge>;
};


/** The output of our delete `PackBoxStyle` mutation. */
export type DeletePackBoxStylePayloadPackBoxStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxStylesOrderBy>>;
};

/** All input for the `deletePackBoxStyleByNodeId` mutation. */
export type DeletePackBoxStyleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackBoxStyle` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackBoxStyle` mutation. */
export type DeletePackBoxStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackBoxStyleByShipperIdAndBoxStyle` mutation. */
export type DeletePackBoxStyleByShipperIdAndBoxStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  boxStyle: Scalars['String'];
};

/** The output of our delete `PackBoxType` mutation. */
export type DeletePackBoxTypePayload = {
  __typename?: 'DeletePackBoxTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxType` that was deleted by this mutation. */
  packBoxType?: Maybe<PackBoxType>;
  deletedPackBoxTypeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxType`. May be used by Relay 1. */
  packBoxTypeEdge?: Maybe<PackBoxTypesEdge>;
};


/** The output of our delete `PackBoxType` mutation. */
export type DeletePackBoxTypePayloadPackBoxTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxTypesOrderBy>>;
};

/** All input for the `deletePackBoxTypeByNodeId` mutation. */
export type DeletePackBoxTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackBoxType` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackBoxType` mutation. */
export type DeletePackBoxTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackBoxTypeByShipperIdAndBoxType` mutation. */
export type DeletePackBoxTypeByShipperIdAndBoxTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  boxType: Scalars['String'];
};

/** The output of our delete `PackDestination` mutation. */
export type DeletePackDestinationPayload = {
  __typename?: 'DeletePackDestinationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackDestination` that was deleted by this mutation. */
  packDestination?: Maybe<PackDestination>;
  deletedPackDestinationNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackDestination`. May be used by Relay 1. */
  packDestinationEdge?: Maybe<PackDestinationsEdge>;
};


/** The output of our delete `PackDestination` mutation. */
export type DeletePackDestinationPayloadPackDestinationEdgeArgs = {
  orderBy?: Maybe<Array<PackDestinationsOrderBy>>;
};

/** All input for the `deletePackDestinationByNodeId` mutation. */
export type DeletePackDestinationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackDestination` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackDestination` mutation. */
export type DeletePackDestinationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackDestinationByShipperIdAndDestinationCode` mutation. */
export type DeletePackDestinationByShipperIdAndDestinationCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  destinationCode: Scalars['String'];
};

/** The output of our delete `PackGrade` mutation. */
export type DeletePackGradePayload = {
  __typename?: 'DeletePackGradePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackGrade` that was deleted by this mutation. */
  packGrade?: Maybe<PackGrade>;
  deletedPackGradeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackGrade`. May be used by Relay 1. */
  packGradeEdge?: Maybe<PackGradesEdge>;
};


/** The output of our delete `PackGrade` mutation. */
export type DeletePackGradePayloadPackGradeEdgeArgs = {
  orderBy?: Maybe<Array<PackGradesOrderBy>>;
};

/** All input for the `deletePackGradeByNodeId` mutation. */
export type DeletePackGradeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackGrade` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackGrade` mutation. */
export type DeletePackGradeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackGradeByShipperIdAndGradeCode` mutation. */
export type DeletePackGradeByShipperIdAndGradeCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  gradeCode: Scalars['String'];
};

/** The output of our delete `PackHold` mutation. */
export type DeletePackHoldPayload = {
  __typename?: 'DeletePackHoldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackHold` that was deleted by this mutation. */
  packHold?: Maybe<PackHold>;
  deletedPackHoldNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackHold`. May be used by Relay 1. */
  packHoldEdge?: Maybe<PackHoldsEdge>;
};


/** The output of our delete `PackHold` mutation. */
export type DeletePackHoldPayloadPackHoldEdgeArgs = {
  orderBy?: Maybe<Array<PackHoldsOrderBy>>;
};

/** All input for the `deletePackHoldByNodeId` mutation. */
export type DeletePackHoldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackHold` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackHold` mutation. */
export type DeletePackHoldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackHoldByShipperIdAndHoldCode` mutation. */
export type DeletePackHoldByShipperIdAndHoldCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  holdCode: Scalars['String'];
};

/** The output of our delete `PackLabel` mutation. */
export type DeletePackLabelPayload = {
  __typename?: 'DeletePackLabelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLabel` that was deleted by this mutation. */
  packLabel?: Maybe<PackLabel>;
  deletedPackLabelNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLabel`. May be used by Relay 1. */
  packLabelEdge?: Maybe<PackLabelsEdge>;
};


/** The output of our delete `PackLabel` mutation. */
export type DeletePackLabelPayloadPackLabelEdgeArgs = {
  orderBy?: Maybe<Array<PackLabelsOrderBy>>;
};

/** All input for the `deletePackLabelByNodeId` mutation. */
export type DeletePackLabelByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackLabel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackLabel` mutation. */
export type DeletePackLabelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackLabelByShipperIdAndLabelCode` mutation. */
export type DeletePackLabelByShipperIdAndLabelCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  labelCode: Scalars['String'];
};

/** The output of our delete `PackLiner` mutation. */
export type DeletePackLinerPayload = {
  __typename?: 'DeletePackLinerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLiner` that was deleted by this mutation. */
  packLiner?: Maybe<PackLiner>;
  deletedPackLinerNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLiner`. May be used by Relay 1. */
  packLinerEdge?: Maybe<PackLinersEdge>;
};


/** The output of our delete `PackLiner` mutation. */
export type DeletePackLinerPayloadPackLinerEdgeArgs = {
  orderBy?: Maybe<Array<PackLinersOrderBy>>;
};

/** All input for the `deletePackLinerByNodeId` mutation. */
export type DeletePackLinerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackLiner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackLiner` mutation. */
export type DeletePackLinerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackLinerByShipperIdAndLinerCode` mutation. */
export type DeletePackLinerByShipperIdAndLinerCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  linerCode: Scalars['String'];
};

/** The output of our delete `PackMaster` mutation. */
export type DeletePackMasterPayload = {
  __typename?: 'DeletePackMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackMaster` that was deleted by this mutation. */
  packMaster?: Maybe<PackMaster>;
  deletedPackMasterNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackMaster`. May be used by Relay 1. */
  packMasterEdge?: Maybe<PackMastersEdge>;
};


/** The output of our delete `PackMaster` mutation. */
export type DeletePackMasterPayloadPackMasterEdgeArgs = {
  orderBy?: Maybe<Array<PackMastersOrderBy>>;
};

/** All input for the `deletePackMasterByNodeId` mutation. */
export type DeletePackMasterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackMaster` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackMaster` mutation. */
export type DeletePackMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackOut` mutation. */
export type DeletePackOutPayload = {
  __typename?: 'DeletePackOutPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackOut` that was deleted by this mutation. */
  packOut?: Maybe<PackOut>;
  deletedPackOutNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackOut`. May be used by Relay 1. */
  packOutEdge?: Maybe<PackOutsEdge>;
};


/** The output of our delete `PackOut` mutation. */
export type DeletePackOutPayloadPackOutEdgeArgs = {
  orderBy?: Maybe<Array<PackOutsOrderBy>>;
};

/** All input for the `deletePackOutByNodeId` mutation. */
export type DeletePackOutByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackOut` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackOut` mutation. */
export type DeletePackOutInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackOutByShipperIdAndOutCode` mutation. */
export type DeletePackOutByShipperIdAndOutCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  outCode: Scalars['String'];
};

/** The output of our delete `PackPalletType` mutation. */
export type DeletePackPalletTypePayload = {
  __typename?: 'DeletePackPalletTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackPalletType` that was deleted by this mutation. */
  packPalletType?: Maybe<PackPalletType>;
  deletedPackPalletTypeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackPalletType`. May be used by Relay 1. */
  packPalletTypeEdge?: Maybe<PackPalletTypesEdge>;
};


/** The output of our delete `PackPalletType` mutation. */
export type DeletePackPalletTypePayloadPackPalletTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackPalletTypesOrderBy>>;
};

/** All input for the `deletePackPalletTypeByNodeId` mutation. */
export type DeletePackPalletTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackPalletType` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackPalletType` mutation. */
export type DeletePackPalletTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackPalletTypeByShipperIdAndPalletType` mutation. */
export type DeletePackPalletTypeByShipperIdAndPalletTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  palletType: Scalars['String'];
};

/** The output of our delete `PackProduction` mutation. */
export type DeletePackProductionPayload = {
  __typename?: 'DeletePackProductionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackProduction` that was deleted by this mutation. */
  packProduction?: Maybe<PackProduction>;
  deletedPackProductionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackProduction`. May be used by Relay 1. */
  packProductionEdge?: Maybe<PackProductionsEdge>;
};


/** The output of our delete `PackProduction` mutation. */
export type DeletePackProductionPayloadPackProductionEdgeArgs = {
  orderBy?: Maybe<Array<PackProductionsOrderBy>>;
};

/** All input for the `deletePackProductionByNodeId` mutation. */
export type DeletePackProductionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackProduction` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackProduction` mutation. */
export type DeletePackProductionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackProductionByShipperIdAndProductionCode` mutation. */
export type DeletePackProductionByShipperIdAndProductionCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  productionCode: Scalars['String'];
};

/** The output of our delete `PackSpecial` mutation. */
export type DeletePackSpecialPayload = {
  __typename?: 'DeletePackSpecialPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackSpecial` that was deleted by this mutation. */
  packSpecial?: Maybe<PackSpecial>;
  deletedPackSpecialNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackSpecial`. May be used by Relay 1. */
  packSpecialEdge?: Maybe<PackSpecialsEdge>;
};


/** The output of our delete `PackSpecial` mutation. */
export type DeletePackSpecialPayloadPackSpecialEdgeArgs = {
  orderBy?: Maybe<Array<PackSpecialsOrderBy>>;
};

/** All input for the `deletePackSpecialByNodeId` mutation. */
export type DeletePackSpecialByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackSpecial` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackSpecial` mutation. */
export type DeletePackSpecialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackSpecialByShipperIdAndCustomerCode` mutation. */
export type DeletePackSpecialByShipperIdAndCustomerCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  customerCode: Scalars['String'];
};

/** The output of our delete `PackStyle` mutation. */
export type DeletePackStylePayload = {
  __typename?: 'DeletePackStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackStyle` that was deleted by this mutation. */
  packStyle?: Maybe<PackStyle>;
  deletedPackStyleNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackStyle`. May be used by Relay 1. */
  packStyleEdge?: Maybe<PackStylesEdge>;
};


/** The output of our delete `PackStyle` mutation. */
export type DeletePackStylePayloadPackStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackStylesOrderBy>>;
};

/** All input for the `deletePackStyleByNodeId` mutation. */
export type DeletePackStyleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackStyle` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackStyle` mutation. */
export type DeletePackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackStyleByShipperIdAndPackStyle` mutation. */
export type DeletePackStyleByShipperIdAndPackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  packStyle: Scalars['String'];
};

/** The output of our delete `PackTreeRipe` mutation. */
export type DeletePackTreeRipePayload = {
  __typename?: 'DeletePackTreeRipePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackTreeRipe` that was deleted by this mutation. */
  packTreeRipe?: Maybe<PackTreeRipe>;
  deletedPackTreeRipeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackTreeRipe`. May be used by Relay 1. */
  packTreeRipeEdge?: Maybe<PackTreeRipesEdge>;
};


/** The output of our delete `PackTreeRipe` mutation. */
export type DeletePackTreeRipePayloadPackTreeRipeEdgeArgs = {
  orderBy?: Maybe<Array<PackTreeRipesOrderBy>>;
};

/** All input for the `deletePackTreeRipeByNodeId` mutation. */
export type DeletePackTreeRipeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackTreeRipe` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackTreeRipe` mutation. */
export type DeletePackTreeRipeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deletePackTreeRipeByShipperIdAndTreeRipe` mutation. */
export type DeletePackTreeRipeByShipperIdAndTreeRipeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  treeRipe: Scalars['String'];
};

/** The output of our delete `PalletSection` mutation. */
export type DeletePalletSectionPayload = {
  __typename?: 'DeletePalletSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletSection` that was deleted by this mutation. */
  palletSection?: Maybe<PalletSection>;
  deletedPalletSectionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PalletSection`. May be used by Relay 1. */
  palletSectionEdge?: Maybe<PalletSectionsEdge>;
};


/** The output of our delete `PalletSection` mutation. */
export type DeletePalletSectionPayloadPalletSectionEdgeArgs = {
  orderBy?: Maybe<Array<PalletSectionsOrderBy>>;
};

/** All input for the `deletePalletSectionByNodeId` mutation. */
export type DeletePalletSectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PalletSection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePalletSection` mutation. */
export type DeletePalletSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PalletTempOne` mutation. */
export type DeletePalletTempOnePayload = {
  __typename?: 'DeletePalletTempOnePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletTempOne` that was deleted by this mutation. */
  palletTempOne?: Maybe<PalletTempOne>;
  deletedPalletTempOneNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PalletTempOne`. May be used by Relay 1. */
  palletTempOneEdge?: Maybe<PalletTempOnesEdge>;
};


/** The output of our delete `PalletTempOne` mutation. */
export type DeletePalletTempOnePayloadPalletTempOneEdgeArgs = {
  orderBy?: Maybe<Array<PalletTempOnesOrderBy>>;
};

/** All input for the `deletePalletTempOneByNodeId` mutation. */
export type DeletePalletTempOneByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PalletTempOne` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePalletTempOne` mutation. */
export type DeletePalletTempOneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PalletTempTwo` mutation. */
export type DeletePalletTempTwoPayload = {
  __typename?: 'DeletePalletTempTwoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletTempTwo` that was deleted by this mutation. */
  palletTempTwo?: Maybe<PalletTempTwo>;
  deletedPalletTempTwoNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PalletTempTwo`. May be used by Relay 1. */
  palletTempTwoEdge?: Maybe<PalletTempTwosEdge>;
};


/** The output of our delete `PalletTempTwo` mutation. */
export type DeletePalletTempTwoPayloadPalletTempTwoEdgeArgs = {
  orderBy?: Maybe<Array<PalletTempTwosOrderBy>>;
};

/** All input for the `deletePalletTempTwoByNodeId` mutation. */
export type DeletePalletTempTwoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PalletTempTwo` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePalletTempTwo` mutation. */
export type DeletePalletTempTwoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ProductMaster` mutation. */
export type DeleteProductMasterPayload = {
  __typename?: 'DeleteProductMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductMaster` that was deleted by this mutation. */
  productMaster?: Maybe<ProductMaster>;
  deletedProductMasterNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductMaster`. May be used by Relay 1. */
  productMasterEdge?: Maybe<ProductMastersEdge>;
};


/** The output of our delete `ProductMaster` mutation. */
export type DeleteProductMasterPayloadProductMasterEdgeArgs = {
  orderBy?: Maybe<Array<ProductMastersOrderBy>>;
};

/** All input for the `deleteProductMasterByNodeId` mutation. */
export type DeleteProductMasterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductMaster` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProductMaster` mutation. */
export type DeleteProductMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `ProductSize` mutation. */
export type DeleteProductSizePayload = {
  __typename?: 'DeleteProductSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSize` that was deleted by this mutation. */
  productSize?: Maybe<ProductSize>;
  deletedProductSizeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSize`. May be used by Relay 1. */
  productSizeEdge?: Maybe<ProductSizesEdge>;
};


/** The output of our delete `ProductSize` mutation. */
export type DeleteProductSizePayloadProductSizeEdgeArgs = {
  orderBy?: Maybe<Array<ProductSizesOrderBy>>;
};

/** All input for the `deleteProductSizeByNodeId` mutation. */
export type DeleteProductSizeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductSize` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProductSize` mutation. */
export type DeleteProductSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ProductSpecies` mutation. */
export type DeleteProductSpeciesPayload = {
  __typename?: 'DeleteProductSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSpecies` that was deleted by this mutation. */
  productSpecies?: Maybe<ProductSpecies>;
  deletedProductSpeciesNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSpecies`. May be used by Relay 1. */
  productSpeciesEdge?: Maybe<ProductSpeciesEdge>;
};


/** The output of our delete `ProductSpecies` mutation. */
export type DeleteProductSpeciesPayloadProductSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<ProductSpeciesOrderBy>>;
};

/** All input for the `deleteProductSpeciesByNodeId` mutation. */
export type DeleteProductSpeciesByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductSpecies` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProductSpecies` mutation. */
export type DeleteProductSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `ProductVariety` mutation. */
export type DeleteProductVarietyPayload = {
  __typename?: 'DeleteProductVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductVariety` that was deleted by this mutation. */
  productVariety?: Maybe<ProductVariety>;
  deletedProductVarietyNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductVariety`. May be used by Relay 1. */
  productVarietyEdge?: Maybe<ProductVarietiesEdge>;
};


/** The output of our delete `ProductVariety` mutation. */
export type DeleteProductVarietyPayloadProductVarietyEdgeArgs = {
  orderBy?: Maybe<Array<ProductVarietiesOrderBy>>;
};

/** All input for the `deleteProductVarietyByNodeId` mutation. */
export type DeleteProductVarietyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductVariety` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProductVariety` mutation. */
export type DeleteProductVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `ShipperProjection` mutation. */
export type DeleteShipperProjectionPayload = {
  __typename?: 'DeleteShipperProjectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjection` that was deleted by this mutation. */
  shipperProjection?: Maybe<ShipperProjection>;
  deletedShipperProjectionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjection`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjection`. May be used by Relay 1. */
  shipperProjectionEdge?: Maybe<ShipperProjectionsEdge>;
};


/** The output of our delete `ShipperProjection` mutation. */
export type DeleteShipperProjectionPayloadShipperProjectionEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
};

/** All input for the `deleteShipperProjectionByNodeId` mutation. */
export type DeleteShipperProjectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperProjection` mutation. */
export type DeleteShipperProjectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ShipperProjectionEntry` mutation. */
export type DeleteShipperProjectionEntryPayload = {
  __typename?: 'DeleteShipperProjectionEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionEntry` that was deleted by this mutation. */
  shipperProjectionEntry?: Maybe<ShipperProjectionEntry>;
  deletedShipperProjectionEntryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProjectionVessel` that is related to this `ShipperProjectionEntry`. */
  vessel?: Maybe<ShipperProjectionVessel>;
  /** Reads a single `ShipperProjectionProduct` that is related to this `ShipperProjectionEntry`. */
  product?: Maybe<ShipperProjectionProduct>;
  /** Reads a single `ShipperProjection` that is related to this `ShipperProjectionEntry`. */
  shipperProjection?: Maybe<ShipperProjection>;
  /** An edge for our `ShipperProjectionEntry`. May be used by Relay 1. */
  shipperProjectionEntryEdge?: Maybe<ShipperProjectionEntriesEdge>;
};


/** The output of our delete `ShipperProjectionEntry` mutation. */
export type DeleteShipperProjectionEntryPayloadShipperProjectionEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
};

/** All input for the `deleteShipperProjectionEntryByNodeId` mutation. */
export type DeleteShipperProjectionEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperProjectionEntry` mutation. */
export type DeleteShipperProjectionEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ShipperProjectionProduct` mutation. */
export type DeleteShipperProjectionProductPayload = {
  __typename?: 'DeleteShipperProjectionProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionProduct` that was deleted by this mutation. */
  shipperProjectionProduct?: Maybe<ShipperProjectionProduct>;
  deletedShipperProjectionProductNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionProduct`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjectionProduct`. May be used by Relay 1. */
  shipperProjectionProductEdge?: Maybe<ShipperProjectionProductsEdge>;
};


/** The output of our delete `ShipperProjectionProduct` mutation. */
export type DeleteShipperProjectionProductPayloadShipperProjectionProductEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
};

/** All input for the `deleteShipperProjectionProductByNodeId` mutation. */
export type DeleteShipperProjectionProductByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionProduct` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperProjectionProduct` mutation. */
export type DeleteShipperProjectionProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ShipperProjectionVessel` mutation. */
export type DeleteShipperProjectionVesselPayload = {
  __typename?: 'DeleteShipperProjectionVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVessel` that was deleted by this mutation. */
  shipperProjectionVessel?: Maybe<ShipperProjectionVessel>;
  deletedShipperProjectionVesselNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVessel`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjectionVessel`. May be used by Relay 1. */
  shipperProjectionVesselEdge?: Maybe<ShipperProjectionVesselsEdge>;
};


/** The output of our delete `ShipperProjectionVessel` mutation. */
export type DeleteShipperProjectionVesselPayloadShipperProjectionVesselEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
};

/** All input for the `deleteShipperProjectionVesselByNodeId` mutation. */
export type DeleteShipperProjectionVesselByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionVessel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperProjectionVessel` mutation. */
export type DeleteShipperProjectionVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Vessel` mutation. */
export type DeleteVesselPayload = {
  __typename?: 'DeleteVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vessel` that was deleted by this mutation. */
  vessel?: Maybe<Vessel>;
  deletedVesselNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vessel`. May be used by Relay 1. */
  vesselEdge?: Maybe<VesselsEdge>;
};


/** The output of our delete `Vessel` mutation. */
export type DeleteVesselPayloadVesselEdgeArgs = {
  orderBy?: Maybe<Array<VesselsOrderBy>>;
};

/** All input for the `deleteVesselByNodeId` mutation. */
export type DeleteVesselByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Vessel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVessel` mutation. */
export type DeleteVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our `bulkCreateUserMessage` mutation. */
export type BulkCreateUserMessagePayload = {
  __typename?: 'BulkCreateUserMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  userMessages?: Maybe<Array<Maybe<UserMessage>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkCreateUserMessage` mutation. */
export type BulkCreateUserMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  messages: Array<Maybe<UserMessageInput>>;
};

/** The output of our `bulkAddContactsToGroup` mutation. */
export type BulkAddContactsToGroupPayload = {
  __typename?: 'BulkAddContactsToGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  contactGroupPersonContacts?: Maybe<Array<Maybe<ContactGroupPersonContact>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkAddContactsToGroup` mutation. */
export type BulkAddContactsToGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  items: Array<Maybe<ContactGroupPersonContactInput>>;
};

/** The output of our `bulkRemoveContactGroupPersonContact` mutation. */
export type BulkRemoveContactGroupPersonContactPayload = {
  __typename?: 'BulkRemoveContactGroupPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  contactGroupPersonContacts?: Maybe<Array<Maybe<ContactGroupPersonContact>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkRemoveContactGroupPersonContact` mutation. */
export type BulkRemoveContactGroupPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  items: Array<Maybe<ContactGroupPersonContactInput>>;
};

/** The output of our `batchCreateChileDepartureInspectionPallet` mutation. */
export type BatchCreateChileDepartureInspectionPalletPayload = {
  __typename?: 'BatchCreateChileDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  chileDepartureInspectionPallets?: Maybe<Array<Maybe<ChileDepartureInspectionPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreateChileDepartureInspectionPallet` mutation. */
export type BatchCreateChileDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<ChileDepartureInspectionPalletInput>>;
};

/** The output of our `batchCreatePsaApplePallet` mutation. */
export type BatchCreatePsaApplePalletPayload = {
  __typename?: 'BatchCreatePsaApplePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaApplePallets?: Maybe<Array<Maybe<PsaApplePallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaApplePallet` mutation. */
export type BatchCreatePsaApplePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaApplePalletInput>>;
};

/** The output of our `batchCreatePsaCherryPallet` mutation. */
export type BatchCreatePsaCherryPalletPayload = {
  __typename?: 'BatchCreatePsaCherryPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaCherryPallets?: Maybe<Array<Maybe<PsaCherryPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaCherryPallet` mutation. */
export type BatchCreatePsaCherryPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaCherryPalletInput>>;
};

/** The output of our `batchCreatePsaCitrusPallet` mutation. */
export type BatchCreatePsaCitrusPalletPayload = {
  __typename?: 'BatchCreatePsaCitrusPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaCitrusPallets?: Maybe<Array<Maybe<PsaCitrusPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaCitrusPallet` mutation. */
export type BatchCreatePsaCitrusPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaCitrusPalletInput>>;
};

/** The output of our `batchCreatePsaGrapePallet` mutation. */
export type BatchCreatePsaGrapePalletPayload = {
  __typename?: 'BatchCreatePsaGrapePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaGrapePallets?: Maybe<Array<Maybe<PsaGrapePallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaGrapePallet` mutation. */
export type BatchCreatePsaGrapePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaGrapePalletInput>>;
};

/** The output of our `batchCreatePsaLemonPallet` mutation. */
export type BatchCreatePsaLemonPalletPayload = {
  __typename?: 'BatchCreatePsaLemonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaLemonPallets?: Maybe<Array<Maybe<PsaLemonPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaLemonPallet` mutation. */
export type BatchCreatePsaLemonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaLemonPalletInput>>;
};

/** The output of our `batchCreatePsaPearPallet` mutation. */
export type BatchCreatePsaPearPalletPayload = {
  __typename?: 'BatchCreatePsaPearPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaPearPallets?: Maybe<Array<Maybe<PsaPearPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaPearPallet` mutation. */
export type BatchCreatePsaPearPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaPearPalletInput>>;
};

/** The output of our `batchCreatePsaPersimmonPallet` mutation. */
export type BatchCreatePsaPersimmonPalletPayload = {
  __typename?: 'BatchCreatePsaPersimmonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaPersimmonPallets?: Maybe<Array<Maybe<PsaPersimmonPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaPersimmonPallet` mutation. */
export type BatchCreatePsaPersimmonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaPersimmonPalletInput>>;
};

/** The output of our `batchCreatePsaPomegranatePallet` mutation. */
export type BatchCreatePsaPomegranatePalletPayload = {
  __typename?: 'BatchCreatePsaPomegranatePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaPomegranatePallets?: Maybe<Array<Maybe<PsaPomegranatePallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaPomegranatePallet` mutation. */
export type BatchCreatePsaPomegranatePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaPomegranatePalletInput>>;
};

/** The output of our `batchCreatePsaStoneFruitPallet` mutation. */
export type BatchCreatePsaStoneFruitPalletPayload = {
  __typename?: 'BatchCreatePsaStoneFruitPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaStoneFruitPallets?: Maybe<Array<Maybe<PsaStoneFruitPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaStoneFruitPallet` mutation. */
export type BatchCreatePsaStoneFruitPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaStoneFruitPalletInput>>;
};

/** The output of our `bulkUpsertAgendaItem` mutation. */
export type BulkUpsertAgendaItemPayload = {
  __typename?: 'BulkUpsertAgendaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  agendaItems?: Maybe<Array<Maybe<AgendaItem>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertAgendaItem` mutation. */
export type BulkUpsertAgendaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  items: Array<Maybe<AgendaItemInput>>;
};

/** The output of our `bulkUpsertPriceCategory` mutation. */
export type BulkUpsertPriceCategoryPayload = {
  __typename?: 'BulkUpsertPriceCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  priceCategories?: Maybe<Array<Maybe<PriceCategory>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPriceCategory` mutation. */
export type BulkUpsertPriceCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  categories: Array<Maybe<PriceCategoryInput>>;
};

/** The output of our `bulkUpsertPriceEntry` mutation. */
export type BulkUpsertPriceEntryPayload = {
  __typename?: 'BulkUpsertPriceEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  priceEntries?: Maybe<Array<Maybe<PriceEntry>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPriceEntry` mutation. */
export type BulkUpsertPriceEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  entries: Array<Maybe<PriceEntryInput>>;
};

/** The output of our `bulkUpsertPriceProduct` mutation. */
export type BulkUpsertPriceProductPayload = {
  __typename?: 'BulkUpsertPriceProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  priceProducts?: Maybe<Array<Maybe<PriceProduct>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPriceProduct` mutation. */
export type BulkUpsertPriceProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  products: Array<Maybe<PriceProductInput>>;
};

/** The output of our `bulkUpsertPriceSize` mutation. */
export type BulkUpsertPriceSizePayload = {
  __typename?: 'BulkUpsertPriceSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  priceSizes?: Maybe<Array<Maybe<PriceSize>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPriceSize` mutation. */
export type BulkUpsertPriceSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  sizes: Array<Maybe<PriceSizeInput>>;
};

/** The output of our `deletePriceCategoryEntries` mutation. */
export type DeletePriceCategoryEntriesPayload = {
  __typename?: 'DeletePriceCategoryEntriesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `deletePriceCategoryEntries` mutation. */
export type DeletePriceCategoryEntriesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  selectedCategoryId: Scalars['BigInt'];
  selectedDate: Scalars['Date'];
};

/** The output of our `deletePriceProductEntries` mutation. */
export type DeletePriceProductEntriesPayload = {
  __typename?: 'DeletePriceProductEntriesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `deletePriceProductEntries` mutation. */
export type DeletePriceProductEntriesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  selectedProductId: Scalars['BigInt'];
  selectedDate: Scalars['Date'];
};

/** The output of our `deletePriceSizeEntries` mutation. */
export type DeletePriceSizeEntriesPayload = {
  __typename?: 'DeletePriceSizeEntriesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `deletePriceSizeEntries` mutation. */
export type DeletePriceSizeEntriesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  selectedSizeId: Scalars['BigInt'];
  selectedDate: Scalars['Date'];
};

/** The output of our `bulkDeleteShipperProjectionEntry` mutation. */
export type BulkDeleteShipperProjectionEntryPayload = {
  __typename?: 'BulkDeleteShipperProjectionEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteShipperProjectionEntry` mutation. */
export type BulkDeleteShipperProjectionEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeleteShipperProjectionProduct` mutation. */
export type BulkDeleteShipperProjectionProductPayload = {
  __typename?: 'BulkDeleteShipperProjectionProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteShipperProjectionProduct` mutation. */
export type BulkDeleteShipperProjectionProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkUpsertShipperProjectionEntry` mutation. */
export type BulkUpsertShipperProjectionEntryPayload = {
  __typename?: 'BulkUpsertShipperProjectionEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperProjectionEntries?: Maybe<Array<Maybe<ShipperProjectionEntry>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertShipperProjectionEntry` mutation. */
export type BulkUpsertShipperProjectionEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  entries: Array<Maybe<ShipperProjectionEntryInput>>;
};

/** The output of our `bulkUpsertShipperProjectionProduct` mutation. */
export type BulkUpsertShipperProjectionProductPayload = {
  __typename?: 'BulkUpsertShipperProjectionProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperProjectionProducts?: Maybe<Array<Maybe<ShipperProjectionProduct>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertShipperProjectionProduct` mutation. */
export type BulkUpsertShipperProjectionProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  products: Array<Maybe<ShipperProjectionProductInput>>;
};

/** The output of our `bulkUpsertShipperProjectionVessel` mutation. */
export type BulkUpsertShipperProjectionVesselPayload = {
  __typename?: 'BulkUpsertShipperProjectionVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperProjectionVessels?: Maybe<Array<Maybe<ShipperProjectionVessel>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertShipperProjectionVessel` mutation. */
export type BulkUpsertShipperProjectionVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  vessels: Array<Maybe<ShipperProjectionVesselInput>>;
};

/** The output of our `upsertShipperProjection` mutation. */
export type UpsertShipperProjectionPayload = {
  __typename?: 'UpsertShipperProjectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperProjection?: Maybe<ShipperProjection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjection`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjection`. May be used by Relay 1. */
  shipperProjectionEdge?: Maybe<ShipperProjectionsEdge>;
};


/** The output of our `upsertShipperProjection` mutation. */
export type UpsertShipperProjectionPayloadShipperProjectionEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
};

/** All input for the `upsertShipperProjection` mutation. */
export type UpsertShipperProjectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  projection: ShipperProjectionInput;
};

export type PriceSheetUpdateInput = {
  message: Scalars['String'];
};
